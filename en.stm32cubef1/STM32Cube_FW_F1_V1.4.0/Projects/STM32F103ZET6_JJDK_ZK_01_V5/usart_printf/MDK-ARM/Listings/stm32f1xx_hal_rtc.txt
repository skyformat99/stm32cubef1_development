; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_rtc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_rtc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_rtc.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;1491     */
;;;1492   static HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef* hrtc)
000000  b570              PUSH     {r4-r6,lr}
;;;1493   {
000002  4604              MOV      r4,r0
;;;1494     uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;1495     
;;;1496     /* Disable the write protection for RTC registers */
;;;1497     __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
000006  6820              LDR      r0,[r4,#0]
000008  6840              LDR      r0,[r0,#4]
00000a  f0200010          BIC      r0,r0,#0x10
00000e  6821              LDR      r1,[r4,#0]
000010  6048              STR      r0,[r1,#4]
;;;1498     
;;;1499     tickstart = HAL_GetTick();
000012  f7fffffe          BL       HAL_GetTick
000016  4605              MOV      r5,r0
;;;1500     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1501     while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
000018  e007              B        |L1.42|
                  |L1.26|
;;;1502     {
;;;1503       if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
00001a  f7fffffe          BL       HAL_GetTick
00001e  1b40              SUBS     r0,r0,r5
000020  f5b07f7a          CMP      r0,#0x3e8
000024  d901              BLS      |L1.42|
;;;1504       {       
;;;1505         return HAL_TIMEOUT;
000026  2003              MOVS     r0,#3
                  |L1.40|
;;;1506       } 
;;;1507     }
;;;1508     
;;;1509     return HAL_OK;  
;;;1510   }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  6820              LDR      r0,[r4,#0]            ;1501
00002c  6840              LDR      r0,[r0,#4]            ;1501
00002e  f0000020          AND      r0,r0,#0x20           ;1501
000032  2800              CMP      r0,#0                 ;1501
000034  d0f1              BEQ      |L1.26|
000036  2000              MOVS     r0,#0                 ;1509
000038  e7f6              B        |L1.40|
;;;1511   
                          ENDP

                  RTC_EnterInitMode PROC
;;;1464     */
;;;1465   static HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
00003a  b570              PUSH     {r4-r6,lr}
;;;1466   {
00003c  4604              MOV      r4,r0
;;;1467     uint32_t tickstart = 0;
00003e  2500              MOVS     r5,#0
;;;1468     
;;;1469     tickstart = HAL_GetTick();
000040  f7fffffe          BL       HAL_GetTick
000044  4605              MOV      r5,r0
;;;1470     /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;1471     while((hrtc->Instance->CRL & RTC_CRL_RTOFF) == (uint32_t)RESET)
000046  e007              B        |L1.88|
                  |L1.72|
;;;1472     {
;;;1473       if((HAL_GetTick() - tickstart) >  RTC_TIMEOUT_VALUE)
000048  f7fffffe          BL       HAL_GetTick
00004c  1b40              SUBS     r0,r0,r5
00004e  f5b07f7a          CMP      r0,#0x3e8
000052  d901              BLS      |L1.88|
;;;1474       {       
;;;1475         return HAL_TIMEOUT;
000054  2003              MOVS     r0,#3
                  |L1.86|
;;;1476       } 
;;;1477     }
;;;1478   
;;;1479     /* Disable the write protection for RTC registers */
;;;1480     __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
;;;1481     
;;;1482     
;;;1483     return HAL_OK;  
;;;1484   }
000056  bd70              POP      {r4-r6,pc}
                  |L1.88|
000058  6820              LDR      r0,[r4,#0]            ;1471
00005a  6840              LDR      r0,[r0,#4]            ;1471
00005c  f0000020          AND      r0,r0,#0x20           ;1471
000060  2800              CMP      r0,#0                 ;1471
000062  d0f1              BEQ      |L1.72|
000064  6820              LDR      r0,[r4,#0]            ;1480
000066  6840              LDR      r0,[r0,#4]            ;1480
000068  f0400010          ORR      r0,r0,#0x10           ;1480
00006c  6821              LDR      r1,[r4,#0]            ;1480
00006e  6048              STR      r0,[r1,#4]            ;1480
000070  2000              MOVS     r0,#0                 ;1483
000072  e7f0              B        |L1.86|
;;;1485   
                          ENDP

                  HAL_RTC_WaitForSynchro PROC
;;;1306     */
;;;1307   HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
000074  b570              PUSH     {r4-r6,lr}
;;;1308   {
000076  4604              MOV      r4,r0
;;;1309     uint32_t tickstart = 0;
000078  2500              MOVS     r5,#0
;;;1310     
;;;1311     /* Check input parameters */
;;;1312     if(hrtc == NULL)
00007a  b90c              CBNZ     r4,|L1.128|
;;;1313     {
;;;1314        return HAL_ERROR;
00007c  2001              MOVS     r0,#1
                  |L1.126|
;;;1315     }
;;;1316     
;;;1317     /* Clear RSF flag */
;;;1318     CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
;;;1319     
;;;1320     tickstart = HAL_GetTick();
;;;1321     
;;;1322     /* Wait the registers to be synchronised */
;;;1323     while((hrtc->Instance->CRL & RTC_FLAG_RSF) == (uint32_t)RESET)
;;;1324     {
;;;1325       if((HAL_GetTick() - tickstart ) >  RTC_TIMEOUT_VALUE)
;;;1326       {       
;;;1327         return HAL_TIMEOUT;
;;;1328       } 
;;;1329     }
;;;1330     
;;;1331     return HAL_OK;
;;;1332   }
00007e  bd70              POP      {r4-r6,pc}
                  |L1.128|
000080  6820              LDR      r0,[r4,#0]            ;1318
000082  6840              LDR      r0,[r0,#4]            ;1318
000084  f0200008          BIC      r0,r0,#8              ;1318
000088  6821              LDR      r1,[r4,#0]            ;1318
00008a  6048              STR      r0,[r1,#4]            ;1318
00008c  f7fffffe          BL       HAL_GetTick
000090  4605              MOV      r5,r0                 ;1320
000092  e007              B        |L1.164|
                  |L1.148|
000094  f7fffffe          BL       HAL_GetTick
000098  1b40              SUBS     r0,r0,r5              ;1325
00009a  f5b07f7a          CMP      r0,#0x3e8             ;1325
00009e  d901              BLS      |L1.164|
0000a0  2003              MOVS     r0,#3                 ;1327
0000a2  e7ec              B        |L1.126|
                  |L1.164|
0000a4  6820              LDR      r0,[r4,#0]            ;1323
0000a6  6840              LDR      r0,[r0,#4]            ;1323
0000a8  f0000008          AND      r0,r0,#8              ;1323
0000ac  2800              CMP      r0,#0                 ;1323
0000ae  d0f1              BEQ      |L1.148|
0000b0  2000              MOVS     r0,#0                 ;1331
0000b2  e7e4              B        |L1.126|
;;;1333   
                          ENDP

                  HAL_RTC_MspInit PROC
;;;426      */
;;;427    __weak void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
0000b4  4770              BX       lr
;;;428    {
;;;429      /* Prevent unused argument(s) compilation warning */
;;;430      UNUSED(hrtc);
;;;431      /* NOTE : This function Should not be modified, when the callback is needed,
;;;432                the HAL_RTC_MspInit could be implemented in the user file
;;;433       */ 
;;;434    }
;;;435    
                          ENDP

                  HAL_RTC_Init PROC
;;;243      */
;;;244    HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
0000b6  b570              PUSH     {r4-r6,lr}
;;;245    {
0000b8  4604              MOV      r4,r0
;;;246      uint32_t prescaler = 0;
0000ba  2500              MOVS     r5,#0
;;;247      /* Check input parameters */
;;;248      if(hrtc == NULL)
0000bc  b90c              CBNZ     r4,|L1.194|
;;;249      {
;;;250         return HAL_ERROR;
0000be  2001              MOVS     r0,#1
                  |L1.192|
;;;251      }
;;;252      
;;;253      /* Check the parameters */
;;;254      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;255      assert_param(IS_RTC_CALIB_OUTPUT(hrtc->Init.OutPut));
;;;256      assert_param(IS_RTC_ASYNCH_PREDIV(hrtc->Init.AsynchPrediv));
;;;257        
;;;258      if(hrtc->State == HAL_RTC_STATE_RESET)
;;;259      {
;;;260        /* Allocate lock resource and initialize it */
;;;261        hrtc->Lock = HAL_UNLOCKED;
;;;262        
;;;263        /* Initialize RTC MSP */
;;;264        HAL_RTC_MspInit(hrtc);
;;;265      }
;;;266      
;;;267      /* Set RTC state */  
;;;268      hrtc->State = HAL_RTC_STATE_BUSY;  
;;;269           
;;;270      /* Waiting for synchro */
;;;271      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
;;;272      {
;;;273        /* Set RTC state */
;;;274        hrtc->State = HAL_RTC_STATE_ERROR;
;;;275        
;;;276        return HAL_ERROR;
;;;277      } 
;;;278    
;;;279      /* Set Initialization mode */
;;;280      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;281      {
;;;282        /* Set RTC state */
;;;283        hrtc->State = HAL_RTC_STATE_ERROR;
;;;284        
;;;285        return HAL_ERROR;
;;;286      } 
;;;287      else
;;;288      { 
;;;289        /* Clear Flags Bits */
;;;290        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_OW | RTC_FLAG_ALRAF | RTC_FLAG_SEC));
;;;291        
;;;292        if(hrtc->Init.OutPut != RTC_OUTPUTSOURCE_NONE)
;;;293        {
;;;294          /* Disable the selected Tamper pin */
;;;295          CLEAR_BIT(BKP->CR, BKP_CR_TPE);
;;;296        }
;;;297        
;;;298        /* Set the signal which will be routed to RTC Tamper pin*/
;;;299        MODIFY_REG(BKP->RTCCR, (BKP_RTCCR_CCO | BKP_RTCCR_ASOE | BKP_RTCCR_ASOS), hrtc->Init.OutPut);
;;;300    
;;;301        if (hrtc->Init.AsynchPrediv != RTC_AUTO_1_SECOND)
;;;302        {
;;;303          /* RTC Prescaler provided directly by end-user*/
;;;304          prescaler = hrtc->Init.AsynchPrediv;
;;;305        }
;;;306        else
;;;307        {
;;;308          /* RTC Prescaler will be automatically calculated to get 1 second timebase */
;;;309          /* Get the RTCCLK frequency */
;;;310          prescaler = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_RTC);
;;;311    
;;;312          /* Check that RTC clock is enabled*/
;;;313          if (prescaler == 0)
;;;314          {
;;;315            /* Should not happen. Frequency is not available*/
;;;316            hrtc->State = HAL_RTC_STATE_ERROR;
;;;317            return HAL_ERROR;
;;;318          }
;;;319          else
;;;320          {
;;;321            /* RTC period = RTCCLK/(RTC_PR + 1) */
;;;322            prescaler = prescaler - 1;
;;;323          }
;;;324        }
;;;325        
;;;326        /* Configure the RTC_PRLH / RTC_PRLL */
;;;327        MODIFY_REG(hrtc->Instance->PRLH, RTC_PRLH_PRL, (prescaler >> 16));
;;;328        MODIFY_REG(hrtc->Instance->PRLL, RTC_PRLL_PRL, (prescaler & RTC_PRLL_PRL));
;;;329          
;;;330        /* Wait for synchro */
;;;331        if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;332        {       
;;;333          hrtc->State = HAL_RTC_STATE_ERROR;
;;;334          
;;;335          return HAL_ERROR;
;;;336        }
;;;337        
;;;338        /* Initialize date to 1st of January 2000 */
;;;339        hrtc->DateToUpdate.Year = 0x00;
;;;340        hrtc->DateToUpdate.Month = RTC_MONTH_JANUARY;
;;;341        hrtc->DateToUpdate.Date = 0x01;
;;;342    
;;;343        /* Set RTC state */
;;;344        hrtc->State = HAL_RTC_STATE_READY;
;;;345        
;;;346        return HAL_OK;
;;;347      }
;;;348    }
0000c0  bd70              POP      {r4-r6,pc}
                  |L1.194|
0000c2  7c60              LDRB     r0,[r4,#0x11]         ;258
0000c4  b920              CBNZ     r0,|L1.208|
0000c6  2000              MOVS     r0,#0                 ;261
0000c8  7420              STRB     r0,[r4,#0x10]         ;261
0000ca  4620              MOV      r0,r4                 ;264
0000cc  f7fffffe          BL       HAL_RTC_MspInit
                  |L1.208|
0000d0  2002              MOVS     r0,#2                 ;268
0000d2  7460              STRB     r0,[r4,#0x11]         ;268
0000d4  4620              MOV      r0,r4                 ;271
0000d6  f7fffffe          BL       HAL_RTC_WaitForSynchro
0000da  b118              CBZ      r0,|L1.228|
0000dc  2004              MOVS     r0,#4                 ;274
0000de  7460              STRB     r0,[r4,#0x11]         ;274
0000e0  2001              MOVS     r0,#1                 ;276
0000e2  e7ed              B        |L1.192|
                  |L1.228|
0000e4  4620              MOV      r0,r4                 ;280
0000e6  f7fffffe          BL       RTC_EnterInitMode
0000ea  b118              CBZ      r0,|L1.244|
0000ec  2004              MOVS     r0,#4                 ;283
0000ee  7460              STRB     r0,[r4,#0x11]         ;283
0000f0  2001              MOVS     r0,#1                 ;285
0000f2  e7e5              B        |L1.192|
                  |L1.244|
0000f4  6820              LDR      r0,[r4,#0]            ;290
0000f6  6840              LDR      r0,[r0,#4]            ;290
0000f8  f0200007          BIC      r0,r0,#7              ;290
0000fc  6821              LDR      r1,[r4,#0]            ;290
0000fe  6048              STR      r0,[r1,#4]            ;290
000100  68a0              LDR      r0,[r4,#8]            ;292
000102  b128              CBZ      r0,|L1.272|
000104  48fb              LDR      r0,|L1.1268|
000106  6800              LDR      r0,[r0,#0]            ;295
000108  f0200001          BIC      r0,r0,#1              ;295
00010c  49f9              LDR      r1,|L1.1268|
00010e  6008              STR      r0,[r1,#0]            ;295
                  |L1.272|
000110  48f8              LDR      r0,|L1.1268|
000112  1f00              SUBS     r0,r0,#4              ;299
000114  6800              LDR      r0,[r0,#0]            ;299
000116  f4207060          BIC      r0,r0,#0x380          ;299
00011a  68a1              LDR      r1,[r4,#8]            ;299
00011c  4308              ORRS     r0,r0,r1              ;299
00011e  49f5              LDR      r1,|L1.1268|
000120  1f09              SUBS     r1,r1,#4              ;299
000122  6008              STR      r0,[r1,#0]            ;299
000124  6860              LDR      r0,[r4,#4]            ;301
000126  1c40              ADDS     r0,r0,#1              ;301
000128  b108              CBZ      r0,|L1.302|
00012a  6865              LDR      r5,[r4,#4]            ;304
00012c  e009              B        |L1.322|
                  |L1.302|
00012e  2001              MOVS     r0,#1                 ;310
000130  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
000134  4605              MOV      r5,r0                 ;310
000136  b91d              CBNZ     r5,|L1.320|
000138  2004              MOVS     r0,#4                 ;316
00013a  7460              STRB     r0,[r4,#0x11]         ;316
00013c  2001              MOVS     r0,#1                 ;317
00013e  e7bf              B        |L1.192|
                  |L1.320|
000140  1e6d              SUBS     r5,r5,#1              ;322
                  |L1.322|
000142  6820              LDR      r0,[r4,#0]            ;327
000144  6880              LDR      r0,[r0,#8]            ;327
000146  f020000f          BIC      r0,r0,#0xf            ;327
00014a  ea404015          ORR      r0,r0,r5,LSR #16      ;327
00014e  6821              LDR      r1,[r4,#0]            ;327
000150  6088              STR      r0,[r1,#8]            ;327
000152  6820              LDR      r0,[r4,#0]            ;328
000154  68c0              LDR      r0,[r0,#0xc]          ;328
000156  f365000f          BFI      r0,r5,#0,#16          ;328
00015a  6821              LDR      r1,[r4,#0]            ;328
00015c  60c8              STR      r0,[r1,#0xc]          ;328
00015e  4620              MOV      r0,r4                 ;331
000160  f7fffffe          BL       RTC_ExitInitMode
000164  b118              CBZ      r0,|L1.366|
000166  2004              MOVS     r0,#4                 ;333
000168  7460              STRB     r0,[r4,#0x11]         ;333
00016a  2001              MOVS     r0,#1                 ;335
00016c  e7a8              B        |L1.192|
                  |L1.366|
00016e  2100              MOVS     r1,#0                 ;339
000170  73e1              STRB     r1,[r4,#0xf]          ;339
000172  2101              MOVS     r1,#1                 ;340
000174  7361              STRB     r1,[r4,#0xd]          ;340
000176  73a1              STRB     r1,[r4,#0xe]          ;341
000178  2001              MOVS     r0,#1                 ;344
00017a  7460              STRB     r0,[r4,#0x11]         ;344
00017c  2000              MOVS     r0,#0                 ;346
00017e  e79f              B        |L1.192|
;;;349    
                          ENDP

                  HAL_RTC_MspDeInit PROC
;;;441      */
;;;442    __weak void HAL_RTC_MspDeInit(RTC_HandleTypeDef* hrtc)
000180  4770              BX       lr
;;;443    {
;;;444      /* Prevent unused argument(s) compilation warning */
;;;445      UNUSED(hrtc);
;;;446      /* NOTE : This function Should not be modified, when the callback is needed,
;;;447                the HAL_RTC_MspDeInit could be implemented in the user file
;;;448       */ 
;;;449    }
;;;450    
                          ENDP

                  HAL_RTC_DeInit PROC
;;;356      */
;;;357    HAL_StatusTypeDef HAL_RTC_DeInit(RTC_HandleTypeDef *hrtc)
000182  b510              PUSH     {r4,lr}
;;;358    {
000184  4604              MOV      r4,r0
;;;359      /* Check input parameters */
;;;360      if(hrtc == NULL)
000186  b90c              CBNZ     r4,|L1.396|
;;;361      {
;;;362         return HAL_ERROR;
000188  2001              MOVS     r0,#1
                  |L1.394|
;;;363      }
;;;364      
;;;365      /* Check the parameters */
;;;366      assert_param(IS_RTC_ALL_INSTANCE(hrtc->Instance));
;;;367    
;;;368      /* Set RTC state */
;;;369      hrtc->State = HAL_RTC_STATE_BUSY; 
;;;370      
;;;371      /* Set Initialization mode */
;;;372      if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;373      {
;;;374        /* Set RTC state */
;;;375        hrtc->State = HAL_RTC_STATE_ERROR;
;;;376        
;;;377        /* Release Lock */
;;;378        __HAL_UNLOCK(hrtc);
;;;379    
;;;380        return HAL_ERROR;
;;;381      }  
;;;382      else
;;;383      {
;;;384        CLEAR_REG(hrtc->Instance->CNTL);
;;;385        CLEAR_REG(hrtc->Instance->CNTH);
;;;386        WRITE_REG(hrtc->Instance->PRLL, 0x00008000);
;;;387        CLEAR_REG(hrtc->Instance->PRLH);
;;;388    
;;;389        /* Reset All CRH/CRL bits */
;;;390        CLEAR_REG(hrtc->Instance->CRH);
;;;391        CLEAR_REG(hrtc->Instance->CRL);
;;;392        
;;;393        if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;394        {       
;;;395          hrtc->State = HAL_RTC_STATE_ERROR;
;;;396          
;;;397          /* Process Unlocked */ 
;;;398          __HAL_UNLOCK(hrtc);
;;;399          
;;;400          return HAL_ERROR;
;;;401        }
;;;402      }
;;;403    
;;;404      /* Wait for synchro*/
;;;405      HAL_RTC_WaitForSynchro(hrtc);
;;;406    
;;;407      /* Clear RSF flag */
;;;408      CLEAR_BIT(hrtc->Instance->CRL, RTC_FLAG_RSF);
;;;409        
;;;410      /* De-Initialize RTC MSP */
;;;411      HAL_RTC_MspDeInit(hrtc);
;;;412    
;;;413      hrtc->State = HAL_RTC_STATE_RESET; 
;;;414      
;;;415      /* Release Lock */
;;;416      __HAL_UNLOCK(hrtc);
;;;417    
;;;418      return HAL_OK;
;;;419    }
00018a  bd10              POP      {r4,pc}
                  |L1.396|
00018c  2002              MOVS     r0,#2                 ;369
00018e  7460              STRB     r0,[r4,#0x11]         ;369
000190  4620              MOV      r0,r4                 ;372
000192  f7fffffe          BL       RTC_EnterInitMode
000196  b138              CBZ      r0,|L1.424|
000198  2004              MOVS     r0,#4                 ;375
00019a  7460              STRB     r0,[r4,#0x11]         ;375
00019c  bf00              NOP                            ;378
00019e  2000              MOVS     r0,#0                 ;378
0001a0  7420              STRB     r0,[r4,#0x10]         ;378
0001a2  bf00              NOP                            ;378
0001a4  2001              MOVS     r0,#1                 ;380
0001a6  e7f0              B        |L1.394|
                  |L1.424|
0001a8  2000              MOVS     r0,#0                 ;384
0001aa  6821              LDR      r1,[r4,#0]            ;384
0001ac  61c8              STR      r0,[r1,#0x1c]         ;384
0001ae  6821              LDR      r1,[r4,#0]            ;385
0001b0  6188              STR      r0,[r1,#0x18]         ;385
0001b2  f44f4000          MOV      r0,#0x8000            ;386
0001b6  6821              LDR      r1,[r4,#0]            ;386
0001b8  60c8              STR      r0,[r1,#0xc]          ;386
0001ba  2000              MOVS     r0,#0                 ;387
0001bc  6821              LDR      r1,[r4,#0]            ;387
0001be  6088              STR      r0,[r1,#8]            ;387
0001c0  6821              LDR      r1,[r4,#0]            ;390
0001c2  6008              STR      r0,[r1,#0]            ;390
0001c4  6821              LDR      r1,[r4,#0]            ;391
0001c6  6048              STR      r0,[r1,#4]            ;391
0001c8  4620              MOV      r0,r4                 ;393
0001ca  f7fffffe          BL       RTC_ExitInitMode
0001ce  b138              CBZ      r0,|L1.480|
0001d0  2004              MOVS     r0,#4                 ;395
0001d2  7460              STRB     r0,[r4,#0x11]         ;395
0001d4  bf00              NOP                            ;398
0001d6  2000              MOVS     r0,#0                 ;398
0001d8  7420              STRB     r0,[r4,#0x10]         ;398
0001da  bf00              NOP                            ;398
0001dc  2001              MOVS     r0,#1                 ;400
0001de  e7d4              B        |L1.394|
                  |L1.480|
0001e0  4620              MOV      r0,r4                 ;405
0001e2  f7fffffe          BL       HAL_RTC_WaitForSynchro
0001e6  6820              LDR      r0,[r4,#0]            ;408
0001e8  6840              LDR      r0,[r0,#4]            ;408
0001ea  f0200008          BIC      r0,r0,#8              ;408
0001ee  6821              LDR      r1,[r4,#0]            ;408
0001f0  6048              STR      r0,[r1,#4]            ;408
0001f2  4620              MOV      r0,r4                 ;411
0001f4  f7fffffe          BL       HAL_RTC_MspDeInit
0001f8  2000              MOVS     r0,#0                 ;413
0001fa  7460              STRB     r0,[r4,#0x11]         ;413
0001fc  bf00              NOP                            ;416
0001fe  7420              STRB     r0,[r4,#0x10]         ;416
000200  bf00              NOP                            ;416
000202  bf00              NOP                            ;418
000204  e7c1              B        |L1.394|
;;;420    
                          ENDP

                  RTC_WriteAlarmCounter PROC
;;;1432     */
;;;1433   static HAL_StatusTypeDef RTC_WriteAlarmCounter(RTC_HandleTypeDef* hrtc, uint32_t AlarmCounter)
000206  b570              PUSH     {r4-r6,lr}
;;;1434   {
000208  4604              MOV      r4,r0
00020a  460d              MOV      r5,r1
;;;1435     HAL_StatusTypeDef status = HAL_OK;
00020c  2600              MOVS     r6,#0
;;;1436     
;;;1437     /* Set Initialization mode */
;;;1438     if(RTC_EnterInitMode(hrtc) != HAL_OK)
00020e  4620              MOV      r0,r4
000210  f7fffffe          BL       RTC_EnterInitMode
000214  b108              CBZ      r0,|L1.538|
;;;1439     {
;;;1440       status = HAL_ERROR;
000216  2601              MOVS     r6,#1
000218  e00a              B        |L1.560|
                  |L1.538|
;;;1441     } 
;;;1442     else
;;;1443     {
;;;1444       /* Set RTC COUNTER MSB word */
;;;1445       WRITE_REG(hrtc->Instance->ALRH, (AlarmCounter >> 16));
00021a  0c28              LSRS     r0,r5,#16
00021c  6821              LDR      r1,[r4,#0]
00021e  6208              STR      r0,[r1,#0x20]
;;;1446       /* Set RTC COUNTER LSB word */
;;;1447       WRITE_REG(hrtc->Instance->ALRL, (AlarmCounter & RTC_ALRL_RTC_ALR));
000220  b2a8              UXTH     r0,r5
000222  6821              LDR      r1,[r4,#0]
000224  6248              STR      r0,[r1,#0x24]
;;;1448       
;;;1449       /* Wait for synchro */
;;;1450       if(RTC_ExitInitMode(hrtc) != HAL_OK)
000226  4620              MOV      r0,r4
000228  f7fffffe          BL       RTC_ExitInitMode
00022c  b100              CBZ      r0,|L1.560|
;;;1451       {       
;;;1452         status = HAL_ERROR;
00022e  2601              MOVS     r6,#1
                  |L1.560|
;;;1453       }
;;;1454     }
;;;1455   
;;;1456     return status;
000230  4630              MOV      r0,r6
;;;1457   }
000232  bd70              POP      {r4-r6,pc}
;;;1458   
                          ENDP

                  RTC_ReadAlarmCounter PROC
;;;1415     */
;;;1416   static uint32_t RTC_ReadAlarmCounter(RTC_HandleTypeDef* hrtc)
000234  4601              MOV      r1,r0
;;;1417   {
;;;1418     uint16_t high1 = 0, low = 0;
000236  2200              MOVS     r2,#0
000238  2300              MOVS     r3,#0
;;;1419   
;;;1420     high1 = READ_REG(hrtc->Instance->ALRH & RTC_CNTH_RTC_CNT);
00023a  6808              LDR      r0,[r1,#0]
00023c  6a00              LDR      r0,[r0,#0x20]
00023e  b282              UXTH     r2,r0
;;;1421     low   = READ_REG(hrtc->Instance->ALRL & RTC_CNTL_RTC_CNT);
000240  6808              LDR      r0,[r1,#0]
000242  6a40              LDR      r0,[r0,#0x24]
000244  b283              UXTH     r3,r0
;;;1422   
;;;1423     return (((uint32_t) high1 << 16 ) | low);
000246  ea434002          ORR      r0,r3,r2,LSL #16
;;;1424   }
00024a  4770              BX       lr
;;;1425   
                          ENDP

                  RTC_WriteTimeCounter PROC
;;;1383     */
;;;1384   static HAL_StatusTypeDef RTC_WriteTimeCounter(RTC_HandleTypeDef* hrtc, uint32_t TimeCounter)
00024c  b570              PUSH     {r4-r6,lr}
;;;1385   {
00024e  4604              MOV      r4,r0
000250  460d              MOV      r5,r1
;;;1386     HAL_StatusTypeDef status = HAL_OK;
000252  2600              MOVS     r6,#0
;;;1387     
;;;1388     /* Set Initialization mode */
;;;1389     if(RTC_EnterInitMode(hrtc) != HAL_OK)
000254  4620              MOV      r0,r4
000256  f7fffffe          BL       RTC_EnterInitMode
00025a  b108              CBZ      r0,|L1.608|
;;;1390     {
;;;1391       status = HAL_ERROR;
00025c  2601              MOVS     r6,#1
00025e  e00a              B        |L1.630|
                  |L1.608|
;;;1392     } 
;;;1393     else
;;;1394     {
;;;1395       /* Set RTC COUNTER MSB word */
;;;1396       WRITE_REG(hrtc->Instance->CNTH, (TimeCounter >> 16));
000260  0c28              LSRS     r0,r5,#16
000262  6821              LDR      r1,[r4,#0]
000264  6188              STR      r0,[r1,#0x18]
;;;1397       /* Set RTC COUNTER LSB word */
;;;1398       WRITE_REG(hrtc->Instance->CNTL, (TimeCounter & RTC_CNTL_RTC_CNT));
000266  b2a8              UXTH     r0,r5
000268  6821              LDR      r1,[r4,#0]
00026a  61c8              STR      r0,[r1,#0x1c]
;;;1399       
;;;1400       /* Wait for synchro */
;;;1401       if(RTC_ExitInitMode(hrtc) != HAL_OK)
00026c  4620              MOV      r0,r4
00026e  f7fffffe          BL       RTC_ExitInitMode
000272  b100              CBZ      r0,|L1.630|
;;;1402       {       
;;;1403         status = HAL_ERROR;
000274  2601              MOVS     r6,#1
                  |L1.630|
;;;1404       }
;;;1405     }
;;;1406   
;;;1407     return status;
000276  4630              MOV      r0,r6
;;;1408   }
000278  bd70              POP      {r4-r6,pc}
;;;1409   
                          ENDP

                  RTC_Bcd2ToByte PROC
;;;1534     */
;;;1535   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
00027a  4601              MOV      r1,r0
;;;1536   {
;;;1537     uint32_t tmp = 0;
00027c  bf00              NOP      
;;;1538     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
00027e  0908              LSRS     r0,r1,#4
000280  eb000080          ADD      r0,r0,r0,LSL #2
000284  0042              LSLS     r2,r0,#1
;;;1539     return (tmp + (Value & (uint8_t)0x0F));
000286  f001000f          AND      r0,r1,#0xf
00028a  4410              ADD      r0,r0,r2
00028c  b2c0              UXTB     r0,r0
;;;1540   }
00028e  4770              BX       lr
;;;1541   
                          ENDP

                  HAL_RTC_SetTime PROC
;;;479      */
;;;480    HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000290  e92d47f0          PUSH     {r4-r10,lr}
;;;481    {
000294  4604              MOV      r4,r0
000296  460d              MOV      r5,r1
000298  4690              MOV      r8,r2
;;;482      uint32_t counter_time = 0, counter_alarm = 0;
00029a  2600              MOVS     r6,#0
00029c  2700              MOVS     r7,#0
;;;483      
;;;484      /* Check input parameters */
;;;485      if((hrtc == NULL) || (sTime == NULL))
00029e  b104              CBZ      r4,|L1.674|
0002a0  b915              CBNZ     r5,|L1.680|
                  |L1.674|
;;;486      {
;;;487         return HAL_ERROR;
0002a2  2001              MOVS     r0,#1
                  |L1.676|
;;;488      }
;;;489      
;;;490     /* Check the parameters */
;;;491      assert_param(IS_RTC_FORMAT(Format));
;;;492      
;;;493      /* Process Locked */ 
;;;494      __HAL_LOCK(hrtc);
;;;495      
;;;496      hrtc->State = HAL_RTC_STATE_BUSY;
;;;497      
;;;498      if(Format == RTC_FORMAT_BIN)
;;;499      {
;;;500        assert_param(IS_RTC_HOUR24(sTime->Hours));
;;;501        assert_param(IS_RTC_MINUTES(sTime->Minutes));
;;;502        assert_param(IS_RTC_SECONDS(sTime->Seconds));
;;;503    
;;;504        counter_time = (uint32_t)(((uint32_t)sTime->Hours * 3600) + \
;;;505                            ((uint32_t)sTime->Minutes * 60) + \
;;;506                            ((uint32_t)sTime->Seconds));  
;;;507      }
;;;508      else
;;;509      {
;;;510        assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
;;;511        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
;;;512        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
;;;513    
;;;514        counter_time = (((uint32_t)(RTC_Bcd2ToByte(sTime->Hours)) * 3600) + \
;;;515                  ((uint32_t)(RTC_Bcd2ToByte(sTime->Minutes)) * 60) + \
;;;516                  ((uint32_t)(RTC_Bcd2ToByte(sTime->Seconds))));   
;;;517      }
;;;518    
;;;519      /* Write time counter in RTC registers */
;;;520      if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
;;;521      {
;;;522        /* Set RTC state */
;;;523        hrtc->State = HAL_RTC_STATE_ERROR;
;;;524        
;;;525        /* Process Unlocked */ 
;;;526        __HAL_UNLOCK(hrtc);
;;;527        
;;;528        return HAL_ERROR;
;;;529      }
;;;530      else
;;;531      {
;;;532        /* Clear Second and overflow flags */
;;;533        CLEAR_BIT(hrtc->Instance->CRL, (RTC_FLAG_SEC | RTC_FLAG_OW));
;;;534        
;;;535        /* Read current Alarm counter in RTC registers */
;;;536        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;537    
;;;538        /* Set again alarm to match with new time if enabled */
;;;539        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;540        {
;;;541          if(counter_alarm < counter_time)
;;;542          {
;;;543            /* Add 1 day to alarm counter*/
;;;544            counter_alarm += (uint32_t)(24 * 3600);
;;;545            
;;;546            /* Write new Alarm counter in RTC registers */
;;;547            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;548            {
;;;549              /* Set RTC state */
;;;550              hrtc->State = HAL_RTC_STATE_ERROR;
;;;551              
;;;552              /* Process Unlocked */ 
;;;553              __HAL_UNLOCK(hrtc);
;;;554              
;;;555              return HAL_ERROR;
;;;556            }
;;;557          }
;;;558        }
;;;559        
;;;560        hrtc->State = HAL_RTC_STATE_READY;
;;;561      
;;;562       __HAL_UNLOCK(hrtc); 
;;;563         
;;;564       return HAL_OK;
;;;565      }
;;;566    }
0002a4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.680|
0002a8  bf00              NOP                            ;494
0002aa  7c20              LDRB     r0,[r4,#0x10]         ;494
0002ac  2801              CMP      r0,#1                 ;494
0002ae  d101              BNE      |L1.692|
0002b0  2002              MOVS     r0,#2                 ;494
0002b2  e7f7              B        |L1.676|
                  |L1.692|
0002b4  2001              MOVS     r0,#1                 ;494
0002b6  7420              STRB     r0,[r4,#0x10]         ;494
0002b8  bf00              NOP                            ;494
0002ba  2002              MOVS     r0,#2                 ;496
0002bc  7460              STRB     r0,[r4,#0x11]         ;496
0002be  f1b80f00          CMP      r8,#0                 ;498
0002c2  d10b              BNE      |L1.732|
0002c4  7828              LDRB     r0,[r5,#0]            ;504
0002c6  f44f6161          MOV      r1,#0xe10             ;504
0002ca  4348              MULS     r0,r1,r0              ;504
0002cc  7869              LDRB     r1,[r5,#1]            ;504
0002ce  ebc11101          RSB      r1,r1,r1,LSL #4       ;504
0002d2  eb000081          ADD      r0,r0,r1,LSL #2       ;504
0002d6  78a9              LDRB     r1,[r5,#2]            ;504
0002d8  1846              ADDS     r6,r0,r1              ;504
0002da  e012              B        |L1.770|
                  |L1.732|
0002dc  7828              LDRB     r0,[r5,#0]            ;514
0002de  f7fffffe          BL       RTC_Bcd2ToByte
0002e2  f44f6161          MOV      r1,#0xe10             ;514
0002e6  fb00f901          MUL      r9,r0,r1              ;514
0002ea  7868              LDRB     r0,[r5,#1]            ;514
0002ec  f7fffffe          BL       RTC_Bcd2ToByte
0002f0  ebc01000          RSB      r0,r0,r0,LSL #4       ;514
0002f4  eb090980          ADD      r9,r9,r0,LSL #2       ;514
0002f8  78a8              LDRB     r0,[r5,#2]            ;514
0002fa  f7fffffe          BL       RTC_Bcd2ToByte
0002fe  eb090600          ADD      r6,r9,r0              ;514
                  |L1.770|
000302  4631              MOV      r1,r6                 ;520
000304  4620              MOV      r0,r4                 ;520
000306  f7fffffe          BL       RTC_WriteTimeCounter
00030a  b138              CBZ      r0,|L1.796|
00030c  2004              MOVS     r0,#4                 ;523
00030e  7460              STRB     r0,[r4,#0x11]         ;523
000310  bf00              NOP                            ;526
000312  2000              MOVS     r0,#0                 ;526
000314  7420              STRB     r0,[r4,#0x10]         ;526
000316  bf00              NOP                            ;526
000318  2001              MOVS     r0,#1                 ;528
00031a  e7c3              B        |L1.676|
                  |L1.796|
00031c  6820              LDR      r0,[r4,#0]            ;533
00031e  6840              LDR      r0,[r0,#4]            ;533
000320  f0200005          BIC      r0,r0,#5              ;533
000324  6821              LDR      r1,[r4,#0]            ;533
000326  6048              STR      r0,[r1,#4]            ;533
000328  4620              MOV      r0,r4                 ;536
00032a  f7fffffe          BL       RTC_ReadAlarmCounter
00032e  4607              MOV      r7,r0                 ;536
000330  1c78              ADDS     r0,r7,#1              ;539
000332  b180              CBZ      r0,|L1.854|
000334  42b7              CMP      r7,r6                 ;541
000336  d20e              BCS      |L1.854|
000338  486f              LDR      r0,|L1.1272|
00033a  4407              ADD      r7,r7,r0              ;544
00033c  4639              MOV      r1,r7                 ;547
00033e  4620              MOV      r0,r4                 ;547
000340  f7fffffe          BL       RTC_WriteAlarmCounter
000344  b138              CBZ      r0,|L1.854|
000346  2004              MOVS     r0,#4                 ;550
000348  7460              STRB     r0,[r4,#0x11]         ;550
00034a  bf00              NOP                            ;553
00034c  2000              MOVS     r0,#0                 ;553
00034e  7420              STRB     r0,[r4,#0x10]         ;553
000350  bf00              NOP                            ;553
000352  2001              MOVS     r0,#1                 ;555
000354  e7a6              B        |L1.676|
                  |L1.854|
000356  2001              MOVS     r0,#1                 ;560
000358  7460              STRB     r0,[r4,#0x11]         ;560
00035a  bf00              NOP                            ;562
00035c  2000              MOVS     r0,#0                 ;562
00035e  7420              STRB     r0,[r4,#0x10]         ;562
000360  bf00              NOP                            ;562
000362  bf00              NOP                            ;564
000364  e79e              B        |L1.676|
;;;567    
                          ENDP

                  RTC_ByteToBcd2 PROC
;;;1516     */
;;;1517   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000366  4601              MOV      r1,r0
;;;1518   {
;;;1519     uint32_t bcdhigh = 0;
000368  2200              MOVS     r2,#0
;;;1520     
;;;1521     while(Value >= 10)
00036a  e003              B        |L1.884|
                  |L1.876|
;;;1522     {
;;;1523       bcdhigh++;
00036c  1c52              ADDS     r2,r2,#1
;;;1524       Value -= 10;
00036e  f1a1000a          SUB      r0,r1,#0xa
000372  b2c1              UXTB     r1,r0
                  |L1.884|
000374  290a              CMP      r1,#0xa               ;1521
000376  daf9              BGE      |L1.876|
;;;1525     }
;;;1526     
;;;1527     return  ((uint8_t)(bcdhigh << 4) | Value);
000378  0710              LSLS     r0,r2,#28
00037a  ea416010          ORR      r0,r1,r0,LSR #24
;;;1528   }
00037e  4770              BX       lr
;;;1529   
                          ENDP

                  RTC_WeekDayNum PROC
;;;1680     */
;;;1681   static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
000380  b5f0              PUSH     {r4-r7,lr}
;;;1682   {
000382  4604              MOV      r4,r0
000384  460b              MOV      r3,r1
;;;1683     uint32_t year = 0, weekday = 0;
000386  2100              MOVS     r1,#0
000388  2500              MOVS     r5,#0
;;;1684   
;;;1685     year = 2000 + nYear;
00038a  f50461fa          ADD      r1,r4,#0x7d0
;;;1686     
;;;1687     if(nMonth < 3)
00038e  2b03              CMP      r3,#3
000390  da1b              BGE      |L1.970|
;;;1688     {
;;;1689       /*D = { [(23 x month)/9] + day + 4 + year + [(year-1)/4] - [(year-1)/100] + [(year-1)/400] } mod 7*/
;;;1690       weekday = (((23 * nMonth)/9) + nDay + 4 + year + ((year-1)/4) - ((year-1)/100) + ((year-1)/400)) % 7;
000392  ebc300c3          RSB      r0,r3,r3,LSL #3
000396  eb001003          ADD      r0,r0,r3,LSL #4
00039a  2609              MOVS     r6,#9
00039c  fb90f0f6          SDIV     r0,r0,r6
0003a0  4410              ADD      r0,r0,r2
0003a2  1d00              ADDS     r0,r0,#4
0003a4  1846              ADDS     r6,r0,r1
0003a6  1e48              SUBS     r0,r1,#1
0003a8  eb060690          ADD      r6,r6,r0,LSR #2
0003ac  2764              MOVS     r7,#0x64
0003ae  fbb0f0f7          UDIV     r0,r0,r7
0003b2  1a36              SUBS     r6,r6,r0
0003b4  1e48              SUBS     r0,r1,#1
0003b6  00bf              LSLS     r7,r7,#2
0003b8  fbb0f0f7          UDIV     r0,r0,r7
0003bc  4430              ADD      r0,r0,r6
0003be  2607              MOVS     r6,#7
0003c0  fbb0f7f6          UDIV     r7,r0,r6
0003c4  fb060517          MLS      r5,r6,r7,r0
0003c8  e01a              B        |L1.1024|
                  |L1.970|
;;;1691     }
;;;1692     else
;;;1693     {
;;;1694       /*D = { [(23 x month)/9] + day + 4 + year + [year/4] - [year/100] + [year/400] - 2 } mod 7*/
;;;1695       weekday = (((23 * nMonth)/9) + nDay + 4 + year + (year/4) - (year/100) + (year/400) - 2 ) % 7; 
0003ca  ebc300c3          RSB      r0,r3,r3,LSL #3
0003ce  eb001003          ADD      r0,r0,r3,LSL #4
0003d2  2609              MOVS     r6,#9
0003d4  fb90f0f6          SDIV     r0,r0,r6
0003d8  4410              ADD      r0,r0,r2
0003da  1d00              ADDS     r0,r0,#4
0003dc  4408              ADD      r0,r0,r1
0003de  eb000091          ADD      r0,r0,r1,LSR #2
0003e2  2664              MOVS     r6,#0x64
0003e4  fbb1f6f6          UDIV     r6,r1,r6
0003e8  1b80              SUBS     r0,r0,r6
0003ea  f44f76c8          MOV      r6,#0x190
0003ee  fbb1f6f6          UDIV     r6,r1,r6
0003f2  4430              ADD      r0,r0,r6
0003f4  1e80              SUBS     r0,r0,#2
0003f6  2607              MOVS     r6,#7
0003f8  fbb0f7f6          UDIV     r7,r0,r6
0003fc  fb060517          MLS      r5,r6,r7,r0
                  |L1.1024|
;;;1696     }
;;;1697   
;;;1698     return (uint8_t)weekday;
000400  b2e8              UXTB     r0,r5
;;;1699   }
000402  bdf0              POP      {r4-r7,pc}
;;;1700   
                          ENDP

                  RTC_IsLeapYear PROC
;;;1643     */
;;;1644   static uint8_t RTC_IsLeapYear(uint16_t nYear)
000404  4601              MOV      r1,r0
;;;1645   {
;;;1646     if((nYear % 4) != 0) 
000406  17ca              ASRS     r2,r1,#31
000408  eb017292          ADD      r2,r1,r2,LSR #30
00040c  1092              ASRS     r2,r2,#2
00040e  eba10282          SUB      r2,r1,r2,LSL #2
000412  b10a              CBZ      r2,|L1.1048|
;;;1647     {
;;;1648       return 0;
000414  2000              MOVS     r0,#0
                  |L1.1046|
;;;1649     }
;;;1650     
;;;1651     if((nYear % 100) != 0) 
;;;1652     {
;;;1653       return 1;
;;;1654     }
;;;1655     
;;;1656     if((nYear % 400) == 0)
;;;1657     {
;;;1658       return 1;
;;;1659     }
;;;1660     else
;;;1661     {
;;;1662       return 0;
;;;1663     }
;;;1664   }
000416  4770              BX       lr
                  |L1.1048|
000418  2064              MOVS     r0,#0x64              ;1651
00041a  fb91f2f0          SDIV     r2,r1,r0              ;1651
00041e  fb001012          MLS      r0,r0,r2,r1           ;1651
000422  b108              CBZ      r0,|L1.1064|
000424  2001              MOVS     r0,#1                 ;1653
000426  e7f6              B        |L1.1046|
                  |L1.1064|
000428  f44f70c8          MOV      r0,#0x190             ;1656
00042c  fb91f2f0          SDIV     r2,r1,r0              ;1656
000430  fb001012          MLS      r0,r0,r2,r1           ;1656
000434  b908              CBNZ     r0,|L1.1082|
000436  2001              MOVS     r0,#1                 ;1658
000438  e7ed              B        |L1.1046|
                  |L1.1082|
00043a  2000              MOVS     r0,#0                 ;1662
00043c  e7eb              B        |L1.1046|
;;;1665   
                          ENDP

                  RTC_DateUpdate PROC
;;;1548     */
;;;1549   static void RTC_DateUpdate(RTC_HandleTypeDef* hrtc, uint32_t DayElapsed)
00043e  e92d47f0          PUSH     {r4-r10,lr}
;;;1550   {
000442  4606              MOV      r6,r0
000444  4688              MOV      r8,r1
;;;1551     uint32_t year = 0, month = 0, day = 0;
000446  2700              MOVS     r7,#0
000448  2400              MOVS     r4,#0
00044a  2500              MOVS     r5,#0
;;;1552     uint32_t loop = 0;
00044c  46a1              MOV      r9,r4
;;;1553   
;;;1554     /* Get the current year*/
;;;1555     year = hrtc->DateToUpdate.Year;
00044e  7bf7              LDRB     r7,[r6,#0xf]
;;;1556   
;;;1557     /* Get the current month and day */
;;;1558     month = hrtc->DateToUpdate.Month;
000450  7b74              LDRB     r4,[r6,#0xd]
;;;1559     day = hrtc->DateToUpdate.Date;
000452  7bb5              LDRB     r5,[r6,#0xe]
;;;1560   
;;;1561     for (loop = 0; loop < DayElapsed; loop++)
000454  bf00              NOP      
000456  e040              B        |L1.1242|
                  |L1.1112|
;;;1562     {
;;;1563       if((month == 1) || (month == 3) || (month == 5) || (month == 7) || \
000458  2c01              CMP      r4,#1
00045a  d00b              BEQ      |L1.1140|
00045c  2c03              CMP      r4,#3
00045e  d009              BEQ      |L1.1140|
000460  2c05              CMP      r4,#5
000462  d007              BEQ      |L1.1140|
000464  2c07              CMP      r4,#7
000466  d005              BEQ      |L1.1140|
;;;1564          (month == 8) || (month == 10) || (month == 12))
000468  2c08              CMP      r4,#8
00046a  d003              BEQ      |L1.1140|
00046c  2c0a              CMP      r4,#0xa
00046e  d001              BEQ      |L1.1140|
000470  2c0c              CMP      r4,#0xc
000472  d10c              BNE      |L1.1166|
                  |L1.1140|
;;;1565       {
;;;1566         if(day < 31)
000474  2d1f              CMP      r5,#0x1f
000476  d201              BCS      |L1.1148|
;;;1567         {
;;;1568           day++;
000478  1c6d              ADDS     r5,r5,#1
00047a  e02c              B        |L1.1238|
                  |L1.1148|
;;;1569         }
;;;1570         /* Date structure member: day = 31 */
;;;1571         else
;;;1572         {
;;;1573           if(month != 12)
00047c  2c0c              CMP      r4,#0xc
00047e  d002              BEQ      |L1.1158|
;;;1574           {
;;;1575             month++;
000480  1c64              ADDS     r4,r4,#1
;;;1576             day = 1;
000482  2501              MOVS     r5,#1
000484  e027              B        |L1.1238|
                  |L1.1158|
;;;1577           }
;;;1578           /* Date structure member: day = 31 & month =12 */
;;;1579           else
;;;1580           {
;;;1581             month = 1;
000486  2401              MOVS     r4,#1
;;;1582             day = 1;
000488  2501              MOVS     r5,#1
;;;1583             year++;
00048a  1c7f              ADDS     r7,r7,#1
00048c  e023              B        |L1.1238|
                  |L1.1166|
;;;1584           }
;;;1585         }
;;;1586       }
;;;1587       else if((month == 4) || (month == 6) || (month == 9) || (month == 11))
00048e  2c04              CMP      r4,#4
000490  d005              BEQ      |L1.1182|
000492  2c06              CMP      r4,#6
000494  d003              BEQ      |L1.1182|
000496  2c09              CMP      r4,#9
000498  d001              BEQ      |L1.1182|
00049a  2c0b              CMP      r4,#0xb
00049c  d106              BNE      |L1.1196|
                  |L1.1182|
;;;1588       {
;;;1589         if(day < 30)
00049e  2d1e              CMP      r5,#0x1e
0004a0  d201              BCS      |L1.1190|
;;;1590         {
;;;1591           day++;
0004a2  1c6d              ADDS     r5,r5,#1
0004a4  e017              B        |L1.1238|
                  |L1.1190|
;;;1592         }
;;;1593         /* Date structure member: day = 30 */
;;;1594         else
;;;1595         {
;;;1596           month++;
0004a6  1c64              ADDS     r4,r4,#1
;;;1597           day = 1;
0004a8  2501              MOVS     r5,#1
0004aa  e014              B        |L1.1238|
                  |L1.1196|
;;;1598         }
;;;1599       }
;;;1600       else if(month == 2)
0004ac  2c02              CMP      r4,#2
0004ae  d112              BNE      |L1.1238|
;;;1601       {
;;;1602         if(day < 28)
0004b0  2d1c              CMP      r5,#0x1c
0004b2  d201              BCS      |L1.1208|
;;;1603         {
;;;1604           day++;
0004b4  1c6d              ADDS     r5,r5,#1
0004b6  e00e              B        |L1.1238|
                  |L1.1208|
;;;1605         }
;;;1606         else if(day == 28)
0004b8  2d1c              CMP      r5,#0x1c
0004ba  d108              BNE      |L1.1230|
;;;1607         {
;;;1608           /* Leap year */
;;;1609           if(RTC_IsLeapYear(year))
0004bc  b2b8              UXTH     r0,r7
0004be  f7fffffe          BL       RTC_IsLeapYear
0004c2  b108              CBZ      r0,|L1.1224|
;;;1610           {
;;;1611             day++;
0004c4  1c6d              ADDS     r5,r5,#1
0004c6  e006              B        |L1.1238|
                  |L1.1224|
;;;1612           }
;;;1613           else
;;;1614           {
;;;1615             month++;
0004c8  1c64              ADDS     r4,r4,#1
;;;1616             day = 1;
0004ca  2501              MOVS     r5,#1
0004cc  e003              B        |L1.1238|
                  |L1.1230|
;;;1617           }
;;;1618         }
;;;1619         else if(day == 29)
0004ce  2d1d              CMP      r5,#0x1d
0004d0  d101              BNE      |L1.1238|
;;;1620         {
;;;1621           month++;
0004d2  1c64              ADDS     r4,r4,#1
;;;1622           day = 1;
0004d4  2501              MOVS     r5,#1
                  |L1.1238|
0004d6  f1090901          ADD      r9,r9,#1              ;1561
                  |L1.1242|
0004da  45c1              CMP      r9,r8                 ;1561
0004dc  d3bc              BCC      |L1.1112|
;;;1623         }
;;;1624       }
;;;1625     }
;;;1626   
;;;1627     /* Update year */
;;;1628     hrtc->DateToUpdate.Year = year;
0004de  73f7              STRB     r7,[r6,#0xf]
;;;1629   
;;;1630     /* Update day and month */
;;;1631     hrtc->DateToUpdate.Month = month;
0004e0  7374              STRB     r4,[r6,#0xd]
;;;1632     hrtc->DateToUpdate.Date = day;
0004e2  73b5              STRB     r5,[r6,#0xe]
;;;1633   
;;;1634     /* Update day of the week */
;;;1635     hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(year, month, day);
0004e4  b2ea              UXTB     r2,r5
0004e6  b2e1              UXTB     r1,r4
0004e8  4638              MOV      r0,r7
0004ea  f7fffffe          BL       RTC_WeekDayNum
0004ee  7330              STRB     r0,[r6,#0xc]
;;;1636   }
0004f0  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1268|
                          DCD      0x40006c30
                  |L1.1272|
                          DCD      0x00015180
                          ENDP

                  RTC_ReadTimeCounter PROC
;;;1353     */
;;;1354   static uint32_t RTC_ReadTimeCounter(RTC_HandleTypeDef* hrtc)
0004fc  b530              PUSH     {r4,r5,lr}
;;;1355   {
0004fe  4601              MOV      r1,r0
;;;1356     uint16_t high1 = 0, high2 = 0, low = 0;
000500  2200              MOVS     r2,#0
000502  2300              MOVS     r3,#0
000504  2400              MOVS     r4,#0
;;;1357     uint32_t timecounter = 0;
000506  2000              MOVS     r0,#0
;;;1358   
;;;1359     high1 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
000508  680d              LDR      r5,[r1,#0]
00050a  69ad              LDR      r5,[r5,#0x18]
00050c  b2aa              UXTH     r2,r5
;;;1360     low   = READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT);
00050e  680d              LDR      r5,[r1,#0]
000510  69ed              LDR      r5,[r5,#0x1c]
000512  b2ac              UXTH     r4,r5
;;;1361     high2 = READ_REG(hrtc->Instance->CNTH & RTC_CNTH_RTC_CNT);
000514  680d              LDR      r5,[r1,#0]
000516  69ad              LDR      r5,[r5,#0x18]
000518  b2ab              UXTH     r3,r5
;;;1362   
;;;1363     if (high1 != high2)
00051a  429a              CMP      r2,r3
00051c  d005              BEQ      |L1.1322|
;;;1364     { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
;;;1365          read again CNTL register then return the counter value */
;;;1366       timecounter = (((uint32_t) high2 << 16 ) | READ_REG(hrtc->Instance->CNTL & RTC_CNTL_RTC_CNT));
00051e  680d              LDR      r5,[r1,#0]
000520  69ed              LDR      r5,[r5,#0x1c]
000522  f363451f          BFI      r5,r3,#16,#16
000526  4628              MOV      r0,r5
000528  e001              B        |L1.1326|
                  |L1.1322|
;;;1367     }
;;;1368     else
;;;1369     { /* No counter roll over during reading of CNTL and CNTH registers, counter 
;;;1370          value is equal to first value of CNTL and CNTH */
;;;1371       timecounter = (((uint32_t) high1 << 16 ) | low);
00052a  ea444002          ORR      r0,r4,r2,LSL #16
                  |L1.1326|
;;;1372     }
;;;1373   
;;;1374     return timecounter;
;;;1375   }
00052e  bd30              POP      {r4,r5,pc}
;;;1376   
                          ENDP

                  HAL_RTC_GetTime PROC
;;;578      */
;;;579    HAL_StatusTypeDef HAL_RTC_GetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
000530  e92d47f0          PUSH     {r4-r10,lr}
;;;580    {
000534  4680              MOV      r8,r0
000536  460c              MOV      r4,r1
000538  4691              MOV      r9,r2
;;;581      uint32_t counter_time = 0, counter_alarm = 0, days_elapsed = 0, hours = 0;
00053a  2500              MOVS     r5,#0
00053c  2600              MOVS     r6,#0
00053e  46aa              MOV      r10,r5
000540  2700              MOVS     r7,#0
;;;582      
;;;583      /* Check input parameters */
;;;584      if((hrtc == NULL) || (sTime == NULL))
000542  f1b80f00          CMP      r8,#0
000546  d000              BEQ      |L1.1354|
000548  b914              CBNZ     r4,|L1.1360|
                  |L1.1354|
;;;585      {
;;;586         return HAL_ERROR;
00054a  2001              MOVS     r0,#1
                  |L1.1356|
;;;587      }
;;;588    
;;;589      /* Check the parameters */
;;;590      assert_param(IS_RTC_FORMAT(Format));
;;;591    
;;;592      /* Check if counter overflow occurred */
;;;593      if (__HAL_RTC_OVERFLOW_GET_FLAG(hrtc, RTC_FLAG_OW))
;;;594      {
;;;595          return HAL_ERROR;
;;;596      }
;;;597    
;;;598      /* Read the time counter*/
;;;599      counter_time = RTC_ReadTimeCounter(hrtc);
;;;600    
;;;601      /* Fill the structure fields with the read parameters */
;;;602      hours = counter_time / 3600;
;;;603      sTime->Minutes  = (uint8_t)((counter_time % 3600) / 60);
;;;604      sTime->Seconds  = (uint8_t)((counter_time % 3600) % 60);
;;;605    
;;;606      if (hours >= 24)
;;;607      {
;;;608        /* Get number of days elapsed from last calculation */
;;;609        days_elapsed = (hours / 24);
;;;610    
;;;611        /* Set Hours in RTC_TimeTypeDef structure*/
;;;612        sTime->Hours = (hours % 24);    
;;;613    
;;;614        /* Read Alarm counter in RTC registers */
;;;615        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;616    
;;;617        /* Calculate remaining time to reach alarm (only if set and not yet expired)*/
;;;618        if ((counter_alarm != RTC_ALARM_RESETVALUE) && (counter_alarm > counter_time))
;;;619        {
;;;620          counter_alarm -= counter_time;
;;;621        }
;;;622        else 
;;;623        {
;;;624          /* In case of counter_alarm < counter_time */
;;;625          /* Alarm expiration already occurred but alarm not deactivated */
;;;626          counter_alarm = RTC_ALARM_RESETVALUE;
;;;627        }
;;;628    
;;;629        /* Set updated time in decreasing counter by number of days elapsed */
;;;630        counter_time -= (days_elapsed * 24 * 3600);
;;;631        
;;;632        /* Write time counter in RTC registers */
;;;633        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
;;;634        {
;;;635          return HAL_ERROR;
;;;636        }
;;;637    
;;;638        /* Set updated alarm to be set */
;;;639        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;640        {
;;;641          counter_alarm += counter_time;
;;;642          
;;;643          /* Write time counter in RTC registers */
;;;644          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;645          {
;;;646            return HAL_ERROR;
;;;647          }
;;;648        }
;;;649        else
;;;650        {
;;;651          /* Alarm already occurred. Set it to reset values to avoid unexpected expiration */
;;;652          if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;653          {
;;;654            return HAL_ERROR;
;;;655          }
;;;656        }
;;;657        
;;;658        /* Update date */
;;;659        RTC_DateUpdate(hrtc, days_elapsed);
;;;660      }
;;;661      else 
;;;662      {
;;;663        sTime->Hours = hours;    
;;;664      }
;;;665    
;;;666      /* Check the input parameters format */
;;;667      if(Format != RTC_FORMAT_BIN)
;;;668      {
;;;669        /* Convert the time structure parameters to BCD format */
;;;670        sTime->Hours    = (uint8_t)RTC_ByteToBcd2(sTime->Hours);
;;;671        sTime->Minutes  = (uint8_t)RTC_ByteToBcd2(sTime->Minutes);
;;;672        sTime->Seconds  = (uint8_t)RTC_ByteToBcd2(sTime->Seconds);  
;;;673      }
;;;674      
;;;675      return HAL_OK;
;;;676    }
00054c  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1360|
000550  f8d80000          LDR      r0,[r8,#0]            ;593
000554  6840              LDR      r0,[r0,#4]            ;593
000556  f3c00080          UBFX     r0,r0,#2,#1           ;593
00055a  b108              CBZ      r0,|L1.1376|
00055c  2001              MOVS     r0,#1                 ;595
00055e  e7f5              B        |L1.1356|
                  |L1.1376|
000560  4640              MOV      r0,r8                 ;599
000562  f7fffffe          BL       RTC_ReadTimeCounter
000566  4605              MOV      r5,r0                 ;599
000568  f44f6061          MOV      r0,#0xe10             ;602
00056c  fbb5f7f0          UDIV     r7,r5,r0              ;602
000570  fbb5f1f0          UDIV     r1,r5,r0              ;603
000574  fb005011          MLS      r0,r0,r1,r5           ;603
000578  213c              MOVS     r1,#0x3c              ;603
00057a  fbb0f0f1          UDIV     r0,r0,r1              ;603
00057e  7060              STRB     r0,[r4,#1]            ;603
000580  f44f6061          MOV      r0,#0xe10             ;604
000584  fbb5f1f0          UDIV     r1,r5,r0              ;604
000588  fb005011          MLS      r0,r0,r1,r5           ;604
00058c  213c              MOVS     r1,#0x3c              ;604
00058e  fbb0f2f1          UDIV     r2,r0,r1              ;604
000592  fb010012          MLS      r0,r1,r2,r0           ;604
000596  70a0              STRB     r0,[r4,#2]            ;604
000598  2f18              CMP      r7,#0x18              ;606
00059a  d339              BCC      |L1.1552|
00059c  2018              MOVS     r0,#0x18              ;609
00059e  fbb7faf0          UDIV     r10,r7,r0             ;609
0005a2  fbb7f1f0          UDIV     r1,r7,r0              ;612
0005a6  fb007011          MLS      r0,r0,r1,r7           ;612
0005aa  7020              STRB     r0,[r4,#0]            ;612
0005ac  4640              MOV      r0,r8                 ;615
0005ae  f7fffffe          BL       RTC_ReadAlarmCounter
0005b2  4606              MOV      r6,r0                 ;615
0005b4  1c70              ADDS     r0,r6,#1              ;618
0005b6  b118              CBZ      r0,|L1.1472|
0005b8  42ae              CMP      r6,r5                 ;618
0005ba  d901              BLS      |L1.1472|
0005bc  1b76              SUBS     r6,r6,r5              ;620
0005be  e001              B        |L1.1476|
                  |L1.1472|
0005c0  f04f36ff          MOV      r6,#0xffffffff        ;626
                  |L1.1476|
0005c4  eb0a004a          ADD      r0,r10,r10,LSL #1     ;630
0005c8  00c0              LSLS     r0,r0,#3              ;630
0005ca  ebc01140          RSB      r1,r0,r0,LSL #5       ;630
0005ce  ebc12000          RSB      r0,r1,r0,LSL #8       ;630
0005d2  eba51500          SUB      r5,r5,r0,LSL #4       ;630
0005d6  4629              MOV      r1,r5                 ;633
0005d8  4640              MOV      r0,r8                 ;633
0005da  f7fffffe          BL       RTC_WriteTimeCounter
0005de  b108              CBZ      r0,|L1.1508|
0005e0  2001              MOVS     r0,#1                 ;635
0005e2  e7b3              B        |L1.1356|
                  |L1.1508|
0005e4  1c70              ADDS     r0,r6,#1              ;639
0005e6  b138              CBZ      r0,|L1.1528|
0005e8  442e              ADD      r6,r6,r5              ;641
0005ea  4631              MOV      r1,r6                 ;644
0005ec  4640              MOV      r0,r8                 ;644
0005ee  f7fffffe          BL       RTC_WriteAlarmCounter
0005f2  b140              CBZ      r0,|L1.1542|
0005f4  2001              MOVS     r0,#1                 ;646
0005f6  e7a9              B        |L1.1356|
                  |L1.1528|
0005f8  4631              MOV      r1,r6                 ;652
0005fa  4640              MOV      r0,r8                 ;652
0005fc  f7fffffe          BL       RTC_WriteAlarmCounter
000600  b108              CBZ      r0,|L1.1542|
000602  2001              MOVS     r0,#1                 ;654
000604  e7a2              B        |L1.1356|
                  |L1.1542|
000606  4651              MOV      r1,r10                ;659
000608  4640              MOV      r0,r8                 ;659
00060a  f7fffffe          BL       RTC_DateUpdate
00060e  e000              B        |L1.1554|
                  |L1.1552|
000610  7027              STRB     r7,[r4,#0]            ;663
                  |L1.1554|
000612  f1b90f00          CMP      r9,#0                 ;667
000616  d00b              BEQ      |L1.1584|
000618  7820              LDRB     r0,[r4,#0]            ;670
00061a  f7fffffe          BL       RTC_ByteToBcd2
00061e  7020              STRB     r0,[r4,#0]            ;670
000620  7860              LDRB     r0,[r4,#1]            ;671
000622  f7fffffe          BL       RTC_ByteToBcd2
000626  7060              STRB     r0,[r4,#1]            ;671
000628  78a0              LDRB     r0,[r4,#2]            ;672
00062a  f7fffffe          BL       RTC_ByteToBcd2
00062e  70a0              STRB     r0,[r4,#2]            ;672
                  |L1.1584|
000630  2000              MOVS     r0,#0                 ;675
000632  e78b              B        |L1.1356|
;;;677    
                          ENDP

                  HAL_RTC_SetDate PROC
;;;689      */
;;;690    HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000634  e92d47f0          PUSH     {r4-r10,lr}
;;;691    {
000638  4604              MOV      r4,r0
00063a  460d              MOV      r5,r1
00063c  4690              MOV      r8,r2
;;;692      uint32_t counter_time = 0, counter_alarm = 0, hours = 0;
00063e  2600              MOVS     r6,#0
000640  2700              MOVS     r7,#0
000642  46b1              MOV      r9,r6
;;;693      
;;;694      /* Check input parameters */
;;;695      if((hrtc == NULL) || (sDate == NULL))
000644  b104              CBZ      r4,|L1.1608|
000646  b915              CBNZ     r5,|L1.1614|
                  |L1.1608|
;;;696      {
;;;697         return HAL_ERROR;
000648  2001              MOVS     r0,#1
                  |L1.1610|
;;;698      }
;;;699      
;;;700      /* Check the parameters */
;;;701      assert_param(IS_RTC_FORMAT(Format));
;;;702      
;;;703     /* Process Locked */ 
;;;704     __HAL_LOCK(hrtc);
;;;705      
;;;706      hrtc->State = HAL_RTC_STATE_BUSY; 
;;;707      
;;;708      if(Format == RTC_FORMAT_BIN)
;;;709      {   
;;;710        assert_param(IS_RTC_YEAR(sDate->Year));
;;;711        assert_param(IS_RTC_MONTH(sDate->Month));
;;;712        assert_param(IS_RTC_DATE(sDate->Date)); 
;;;713    
;;;714        /* Change the current date */
;;;715        hrtc->DateToUpdate.Year  = sDate->Year;
;;;716        hrtc->DateToUpdate.Month = sDate->Month;
;;;717        hrtc->DateToUpdate.Date  = sDate->Date;
;;;718      }
;;;719      else
;;;720      {   
;;;721        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
;;;722        assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
;;;723        assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));
;;;724        
;;;725        /* Change the current date */
;;;726        hrtc->DateToUpdate.Year  = RTC_Bcd2ToByte(sDate->Year);
;;;727        hrtc->DateToUpdate.Month = RTC_Bcd2ToByte(sDate->Month);
;;;728        hrtc->DateToUpdate.Date  = RTC_Bcd2ToByte(sDate->Date);
;;;729      }
;;;730    
;;;731      /* WeekDay set by user can be ignored because automatically calculated */
;;;732      hrtc->DateToUpdate.WeekDay = RTC_WeekDayNum(hrtc->DateToUpdate.Year, hrtc->DateToUpdate.Month, hrtc->DateToUpdate.Date);
;;;733      sDate->WeekDay = hrtc->DateToUpdate.WeekDay;
;;;734    
;;;735      /* Reset time to be aligned on the same day */
;;;736      /* Read the time counter*/
;;;737      counter_time = RTC_ReadTimeCounter(hrtc);
;;;738    
;;;739      /* Fill the structure fields with the read parameters */
;;;740      hours = counter_time / 3600;
;;;741      if (hours > 24)
;;;742      {
;;;743        /* Set updated time in decreasing counter by number of days elapsed */
;;;744        counter_time -= ((hours / 24) * 24 * 3600);
;;;745        /* Write time counter in RTC registers */
;;;746        if (RTC_WriteTimeCounter(hrtc, counter_time) != HAL_OK)
;;;747        {
;;;748          /* Set RTC state */
;;;749          hrtc->State = HAL_RTC_STATE_ERROR;
;;;750          
;;;751          /* Process Unlocked */ 
;;;752          __HAL_UNLOCK(hrtc);
;;;753          
;;;754          return HAL_ERROR;
;;;755        }
;;;756    
;;;757        /* Read current Alarm counter in RTC registers */
;;;758        counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;759    
;;;760        /* Set again alarm to match with new time if enabled */
;;;761        if (counter_alarm != RTC_ALARM_RESETVALUE)
;;;762        {
;;;763          if(counter_alarm < counter_time)
;;;764          {
;;;765            /* Add 1 day to alarm counter*/
;;;766            counter_alarm += (uint32_t)(24 * 3600);
;;;767            
;;;768            /* Write new Alarm counter in RTC registers */
;;;769            if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;770            {
;;;771              /* Set RTC state */
;;;772              hrtc->State = HAL_RTC_STATE_ERROR;
;;;773              
;;;774              /* Process Unlocked */ 
;;;775              __HAL_UNLOCK(hrtc);
;;;776              
;;;777              return HAL_ERROR;
;;;778            }
;;;779          }
;;;780        }
;;;781        
;;;782    
;;;783      }
;;;784    
;;;785      hrtc->State = HAL_RTC_STATE_READY ;
;;;786      
;;;787      /* Process Unlocked */ 
;;;788      __HAL_UNLOCK(hrtc);
;;;789      
;;;790      return HAL_OK;    
;;;791    }
00064a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1614|
00064e  bf00              NOP                            ;704
000650  7c20              LDRB     r0,[r4,#0x10]         ;704
000652  2801              CMP      r0,#1                 ;704
000654  d101              BNE      |L1.1626|
000656  2002              MOVS     r0,#2                 ;704
000658  e7f7              B        |L1.1610|
                  |L1.1626|
00065a  2001              MOVS     r0,#1                 ;704
00065c  7420              STRB     r0,[r4,#0x10]         ;704
00065e  bf00              NOP                            ;704
000660  2002              MOVS     r0,#2                 ;706
000662  7460              STRB     r0,[r4,#0x11]         ;706
000664  f1b80f00          CMP      r8,#0                 ;708
000668  d106              BNE      |L1.1656|
00066a  78e9              LDRB     r1,[r5,#3]            ;715
00066c  73e1              STRB     r1,[r4,#0xf]          ;715
00066e  7869              LDRB     r1,[r5,#1]            ;716
000670  7361              STRB     r1,[r4,#0xd]          ;716
000672  78a9              LDRB     r1,[r5,#2]            ;717
000674  73a1              STRB     r1,[r4,#0xe]          ;717
000676  e00b              B        |L1.1680|
                  |L1.1656|
000678  78e8              LDRB     r0,[r5,#3]            ;726
00067a  f7fffffe          BL       RTC_Bcd2ToByte
00067e  73e0              STRB     r0,[r4,#0xf]          ;726
000680  7868              LDRB     r0,[r5,#1]            ;727
000682  f7fffffe          BL       RTC_Bcd2ToByte
000686  7360              STRB     r0,[r4,#0xd]          ;727
000688  78a8              LDRB     r0,[r5,#2]            ;728
00068a  f7fffffe          BL       RTC_Bcd2ToByte
00068e  73a0              STRB     r0,[r4,#0xe]          ;728
                  |L1.1680|
000690  7ba2              LDRB     r2,[r4,#0xe]          ;732
000692  7b61              LDRB     r1,[r4,#0xd]          ;732
000694  7be0              LDRB     r0,[r4,#0xf]          ;732
000696  f7fffffe          BL       RTC_WeekDayNum
00069a  7320              STRB     r0,[r4,#0xc]          ;732
00069c  7b20              LDRB     r0,[r4,#0xc]          ;733
00069e  7028              STRB     r0,[r5,#0]            ;733
0006a0  4620              MOV      r0,r4                 ;737
0006a2  f7fffffe          BL       RTC_ReadTimeCounter
0006a6  4606              MOV      r6,r0                 ;737
0006a8  f44f6061          MOV      r0,#0xe10             ;740
0006ac  fbb6f9f0          UDIV     r9,r6,r0              ;740
0006b0  f1b90f18          CMP      r9,#0x18              ;741
0006b4  d92f              BLS      |L1.1814|
0006b6  2018              MOVS     r0,#0x18              ;744
0006b8  fbb9f0f0          UDIV     r0,r9,r0              ;744
0006bc  eb000040          ADD      r0,r0,r0,LSL #1       ;744
0006c0  00c0              LSLS     r0,r0,#3              ;744
0006c2  ebc01140          RSB      r1,r0,r0,LSL #5       ;744
0006c6  ebc12000          RSB      r0,r1,r0,LSL #8       ;744
0006ca  eba61600          SUB      r6,r6,r0,LSL #4       ;744
0006ce  4631              MOV      r1,r6                 ;746
0006d0  4620              MOV      r0,r4                 ;746
0006d2  f7fffffe          BL       RTC_WriteTimeCounter
0006d6  b138              CBZ      r0,|L1.1768|
0006d8  2004              MOVS     r0,#4                 ;749
0006da  7460              STRB     r0,[r4,#0x11]         ;749
0006dc  bf00              NOP                            ;752
0006de  2000              MOVS     r0,#0                 ;752
0006e0  7420              STRB     r0,[r4,#0x10]         ;752
0006e2  bf00              NOP                            ;752
0006e4  2001              MOVS     r0,#1                 ;754
0006e6  e7b0              B        |L1.1610|
                  |L1.1768|
0006e8  4620              MOV      r0,r4                 ;758
0006ea  f7fffffe          BL       RTC_ReadAlarmCounter
0006ee  4607              MOV      r7,r0                 ;758
0006f0  1c78              ADDS     r0,r7,#1              ;761
0006f2  b180              CBZ      r0,|L1.1814|
0006f4  42b7              CMP      r7,r6                 ;763
0006f6  d20e              BCS      |L1.1814|
0006f8  48f7              LDR      r0,|L1.2776|
0006fa  4407              ADD      r7,r7,r0              ;766
0006fc  4639              MOV      r1,r7                 ;769
0006fe  4620              MOV      r0,r4                 ;769
000700  f7fffffe          BL       RTC_WriteAlarmCounter
000704  b138              CBZ      r0,|L1.1814|
000706  2004              MOVS     r0,#4                 ;772
000708  7460              STRB     r0,[r4,#0x11]         ;772
00070a  bf00              NOP                            ;775
00070c  2000              MOVS     r0,#0                 ;775
00070e  7420              STRB     r0,[r4,#0x10]         ;775
000710  bf00              NOP                            ;775
000712  2001              MOVS     r0,#1                 ;777
000714  e799              B        |L1.1610|
                  |L1.1814|
000716  2001              MOVS     r0,#1                 ;785
000718  7460              STRB     r0,[r4,#0x11]         ;785
00071a  bf00              NOP                            ;788
00071c  2000              MOVS     r0,#0                 ;788
00071e  7420              STRB     r0,[r4,#0x10]         ;788
000720  bf00              NOP                            ;788
000722  bf00              NOP                            ;790
000724  e791              B        |L1.1610|
;;;792    
                          ENDP

                  HAL_RTC_GetDate PROC
;;;803      */
;;;804    HAL_StatusTypeDef HAL_RTC_GetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
000726  b5f8              PUSH     {r3-r7,lr}
;;;805    {
000728  4605              MOV      r5,r0
00072a  460c              MOV      r4,r1
00072c  4616              MOV      r6,r2
;;;806      RTC_TimeTypeDef stime = {0};
00072e  2000              MOVS     r0,#0
000730  9000              STR      r0,[sp,#0]
;;;807      
;;;808      /* Check input parameters */
;;;809      if((hrtc == NULL) || (sDate == NULL))
000732  b105              CBZ      r5,|L1.1846|
000734  b90c              CBNZ     r4,|L1.1850|
                  |L1.1846|
;;;810      {
;;;811         return HAL_ERROR;
000736  2001              MOVS     r0,#1
                  |L1.1848|
;;;812      }
;;;813      
;;;814      /* Check the parameters */
;;;815      assert_param(IS_RTC_FORMAT(Format));
;;;816      
;;;817      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;818      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
;;;819      {
;;;820        return HAL_ERROR;
;;;821      }
;;;822    
;;;823      /* Fill the structure fields with the read parameters */
;;;824      sDate->WeekDay  = hrtc->DateToUpdate.WeekDay;
;;;825      sDate->Year     = hrtc->DateToUpdate.Year;
;;;826      sDate->Month    = hrtc->DateToUpdate.Month;
;;;827      sDate->Date     = hrtc->DateToUpdate.Date;
;;;828    
;;;829      /* Check the input parameters format */
;;;830      if(Format != RTC_FORMAT_BIN)
;;;831      {    
;;;832        /* Convert the date structure parameters to BCD format */
;;;833        sDate->Year   = (uint8_t)RTC_ByteToBcd2(sDate->Year);
;;;834        sDate->Month  = (uint8_t)RTC_ByteToBcd2(sDate->Month);
;;;835        sDate->Date   = (uint8_t)RTC_ByteToBcd2(sDate->Date);  
;;;836      }
;;;837      return HAL_OK;
;;;838    }
000738  bdf8              POP      {r3-r7,pc}
                  |L1.1850|
00073a  2200              MOVS     r2,#0                 ;818
00073c  4669              MOV      r1,sp                 ;818
00073e  4628              MOV      r0,r5                 ;818
000740  f7fffffe          BL       HAL_RTC_GetTime
000744  b108              CBZ      r0,|L1.1866|
000746  2001              MOVS     r0,#1                 ;820
000748  e7f6              B        |L1.1848|
                  |L1.1866|
00074a  7b28              LDRB     r0,[r5,#0xc]          ;824
00074c  7020              STRB     r0,[r4,#0]            ;824
00074e  7be8              LDRB     r0,[r5,#0xf]          ;825
000750  70e0              STRB     r0,[r4,#3]            ;825
000752  7b68              LDRB     r0,[r5,#0xd]          ;826
000754  7060              STRB     r0,[r4,#1]            ;826
000756  7ba8              LDRB     r0,[r5,#0xe]          ;827
000758  70a0              STRB     r0,[r4,#2]            ;827
00075a  b15e              CBZ      r6,|L1.1908|
00075c  78e0              LDRB     r0,[r4,#3]            ;833
00075e  f7fffffe          BL       RTC_ByteToBcd2
000762  70e0              STRB     r0,[r4,#3]            ;833
000764  7860              LDRB     r0,[r4,#1]            ;834
000766  f7fffffe          BL       RTC_ByteToBcd2
00076a  7060              STRB     r0,[r4,#1]            ;834
00076c  78a0              LDRB     r0,[r4,#2]            ;835
00076e  f7fffffe          BL       RTC_ByteToBcd2
000772  70a0              STRB     r0,[r4,#2]            ;835
                  |L1.1908|
000774  2000              MOVS     r0,#0                 ;837
000776  e7df              B        |L1.1848|
;;;839    
                          ENDP

                  HAL_RTC_SetAlarm PROC
;;;868      */
;;;869    HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000778  e92d43f8          PUSH     {r3-r9,lr}
;;;870    {
00077c  4604              MOV      r4,r0
00077e  460d              MOV      r5,r1
000780  4617              MOV      r7,r2
;;;871      uint32_t counter_alarm = 0, counter_time;
000782  2600              MOVS     r6,#0
;;;872      RTC_TimeTypeDef stime = {0};
000784  2000              MOVS     r0,#0
000786  9000              STR      r0,[sp,#0]
;;;873      
;;;874      /* Check input parameters */
;;;875      if((hrtc == NULL) || (sAlarm == NULL))
000788  b104              CBZ      r4,|L1.1932|
00078a  b915              CBNZ     r5,|L1.1938|
                  |L1.1932|
;;;876      {
;;;877         return HAL_ERROR;
00078c  2001              MOVS     r0,#1
                  |L1.1934|
;;;878      }
;;;879      
;;;880      /* Check the parameters */
;;;881      assert_param(IS_RTC_FORMAT(Format));
;;;882      assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;883    
;;;884      /* Process Locked */ 
;;;885      __HAL_LOCK(hrtc);
;;;886      
;;;887      hrtc->State = HAL_RTC_STATE_BUSY;
;;;888      
;;;889      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;890      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
;;;891      {
;;;892        return HAL_ERROR;
;;;893      }
;;;894    
;;;895      /* Convert time in seconds */
;;;896      counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600) + \
;;;897                          ((uint32_t)stime.Minutes * 60) + \
;;;898                          ((uint32_t)stime.Seconds));  
;;;899    
;;;900      if(Format == RTC_FORMAT_BIN)
;;;901      {
;;;902        assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;903        assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;904        assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;905        
;;;906        counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600) + \
;;;907                            ((uint32_t)sAlarm->AlarmTime.Minutes * 60) + \
;;;908                            ((uint32_t)sAlarm->AlarmTime.Seconds));  
;;;909      }
;;;910      else
;;;911      {
;;;912        assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;913        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;914        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;915        
;;;916        counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600) + \
;;;917                  ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60) + \
;;;918                  ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));   
;;;919      }
;;;920    
;;;921      /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;922      if (counter_alarm < counter_time)
;;;923      {
;;;924        /* Add 1 day to alarm counter*/
;;;925        counter_alarm += (uint32_t)(24 * 3600);
;;;926      }
;;;927    
;;;928      /* Write Alarm counter in RTC registers */
;;;929      if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;930      {
;;;931        /* Set RTC state */
;;;932        hrtc->State = HAL_RTC_STATE_ERROR;
;;;933        
;;;934        /* Process Unlocked */ 
;;;935        __HAL_UNLOCK(hrtc);
;;;936        
;;;937        return HAL_ERROR;
;;;938      }
;;;939      else
;;;940      {
;;;941        hrtc->State = HAL_RTC_STATE_READY;
;;;942      
;;;943       __HAL_UNLOCK(hrtc); 
;;;944         
;;;945       return HAL_OK;
;;;946      }
;;;947    }
00078e  e8bd83f8          POP      {r3-r9,pc}
                  |L1.1938|
000792  bf00              NOP                            ;885
000794  7c20              LDRB     r0,[r4,#0x10]         ;885
000796  2801              CMP      r0,#1                 ;885
000798  d101              BNE      |L1.1950|
00079a  2002              MOVS     r0,#2                 ;885
00079c  e7f7              B        |L1.1934|
                  |L1.1950|
00079e  2001              MOVS     r0,#1                 ;885
0007a0  7420              STRB     r0,[r4,#0x10]         ;885
0007a2  bf00              NOP                            ;885
0007a4  2002              MOVS     r0,#2                 ;887
0007a6  7460              STRB     r0,[r4,#0x11]         ;887
0007a8  2200              MOVS     r2,#0                 ;890
0007aa  4669              MOV      r1,sp                 ;890
0007ac  4620              MOV      r0,r4                 ;890
0007ae  f7fffffe          BL       HAL_RTC_GetTime
0007b2  b108              CBZ      r0,|L1.1976|
0007b4  2001              MOVS     r0,#1                 ;892
0007b6  e7ea              B        |L1.1934|
                  |L1.1976|
0007b8  f89d0000          LDRB     r0,[sp,#0]            ;896
0007bc  f44f6161          MOV      r1,#0xe10             ;896
0007c0  4348              MULS     r0,r1,r0              ;896
0007c2  f89d1001          LDRB     r1,[sp,#1]            ;896
0007c6  ebc11101          RSB      r1,r1,r1,LSL #4       ;896
0007ca  eb000081          ADD      r0,r0,r1,LSL #2       ;896
0007ce  f89d1002          LDRB     r1,[sp,#2]            ;896
0007d2  eb000801          ADD      r8,r0,r1              ;896
0007d6  b95f              CBNZ     r7,|L1.2032|
0007d8  7828              LDRB     r0,[r5,#0]            ;906
0007da  f44f6161          MOV      r1,#0xe10             ;906
0007de  4348              MULS     r0,r1,r0              ;906
0007e0  7869              LDRB     r1,[r5,#1]            ;906
0007e2  ebc11101          RSB      r1,r1,r1,LSL #4       ;906
0007e6  eb000081          ADD      r0,r0,r1,LSL #2       ;906
0007ea  78a9              LDRB     r1,[r5,#2]            ;906
0007ec  1846              ADDS     r6,r0,r1              ;906
0007ee  e012              B        |L1.2070|
                  |L1.2032|
0007f0  7828              LDRB     r0,[r5,#0]            ;916
0007f2  f7fffffe          BL       RTC_Bcd2ToByte
0007f6  f44f6161          MOV      r1,#0xe10             ;916
0007fa  fb00f901          MUL      r9,r0,r1              ;916
0007fe  7868              LDRB     r0,[r5,#1]            ;916
000800  f7fffffe          BL       RTC_Bcd2ToByte
000804  ebc01000          RSB      r0,r0,r0,LSL #4       ;916
000808  eb090980          ADD      r9,r9,r0,LSL #2       ;916
00080c  78a8              LDRB     r0,[r5,#2]            ;916
00080e  f7fffffe          BL       RTC_Bcd2ToByte
000812  eb090600          ADD      r6,r9,r0              ;916
                  |L1.2070|
000816  4546              CMP      r6,r8                 ;922
000818  d201              BCS      |L1.2078|
00081a  48af              LDR      r0,|L1.2776|
00081c  4406              ADD      r6,r6,r0              ;925
                  |L1.2078|
00081e  4631              MOV      r1,r6                 ;929
000820  4620              MOV      r0,r4                 ;929
000822  f7fffffe          BL       RTC_WriteAlarmCounter
000826  b138              CBZ      r0,|L1.2104|
000828  2004              MOVS     r0,#4                 ;932
00082a  7460              STRB     r0,[r4,#0x11]         ;932
00082c  bf00              NOP                            ;935
00082e  2000              MOVS     r0,#0                 ;935
000830  7420              STRB     r0,[r4,#0x10]         ;935
000832  bf00              NOP                            ;935
000834  2001              MOVS     r0,#1                 ;937
000836  e7aa              B        |L1.1934|
                  |L1.2104|
000838  2001              MOVS     r0,#1                 ;941
00083a  7460              STRB     r0,[r4,#0x11]         ;941
00083c  bf00              NOP                            ;943
00083e  2000              MOVS     r0,#0                 ;943
000840  7420              STRB     r0,[r4,#0x10]         ;943
000842  bf00              NOP                            ;943
000844  bf00              NOP                            ;945
000846  e7a2              B        |L1.1934|
;;;948    
                          ENDP

                  HAL_RTC_SetAlarm_IT PROC
;;;960      */
;;;961    HAL_StatusTypeDef HAL_RTC_SetAlarm_IT(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
000848  e92d43f8          PUSH     {r3-r9,lr}
;;;962    {
00084c  4604              MOV      r4,r0
00084e  460d              MOV      r5,r1
000850  4617              MOV      r7,r2
;;;963      uint32_t counter_alarm = 0, counter_time;
000852  2600              MOVS     r6,#0
;;;964      RTC_TimeTypeDef stime = {0};
000854  2000              MOVS     r0,#0
000856  9000              STR      r0,[sp,#0]
;;;965      
;;;966      /* Check input parameters */
;;;967      if((hrtc == NULL) || (sAlarm == NULL))
000858  b104              CBZ      r4,|L1.2140|
00085a  b915              CBNZ     r5,|L1.2146|
                  |L1.2140|
;;;968      {
;;;969         return HAL_ERROR;
00085c  2001              MOVS     r0,#1
                  |L1.2142|
;;;970      }
;;;971      
;;;972      /* Check the parameters */
;;;973      assert_param(IS_RTC_FORMAT(Format));
;;;974      assert_param(IS_RTC_ALARM(sAlarm->Alarm));
;;;975    
;;;976      /* Process Locked */ 
;;;977      __HAL_LOCK(hrtc);
;;;978      
;;;979      hrtc->State = HAL_RTC_STATE_BUSY;
;;;980      
;;;981      /* Call HAL_RTC_GetTime function to update date if counter higher than 24 hours */
;;;982      if (HAL_RTC_GetTime(hrtc, &stime, RTC_FORMAT_BIN) != HAL_OK)
;;;983      {
;;;984        return HAL_ERROR;
;;;985      }
;;;986    
;;;987      /* Convert time in seconds */
;;;988      counter_time = (uint32_t)(((uint32_t)stime.Hours * 3600) + \
;;;989                          ((uint32_t)stime.Minutes * 60) + \
;;;990                          ((uint32_t)stime.Seconds));  
;;;991    
;;;992      if(Format == RTC_FORMAT_BIN)
;;;993      {
;;;994        assert_param(IS_RTC_HOUR24(sAlarm->AlarmTime.Hours));
;;;995        assert_param(IS_RTC_MINUTES(sAlarm->AlarmTime.Minutes));
;;;996        assert_param(IS_RTC_SECONDS(sAlarm->AlarmTime.Seconds));
;;;997        
;;;998        counter_alarm = (uint32_t)(((uint32_t)sAlarm->AlarmTime.Hours * 3600) + \
;;;999          ((uint32_t)sAlarm->AlarmTime.Minutes * 60) + \
;;;1000           ((uint32_t)sAlarm->AlarmTime.Seconds));  
;;;1001     }
;;;1002     else
;;;1003     {
;;;1004       assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
;;;1005       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)));
;;;1006       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));
;;;1007       
;;;1008       counter_alarm = (((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)) * 3600) + \
;;;1009         ((uint32_t)(RTC_Bcd2ToByte(sAlarm->AlarmTime.Minutes)) * 60) + \
;;;1010           ((uint32_t)RTC_Bcd2ToByte(sAlarm->AlarmTime.Seconds)));   
;;;1011     }
;;;1012     
;;;1013     /* Check that requested alarm should expire in the same day (otherwise add 1 day) */
;;;1014     if (counter_alarm < counter_time)
;;;1015     {
;;;1016       /* Add 1 day to alarm counter*/
;;;1017       counter_alarm += (uint32_t)(24 * 3600);
;;;1018     }
;;;1019   
;;;1020     /* Write alarm counter in RTC registers */
;;;1021     if (RTC_WriteAlarmCounter(hrtc, counter_alarm) != HAL_OK)
;;;1022     {
;;;1023       /* Set RTC state */
;;;1024       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1025       
;;;1026       /* Process Unlocked */ 
;;;1027       __HAL_UNLOCK(hrtc);
;;;1028       
;;;1029       return HAL_ERROR;
;;;1030     }
;;;1031     else
;;;1032     {
;;;1033       /* Clear flag alarm A */
;;;1034       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1035       
;;;1036       /* Configure the Alarm interrupt */
;;;1037       __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
;;;1038       
;;;1039       /* RTC Alarm Interrupt Configuration: EXTI configuration */
;;;1040       __HAL_RTC_ALARM_EXTI_ENABLE_IT();
;;;1041       
;;;1042       __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
;;;1043   
;;;1044       hrtc->State = HAL_RTC_STATE_READY;
;;;1045     
;;;1046      __HAL_UNLOCK(hrtc); 
;;;1047        
;;;1048      return HAL_OK;
;;;1049     }
;;;1050   }
00085e  e8bd83f8          POP      {r3-r9,pc}
                  |L1.2146|
000862  bf00              NOP                            ;977
000864  7c20              LDRB     r0,[r4,#0x10]         ;977
000866  2801              CMP      r0,#1                 ;977
000868  d101              BNE      |L1.2158|
00086a  2002              MOVS     r0,#2                 ;977
00086c  e7f7              B        |L1.2142|
                  |L1.2158|
00086e  2001              MOVS     r0,#1                 ;977
000870  7420              STRB     r0,[r4,#0x10]         ;977
000872  bf00              NOP                            ;977
000874  2002              MOVS     r0,#2                 ;979
000876  7460              STRB     r0,[r4,#0x11]         ;979
000878  2200              MOVS     r2,#0                 ;982
00087a  4669              MOV      r1,sp                 ;982
00087c  4620              MOV      r0,r4                 ;982
00087e  f7fffffe          BL       HAL_RTC_GetTime
000882  b108              CBZ      r0,|L1.2184|
000884  2001              MOVS     r0,#1                 ;984
000886  e7ea              B        |L1.2142|
                  |L1.2184|
000888  f89d0000          LDRB     r0,[sp,#0]            ;988
00088c  f44f6161          MOV      r1,#0xe10             ;988
000890  4348              MULS     r0,r1,r0              ;988
000892  f89d1001          LDRB     r1,[sp,#1]            ;988
000896  ebc11101          RSB      r1,r1,r1,LSL #4       ;988
00089a  eb000081          ADD      r0,r0,r1,LSL #2       ;988
00089e  f89d1002          LDRB     r1,[sp,#2]            ;988
0008a2  eb000801          ADD      r8,r0,r1              ;988
0008a6  b95f              CBNZ     r7,|L1.2240|
0008a8  7828              LDRB     r0,[r5,#0]            ;998
0008aa  f44f6161          MOV      r1,#0xe10             ;998
0008ae  4348              MULS     r0,r1,r0              ;998
0008b0  7869              LDRB     r1,[r5,#1]            ;998
0008b2  ebc11101          RSB      r1,r1,r1,LSL #4       ;998
0008b6  eb000081          ADD      r0,r0,r1,LSL #2       ;998
0008ba  78a9              LDRB     r1,[r5,#2]            ;998
0008bc  1846              ADDS     r6,r0,r1              ;998
0008be  e012              B        |L1.2278|
                  |L1.2240|
0008c0  7828              LDRB     r0,[r5,#0]            ;1008
0008c2  f7fffffe          BL       RTC_Bcd2ToByte
0008c6  f44f6161          MOV      r1,#0xe10             ;1008
0008ca  fb00f901          MUL      r9,r0,r1              ;1008
0008ce  7868              LDRB     r0,[r5,#1]            ;1008
0008d0  f7fffffe          BL       RTC_Bcd2ToByte
0008d4  ebc01000          RSB      r0,r0,r0,LSL #4       ;1008
0008d8  eb090980          ADD      r9,r9,r0,LSL #2       ;1008
0008dc  78a8              LDRB     r0,[r5,#2]            ;1008
0008de  f7fffffe          BL       RTC_Bcd2ToByte
0008e2  eb090600          ADD      r6,r9,r0              ;1008
                  |L1.2278|
0008e6  4546              CMP      r6,r8                 ;1014
0008e8  d201              BCS      |L1.2286|
0008ea  487b              LDR      r0,|L1.2776|
0008ec  4406              ADD      r6,r6,r0              ;1017
                  |L1.2286|
0008ee  4631              MOV      r1,r6                 ;1021
0008f0  4620              MOV      r0,r4                 ;1021
0008f2  f7fffffe          BL       RTC_WriteAlarmCounter
0008f6  b138              CBZ      r0,|L1.2312|
0008f8  2004              MOVS     r0,#4                 ;1024
0008fa  7460              STRB     r0,[r4,#0x11]         ;1024
0008fc  bf00              NOP                            ;1027
0008fe  2000              MOVS     r0,#0                 ;1027
000900  7420              STRB     r0,[r4,#0x10]         ;1027
000902  bf00              NOP                            ;1027
000904  2001              MOVS     r0,#1                 ;1029
000906  e7aa              B        |L1.2142|
                  |L1.2312|
000908  f06f0002          MVN      r0,#2                 ;1034
00090c  6821              LDR      r1,[r4,#0]            ;1034
00090e  6048              STR      r0,[r1,#4]            ;1034
000910  6820              LDR      r0,[r4,#0]            ;1037
000912  6800              LDR      r0,[r0,#0]            ;1037
000914  f0400002          ORR      r0,r0,#2              ;1037
000918  6821              LDR      r1,[r4,#0]            ;1037
00091a  6008              STR      r0,[r1,#0]            ;1037
00091c  486f              LDR      r0,|L1.2780|
00091e  6800              LDR      r0,[r0,#0]            ;1040
000920  f4403000          ORR      r0,r0,#0x20000        ;1040
000924  496d              LDR      r1,|L1.2780|
000926  6008              STR      r0,[r1,#0]            ;1040
000928  486c              LDR      r0,|L1.2780|
00092a  3008              ADDS     r0,r0,#8              ;1042
00092c  6800              LDR      r0,[r0,#0]            ;1042
00092e  f4403000          ORR      r0,r0,#0x20000        ;1042
000932  496a              LDR      r1,|L1.2780|
000934  3108              ADDS     r1,r1,#8              ;1042
000936  6008              STR      r0,[r1,#0]            ;1042
000938  2001              MOVS     r0,#1                 ;1044
00093a  7460              STRB     r0,[r4,#0x11]         ;1044
00093c  bf00              NOP                            ;1046
00093e  2000              MOVS     r0,#0                 ;1046
000940  7420              STRB     r0,[r4,#0x10]         ;1046
000942  bf00              NOP                            ;1046
000944  bf00              NOP                            ;1048
000946  e78a              B        |L1.2142|
;;;1051   
                          ENDP

                  HAL_RTC_GetAlarm PROC
;;;1065     */
;;;1066   HAL_StatusTypeDef HAL_RTC_GetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Alarm, uint32_t Format)
000948  e92d41f0          PUSH     {r4-r8,lr}
;;;1067   {
00094c  4606              MOV      r6,r0
00094e  460c              MOV      r4,r1
000950  4690              MOV      r8,r2
000952  461f              MOV      r7,r3
;;;1068     uint32_t counter_alarm = 0;
000954  2500              MOVS     r5,#0
;;;1069   
;;;1070     /* Check input parameters */
;;;1071     if((hrtc == NULL) || (sAlarm == NULL))
000956  b106              CBZ      r6,|L1.2394|
000958  b914              CBNZ     r4,|L1.2400|
                  |L1.2394|
;;;1072     {
;;;1073        return HAL_ERROR;
00095a  2001              MOVS     r0,#1
                  |L1.2396|
;;;1074     }
;;;1075     
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_RTC_FORMAT(Format));
;;;1078     assert_param(IS_RTC_ALARM(Alarm));
;;;1079     
;;;1080     /* Read Alarm counter in RTC registers */
;;;1081     counter_alarm = RTC_ReadAlarmCounter(hrtc);
;;;1082   
;;;1083     /* Fill the structure with the read parameters */
;;;1084     /* Set hours in a day range (between 0 to 24)*/
;;;1085     sAlarm->AlarmTime.Hours   = (uint32_t)((counter_alarm / 3600) % 24);
;;;1086     sAlarm->AlarmTime.Minutes = (uint32_t)((counter_alarm % 3600) / 60);
;;;1087     sAlarm->AlarmTime.Seconds = (uint32_t)((counter_alarm % 3600) % 60);
;;;1088     
;;;1089     if(Format != RTC_FORMAT_BIN)
;;;1090     {
;;;1091       sAlarm->AlarmTime.Hours   = RTC_ByteToBcd2(sAlarm->AlarmTime.Hours);
;;;1092       sAlarm->AlarmTime.Minutes = RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes);
;;;1093       sAlarm->AlarmTime.Seconds = RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds);
;;;1094     }  
;;;1095     
;;;1096     return HAL_OK;
;;;1097   }
00095c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2400|
000960  4630              MOV      r0,r6                 ;1081
000962  f7fffffe          BL       RTC_ReadAlarmCounter
000966  4605              MOV      r5,r0                 ;1081
000968  f44f6061          MOV      r0,#0xe10             ;1085
00096c  fbb5f0f0          UDIV     r0,r5,r0              ;1085
000970  2118              MOVS     r1,#0x18              ;1085
000972  fbb0f2f1          UDIV     r2,r0,r1              ;1085
000976  fb010012          MLS      r0,r1,r2,r0           ;1085
00097a  7020              STRB     r0,[r4,#0]            ;1085
00097c  f44f6061          MOV      r0,#0xe10             ;1086
000980  fbb5f1f0          UDIV     r1,r5,r0              ;1086
000984  fb005011          MLS      r0,r0,r1,r5           ;1086
000988  213c              MOVS     r1,#0x3c              ;1086
00098a  fbb0f0f1          UDIV     r0,r0,r1              ;1086
00098e  7060              STRB     r0,[r4,#1]            ;1086
000990  f44f6061          MOV      r0,#0xe10             ;1087
000994  fbb5f1f0          UDIV     r1,r5,r0              ;1087
000998  fb005011          MLS      r0,r0,r1,r5           ;1087
00099c  213c              MOVS     r1,#0x3c              ;1087
00099e  fbb0f2f1          UDIV     r2,r0,r1              ;1087
0009a2  fb010012          MLS      r0,r1,r2,r0           ;1087
0009a6  70a0              STRB     r0,[r4,#2]            ;1087
0009a8  b15f              CBZ      r7,|L1.2498|
0009aa  7820              LDRB     r0,[r4,#0]            ;1091
0009ac  f7fffffe          BL       RTC_ByteToBcd2
0009b0  7020              STRB     r0,[r4,#0]            ;1091
0009b2  7860              LDRB     r0,[r4,#1]            ;1092
0009b4  f7fffffe          BL       RTC_ByteToBcd2
0009b8  7060              STRB     r0,[r4,#1]            ;1092
0009ba  78a0              LDRB     r0,[r4,#2]            ;1093
0009bc  f7fffffe          BL       RTC_ByteToBcd2
0009c0  70a0              STRB     r0,[r4,#2]            ;1093
                  |L1.2498|
0009c2  2000              MOVS     r0,#0                 ;1096
0009c4  e7ca              B        |L1.2396|
;;;1098   
                          ENDP

                  HAL_RTC_DeactivateAlarm PROC
;;;1107     */
;;;1108   HAL_StatusTypeDef HAL_RTC_DeactivateAlarm(RTC_HandleTypeDef *hrtc, uint32_t Alarm)
0009c6  b570              PUSH     {r4-r6,lr}
;;;1109   {
0009c8  4604              MOV      r4,r0
0009ca  460d              MOV      r5,r1
;;;1110     /* Check the parameters */
;;;1111     assert_param(IS_RTC_ALARM(Alarm));
;;;1112     
;;;1113     /* Check input parameters */
;;;1114     if(hrtc == NULL)
0009cc  b90c              CBNZ     r4,|L1.2514|
;;;1115     {
;;;1116        return HAL_ERROR;
0009ce  2001              MOVS     r0,#1
                  |L1.2512|
;;;1117     }
;;;1118     
;;;1119     /* Process Locked */ 
;;;1120     __HAL_LOCK(hrtc);
;;;1121     
;;;1122     hrtc->State = HAL_RTC_STATE_BUSY;
;;;1123     
;;;1124     /* In case of interrupt mode is used, the interrupt source must disabled */ 
;;;1125     __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
;;;1126     
;;;1127     /* Set Initialization mode */
;;;1128     if(RTC_EnterInitMode(hrtc) != HAL_OK)
;;;1129     {
;;;1130       /* Set RTC state */
;;;1131       hrtc->State = HAL_RTC_STATE_ERROR;
;;;1132       
;;;1133       /* Process Unlocked */ 
;;;1134       __HAL_UNLOCK(hrtc);
;;;1135       
;;;1136       return HAL_ERROR;
;;;1137     } 
;;;1138     else
;;;1139     {
;;;1140       /* Clear flag alarm A */
;;;1141       __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1142       
;;;1143       /* Set to default values ALRH & ALRL registers */
;;;1144       WRITE_REG(hrtc->Instance->ALRH, RTC_ALARM_RESETVALUE_REGISTER);
;;;1145       WRITE_REG(hrtc->Instance->ALRL, RTC_ALARM_RESETVALUE_REGISTER);
;;;1146   
;;;1147       /* RTC Alarm Interrupt Configuration: Disable EXTI configuration */
;;;1148       __HAL_RTC_ALARM_EXTI_DISABLE_IT();
;;;1149       
;;;1150       /* Wait for synchro */
;;;1151       if(RTC_ExitInitMode(hrtc) != HAL_OK)
;;;1152       {       
;;;1153         hrtc->State = HAL_RTC_STATE_ERROR;
;;;1154         
;;;1155         /* Process Unlocked */ 
;;;1156         __HAL_UNLOCK(hrtc);
;;;1157         
;;;1158         return HAL_ERROR;
;;;1159       }
;;;1160     }
;;;1161     hrtc->State = HAL_RTC_STATE_READY; 
;;;1162     
;;;1163     /* Process Unlocked */ 
;;;1164     __HAL_UNLOCK(hrtc);  
;;;1165     
;;;1166     return HAL_OK; 
;;;1167   }
0009d0  bd70              POP      {r4-r6,pc}
                  |L1.2514|
0009d2  bf00              NOP                            ;1120
0009d4  7c20              LDRB     r0,[r4,#0x10]         ;1120
0009d6  2801              CMP      r0,#1                 ;1120
0009d8  d101              BNE      |L1.2526|
0009da  2002              MOVS     r0,#2                 ;1120
0009dc  e7f8              B        |L1.2512|
                  |L1.2526|
0009de  2001              MOVS     r0,#1                 ;1120
0009e0  7420              STRB     r0,[r4,#0x10]         ;1120
0009e2  bf00              NOP                            ;1120
0009e4  2002              MOVS     r0,#2                 ;1122
0009e6  7460              STRB     r0,[r4,#0x11]         ;1122
0009e8  6820              LDR      r0,[r4,#0]            ;1125
0009ea  6800              LDR      r0,[r0,#0]            ;1125
0009ec  f0200002          BIC      r0,r0,#2              ;1125
0009f0  6821              LDR      r1,[r4,#0]            ;1125
0009f2  6008              STR      r0,[r1,#0]            ;1125
0009f4  4620              MOV      r0,r4                 ;1128
0009f6  f7fffffe          BL       RTC_EnterInitMode
0009fa  b138              CBZ      r0,|L1.2572|
0009fc  2004              MOVS     r0,#4                 ;1131
0009fe  7460              STRB     r0,[r4,#0x11]         ;1131
000a00  bf00              NOP                            ;1134
000a02  2000              MOVS     r0,#0                 ;1134
000a04  7420              STRB     r0,[r4,#0x10]         ;1134
000a06  bf00              NOP                            ;1134
000a08  2001              MOVS     r0,#1                 ;1136
000a0a  e7e1              B        |L1.2512|
                  |L1.2572|
000a0c  f06f0002          MVN      r0,#2                 ;1141
000a10  6821              LDR      r1,[r4,#0]            ;1141
000a12  6048              STR      r0,[r1,#4]            ;1141
000a14  0c00              LSRS     r0,r0,#16             ;1144
000a16  6821              LDR      r1,[r4,#0]            ;1144
000a18  6208              STR      r0,[r1,#0x20]         ;1144
000a1a  6821              LDR      r1,[r4,#0]            ;1145
000a1c  6248              STR      r0,[r1,#0x24]         ;1145
000a1e  482f              LDR      r0,|L1.2780|
000a20  6800              LDR      r0,[r0,#0]            ;1148
000a22  f4203000          BIC      r0,r0,#0x20000        ;1148
000a26  492d              LDR      r1,|L1.2780|
000a28  6008              STR      r0,[r1,#0]            ;1148
000a2a  4620              MOV      r0,r4                 ;1151
000a2c  f7fffffe          BL       RTC_ExitInitMode
000a30  b138              CBZ      r0,|L1.2626|
000a32  2004              MOVS     r0,#4                 ;1153
000a34  7460              STRB     r0,[r4,#0x11]         ;1153
000a36  bf00              NOP                            ;1156
000a38  2000              MOVS     r0,#0                 ;1156
000a3a  7420              STRB     r0,[r4,#0x10]         ;1156
000a3c  bf00              NOP                            ;1156
000a3e  2001              MOVS     r0,#1                 ;1158
000a40  e7c6              B        |L1.2512|
                  |L1.2626|
000a42  2001              MOVS     r0,#1                 ;1161
000a44  7460              STRB     r0,[r4,#0x11]         ;1161
000a46  bf00              NOP                            ;1164
000a48  2000              MOVS     r0,#0                 ;1164
000a4a  7420              STRB     r0,[r4,#0x10]         ;1164
000a4c  bf00              NOP                            ;1164
000a4e  bf00              NOP                            ;1166
000a50  e7be              B        |L1.2512|
;;;1168   
                          ENDP

                  HAL_RTC_AlarmAEventCallback PROC
;;;1202     */
;;;1203   __weak void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
000a52  4770              BX       lr
;;;1204   {
;;;1205     /* Prevent unused argument(s) compilation warning */
;;;1206     UNUSED(hrtc);
;;;1207     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1208               the HAL_RTC_AlarmAEventCallback could be implemented in the user file
;;;1209      */
;;;1210   }
;;;1211   
                          ENDP

                  HAL_RTC_AlarmIRQHandler PROC
;;;1174     */
;;;1175   void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
000a54  b510              PUSH     {r4,lr}
;;;1176   {  
000a56  4604              MOV      r4,r0
;;;1177     if(__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA))
000a58  6820              LDR      r0,[r4,#0]
000a5a  6800              LDR      r0,[r0,#0]
000a5c  f3c00040          UBFX     r0,r0,#1,#1
000a60  b158              CBZ      r0,|L1.2682|
;;;1178     {
;;;1179       /* Get the status of the Interrupt */
;;;1180       if(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != (uint32_t)RESET)
000a62  6820              LDR      r0,[r4,#0]
000a64  6840              LDR      r0,[r0,#4]
000a66  f3c00040          UBFX     r0,r0,#1,#1
000a6a  b130              CBZ      r0,|L1.2682|
;;;1181       {
;;;1182         /* AlarmA callback */ 
;;;1183         HAL_RTC_AlarmAEventCallback(hrtc);
000a6c  4620              MOV      r0,r4
000a6e  f7fffffe          BL       HAL_RTC_AlarmAEventCallback
;;;1184         
;;;1185         /* Clear the Alarm interrupt pending bit */
;;;1186         __HAL_RTC_ALARM_CLEAR_FLAG(hrtc,RTC_FLAG_ALRAF);
000a72  f06f0002          MVN      r0,#2
000a76  6821              LDR      r1,[r4,#0]
000a78  6048              STR      r0,[r1,#4]
                  |L1.2682|
;;;1187       }
;;;1188     }
;;;1189     
;;;1190     /* Clear the EXTI's line Flag for RTC Alarm */
;;;1191     __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
000a7a  f44f3000          MOV      r0,#0x20000
000a7e  4917              LDR      r1,|L1.2780|
000a80  3114              ADDS     r1,r1,#0x14
000a82  6008              STR      r0,[r1,#0]
;;;1192     
;;;1193     /* Change RTC state */
;;;1194     hrtc->State = HAL_RTC_STATE_READY; 
000a84  2001              MOVS     r0,#1
000a86  7460              STRB     r0,[r4,#0x11]
;;;1195   }
000a88  bd10              POP      {r4,pc}
;;;1196   
                          ENDP

                  HAL_RTC_PollForAlarmAEvent PROC
;;;1218     */
;;;1219   HAL_StatusTypeDef HAL_RTC_PollForAlarmAEvent(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000a8a  b570              PUSH     {r4-r6,lr}
;;;1220   {  
000a8c  4604              MOV      r4,r0
000a8e  460d              MOV      r5,r1
;;;1221     uint32_t tickstart = HAL_GetTick();   
000a90  f7fffffe          BL       HAL_GetTick
000a94  4606              MOV      r6,r0
;;;1222     
;;;1223     /* Check input parameters */
;;;1224     if(hrtc == NULL)
000a96  b90c              CBNZ     r4,|L1.2716|
;;;1225     {
;;;1226        return HAL_ERROR;
000a98  2001              MOVS     r0,#1
                  |L1.2714|
;;;1227     }
;;;1228     
;;;1229     while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) == RESET)
;;;1230     {
;;;1231       if(Timeout != HAL_MAX_DELAY)
;;;1232       {
;;;1233         if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1234         {
;;;1235           hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;1236           return HAL_TIMEOUT;
;;;1237         }
;;;1238       }
;;;1239     }
;;;1240     
;;;1241     /* Clear the Alarm interrupt pending bit */
;;;1242     __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
;;;1243     
;;;1244     /* Change RTC state */
;;;1245     hrtc->State = HAL_RTC_STATE_READY; 
;;;1246     
;;;1247     return HAL_OK;  
;;;1248   }
000a9a  bd70              POP      {r4-r6,pc}
                  |L1.2716|
000a9c  e00a              B        |L1.2740|
                  |L1.2718|
000a9e  1c68              ADDS     r0,r5,#1              ;1231
000aa0  b140              CBZ      r0,|L1.2740|
000aa2  b125              CBZ      r5,|L1.2734|
000aa4  f7fffffe          BL       HAL_GetTick
000aa8  1b80              SUBS     r0,r0,r6              ;1233
000aaa  42a8              CMP      r0,r5                 ;1233
000aac  d902              BLS      |L1.2740|
                  |L1.2734|
000aae  2003              MOVS     r0,#3                 ;1235
000ab0  7460              STRB     r0,[r4,#0x11]         ;1235
000ab2  e7f2              B        |L1.2714|
                  |L1.2740|
000ab4  6820              LDR      r0,[r4,#0]            ;1229
000ab6  6840              LDR      r0,[r0,#4]            ;1229
000ab8  f3c00040          UBFX     r0,r0,#1,#1           ;1229
000abc  2800              CMP      r0,#0                 ;1229
000abe  d0ee              BEQ      |L1.2718|
000ac0  f06f0002          MVN      r0,#2                 ;1242
000ac4  6821              LDR      r1,[r4,#0]            ;1242
000ac6  6048              STR      r0,[r1,#4]            ;1242
000ac8  2001              MOVS     r0,#1                 ;1245
000aca  7460              STRB     r0,[r4,#0x11]         ;1245
000acc  2000              MOVS     r0,#0                 ;1247
000ace  e7e4              B        |L1.2714|
;;;1249   
                          ENDP

                  HAL_RTC_GetState PROC
;;;1273     */
;;;1274   HAL_RTCStateTypeDef HAL_RTC_GetState(RTC_HandleTypeDef* hrtc)
000ad0  4601              MOV      r1,r0
;;;1275   {
;;;1276     return hrtc->State;
000ad2  7c48              LDRB     r0,[r1,#0x11]
;;;1277   }
000ad4  4770              BX       lr
000ad6  0000              DCW      0x0000
                  |L1.2776|
                          DCD      0x00015180
                  |L1.2780|
                          DCD      0x40010400
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX|
#line 587
|__asm___19_stm32f1xx_hal_rtc_c_c7052556____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
