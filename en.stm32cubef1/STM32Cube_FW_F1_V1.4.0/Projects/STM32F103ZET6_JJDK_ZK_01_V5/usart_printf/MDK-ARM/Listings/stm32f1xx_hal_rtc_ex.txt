; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_rtc_ex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_rtc_ex.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_rtc_ex.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rtc_ex.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HAL_RTCEx_SetTamper PROC
;;;98       */
;;;99     HAL_StatusTypeDef HAL_RTCEx_SetTamper(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000000  4602              MOV      r2,r0
;;;100    {
;;;101      /* Check input parameters */
;;;102      if((hrtc == NULL) || (sTamper == NULL))
000002  b102              CBZ      r2,|L1.6|
000004  b909              CBNZ     r1,|L1.10|
                  |L1.6|
;;;103      {
;;;104         return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L1.8|
;;;105      }
;;;106      
;;;107      /* Check the parameters */
;;;108      assert_param(IS_RTC_TAMPER(sTamper->Tamper));
;;;109      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;110    
;;;111      /* Process Locked */
;;;112      __HAL_LOCK(hrtc);
;;;113    
;;;114      hrtc->State = HAL_RTC_STATE_BUSY;
;;;115      
;;;116      if (HAL_IS_BIT_SET(BKP->RTCCR,(BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
;;;117      {
;;;118        hrtc->State = HAL_RTC_STATE_ERROR;
;;;119        
;;;120        /* Process Unlocked */
;;;121        __HAL_UNLOCK(hrtc);
;;;122        
;;;123        return HAL_ERROR;
;;;124      }
;;;125    
;;;126      MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
;;;127    
;;;128      hrtc->State = HAL_RTC_STATE_READY; 
;;;129    
;;;130      /* Process Unlocked */
;;;131      __HAL_UNLOCK(hrtc);
;;;132    
;;;133      return HAL_OK;
;;;134    }
000008  4770              BX       lr
                  |L1.10|
00000a  bf00              NOP                            ;112
00000c  7c10              LDRB     r0,[r2,#0x10]         ;112
00000e  2801              CMP      r0,#1                 ;112
000010  d101              BNE      |L1.22|
000012  2002              MOVS     r0,#2                 ;112
000014  e7f8              B        |L1.8|
                  |L1.22|
000016  2001              MOVS     r0,#1                 ;112
000018  7410              STRB     r0,[r2,#0x10]         ;112
00001a  bf00              NOP                            ;112
00001c  2002              MOVS     r0,#2                 ;114
00001e  7450              STRB     r0,[r2,#0x11]         ;114
000020  48b0              LDR      r0,|L1.740|
000022  6800              LDR      r0,[r0,#0]            ;116
000024  f40070c0          AND      r0,r0,#0x180          ;116
000028  b138              CBZ      r0,|L1.58|
00002a  2004              MOVS     r0,#4                 ;118
00002c  7450              STRB     r0,[r2,#0x11]         ;118
00002e  bf00              NOP                            ;121
000030  2000              MOVS     r0,#0                 ;121
000032  7410              STRB     r0,[r2,#0x10]         ;121
000034  bf00              NOP                            ;121
000036  2001              MOVS     r0,#1                 ;123
000038  e7e6              B        |L1.8|
                  |L1.58|
00003a  e9d10300          LDRD     r0,r3,[r1,#0]         ;126
00003e  4318              ORRS     r0,r0,r3              ;126
000040  4ba8              LDR      r3,|L1.740|
000042  1d1b              ADDS     r3,r3,#4              ;126
000044  681b              LDR      r3,[r3,#0]            ;126
000046  f0230303          BIC      r3,r3,#3              ;126
00004a  4318              ORRS     r0,r0,r3              ;126
00004c  4ba5              LDR      r3,|L1.740|
00004e  1d1b              ADDS     r3,r3,#4              ;126
000050  6018              STR      r0,[r3,#0]            ;126
000052  2001              MOVS     r0,#1                 ;128
000054  7450              STRB     r0,[r2,#0x11]         ;128
000056  bf00              NOP                            ;131
000058  2000              MOVS     r0,#0                 ;131
00005a  7410              STRB     r0,[r2,#0x10]         ;131
00005c  bf00              NOP                            ;131
00005e  bf00              NOP                            ;133
000060  e7d2              B        |L1.8|
;;;135    
                          ENDP

                  HAL_RTCEx_SetTamper_IT PROC
;;;144      */
;;;145    HAL_StatusTypeDef HAL_RTCEx_SetTamper_IT(RTC_HandleTypeDef *hrtc, RTC_TamperTypeDef* sTamper)
000062  4602              MOV      r2,r0
;;;146    {
;;;147      /* Check input parameters */
;;;148      if((hrtc == NULL) || (sTamper == NULL))
000064  b102              CBZ      r2,|L1.104|
000066  b909              CBNZ     r1,|L1.108|
                  |L1.104|
;;;149      {
;;;150         return HAL_ERROR;
000068  2001              MOVS     r0,#1
                  |L1.106|
;;;151      }
;;;152      
;;;153      /* Check the parameters */
;;;154      assert_param(IS_RTC_TAMPER(sTamper->Tamper)); 
;;;155      assert_param(IS_RTC_TAMPER_TRIGGER(sTamper->Trigger));
;;;156    
;;;157      /* Process Locked */
;;;158      __HAL_LOCK(hrtc);
;;;159    
;;;160      hrtc->State = HAL_RTC_STATE_BUSY;
;;;161    
;;;162      if (HAL_IS_BIT_SET(BKP->RTCCR,(BKP_RTCCR_CCO | BKP_RTCCR_ASOE)))
;;;163      {
;;;164        hrtc->State = HAL_RTC_STATE_ERROR;
;;;165        
;;;166        /* Process Unlocked */
;;;167        __HAL_UNLOCK(hrtc);
;;;168        
;;;169        return HAL_ERROR;
;;;170      }
;;;171    
;;;172      MODIFY_REG(BKP->CR, (BKP_CR_TPE | BKP_CR_TPAL), (sTamper->Tamper | (sTamper->Trigger)));
;;;173    
;;;174      /* Configure the Tamper Interrupt in the BKP->CSR */
;;;175      __HAL_RTC_TAMPER_ENABLE_IT(hrtc, RTC_IT_TAMP1);
;;;176    
;;;177      hrtc->State = HAL_RTC_STATE_READY;
;;;178    
;;;179      /* Process Unlocked */
;;;180      __HAL_UNLOCK(hrtc);
;;;181    
;;;182      return HAL_OK;
;;;183    }
00006a  4770              BX       lr
                  |L1.108|
00006c  bf00              NOP                            ;158
00006e  7c10              LDRB     r0,[r2,#0x10]         ;158
000070  2801              CMP      r0,#1                 ;158
000072  d101              BNE      |L1.120|
000074  2002              MOVS     r0,#2                 ;158
000076  e7f8              B        |L1.106|
                  |L1.120|
000078  2001              MOVS     r0,#1                 ;158
00007a  7410              STRB     r0,[r2,#0x10]         ;158
00007c  bf00              NOP                            ;158
00007e  2002              MOVS     r0,#2                 ;160
000080  7450              STRB     r0,[r2,#0x11]         ;160
000082  4898              LDR      r0,|L1.740|
000084  6800              LDR      r0,[r0,#0]            ;162
000086  f40070c0          AND      r0,r0,#0x180          ;162
00008a  b138              CBZ      r0,|L1.156|
00008c  2004              MOVS     r0,#4                 ;164
00008e  7450              STRB     r0,[r2,#0x11]         ;164
000090  bf00              NOP                            ;167
000092  2000              MOVS     r0,#0                 ;167
000094  7410              STRB     r0,[r2,#0x10]         ;167
000096  bf00              NOP                            ;167
000098  2001              MOVS     r0,#1                 ;169
00009a  e7e6              B        |L1.106|
                  |L1.156|
00009c  e9d10300          LDRD     r0,r3,[r1,#0]         ;172
0000a0  4318              ORRS     r0,r0,r3              ;172
0000a2  4b90              LDR      r3,|L1.740|
0000a4  1d1b              ADDS     r3,r3,#4              ;172
0000a6  681b              LDR      r3,[r3,#0]            ;172
0000a8  f0230303          BIC      r3,r3,#3              ;172
0000ac  4318              ORRS     r0,r0,r3              ;172
0000ae  4b8d              LDR      r3,|L1.740|
0000b0  1d1b              ADDS     r3,r3,#4              ;172
0000b2  6018              STR      r0,[r3,#0]            ;172
0000b4  1d18              ADDS     r0,r3,#4              ;175
0000b6  6800              LDR      r0,[r0,#0]            ;175
0000b8  f0400004          ORR      r0,r0,#4              ;175
0000bc  1d1b              ADDS     r3,r3,#4              ;175
0000be  6018              STR      r0,[r3,#0]            ;175
0000c0  2001              MOVS     r0,#1                 ;177
0000c2  7450              STRB     r0,[r2,#0x11]         ;177
0000c4  bf00              NOP                            ;180
0000c6  2000              MOVS     r0,#0                 ;180
0000c8  7410              STRB     r0,[r2,#0x10]         ;180
0000ca  bf00              NOP                            ;180
0000cc  bf00              NOP                            ;182
0000ce  e7cc              B        |L1.106|
;;;184    
                          ENDP

                  HAL_RTCEx_DeactivateTamper PROC
;;;192      */
;;;193    HAL_StatusTypeDef HAL_RTCEx_DeactivateTamper(RTC_HandleTypeDef *hrtc, uint32_t Tamper)
0000d0  4602              MOV      r2,r0
;;;194    {
;;;195      /* Check input parameters */
;;;196      if(hrtc == NULL)
0000d2  b90a              CBNZ     r2,|L1.216|
;;;197      {
;;;198         return HAL_ERROR;
0000d4  2001              MOVS     r0,#1
                  |L1.214|
;;;199      }
;;;200      
;;;201      assert_param(IS_RTC_TAMPER(Tamper));
;;;202    
;;;203      /* Process Locked */
;;;204      __HAL_LOCK(hrtc);
;;;205    
;;;206      hrtc->State = HAL_RTC_STATE_BUSY;
;;;207    
;;;208      /* Disable the selected Tamper pin */
;;;209      CLEAR_BIT(BKP->CR, BKP_CR_TPE);
;;;210      
;;;211      /* Disable the Tamper Interrupt in the BKP->CSR */
;;;212      /* Configure the Tamper Interrupt in the BKP->CSR */
;;;213      __HAL_RTC_TAMPER_DISABLE_IT(hrtc, RTC_IT_TAMP1);
;;;214      
;;;215      /* Clear the Tamper interrupt pending bit */
;;;216      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc, RTC_FLAG_TAMP1F);
;;;217      SET_BIT(BKP->CSR, BKP_CSR_CTE);
;;;218      
;;;219      hrtc->State = HAL_RTC_STATE_READY;
;;;220    
;;;221      /* Process Unlocked */
;;;222      __HAL_UNLOCK(hrtc);
;;;223    
;;;224      return HAL_OK;
;;;225    }
0000d6  4770              BX       lr
                  |L1.216|
0000d8  bf00              NOP                            ;204
0000da  7c10              LDRB     r0,[r2,#0x10]         ;204
0000dc  2801              CMP      r0,#1                 ;204
0000de  d101              BNE      |L1.228|
0000e0  2002              MOVS     r0,#2                 ;204
0000e2  e7f8              B        |L1.214|
                  |L1.228|
0000e4  2001              MOVS     r0,#1                 ;204
0000e6  7410              STRB     r0,[r2,#0x10]         ;204
0000e8  bf00              NOP                            ;204
0000ea  2002              MOVS     r0,#2                 ;206
0000ec  7450              STRB     r0,[r2,#0x11]         ;206
0000ee  487d              LDR      r0,|L1.740|
0000f0  1d00              ADDS     r0,r0,#4              ;209
0000f2  6800              LDR      r0,[r0,#0]            ;209
0000f4  f0200001          BIC      r0,r0,#1              ;209
0000f8  4b7a              LDR      r3,|L1.740|
0000fa  1d1b              ADDS     r3,r3,#4              ;209
0000fc  6018              STR      r0,[r3,#0]            ;209
0000fe  1d18              ADDS     r0,r3,#4              ;213
000100  6800              LDR      r0,[r0,#0]            ;213
000102  f0200004          BIC      r0,r0,#4              ;213
000106  1d1b              ADDS     r3,r3,#4              ;213
000108  6018              STR      r0,[r3,#0]            ;213
00010a  4618              MOV      r0,r3                 ;216
00010c  6800              LDR      r0,[r0,#0]            ;216
00010e  f0400003          ORR      r0,r0,#3              ;216
000112  6018              STR      r0,[r3,#0]            ;216
000114  4618              MOV      r0,r3                 ;217
000116  6800              LDR      r0,[r0,#0]            ;217
000118  f0400001          ORR      r0,r0,#1              ;217
00011c  6018              STR      r0,[r3,#0]            ;217
00011e  2001              MOVS     r0,#1                 ;219
000120  7450              STRB     r0,[r2,#0x11]         ;219
000122  bf00              NOP                            ;222
000124  2000              MOVS     r0,#0                 ;222
000126  7410              STRB     r0,[r2,#0x10]         ;222
000128  bf00              NOP                            ;222
00012a  bf00              NOP                            ;224
00012c  e7d3              B        |L1.214|
;;;226    
                          ENDP

                  HAL_RTCEx_Tamper1EventCallback PROC
;;;258      */
;;;259    __weak void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
00012e  4770              BX       lr
;;;260    {
;;;261      /* Prevent unused argument(s) compilation warning */
;;;262      UNUSED(hrtc);
;;;263      /* NOTE : This function Should not be modified, when the callback is needed,
;;;264                the HAL_RTCEx_Tamper1EventCallback could be implemented in the user file
;;;265       */
;;;266    }
;;;267    
                          ENDP

                  HAL_RTCEx_TamperIRQHandler PROC
;;;232      */
;;;233    void HAL_RTCEx_TamperIRQHandler(RTC_HandleTypeDef *hrtc)
000130  b510              PUSH     {r4,lr}
;;;234    {  
000132  4604              MOV      r4,r0
;;;235      /* Get the status of the Interrupt */
;;;236      if(__HAL_RTC_TAMPER_GET_IT_SOURCE(hrtc, RTC_IT_TAMP1))
000134  486b              LDR      r0,|L1.740|
000136  3008              ADDS     r0,r0,#8
000138  6800              LDR      r0,[r0,#0]
00013a  f3c00080          UBFX     r0,r0,#2,#1
00013e  b180              CBZ      r0,|L1.354|
;;;237      {
;;;238        /* Get the TAMPER Interrupt enable bit and pending bit */
;;;239        if(__HAL_RTC_TAMPER_GET_FLAG(hrtc, RTC_FLAG_TAMP1F) != (uint32_t)RESET)
000140  4868              LDR      r0,|L1.740|
000142  3008              ADDS     r0,r0,#8
000144  6800              LDR      r0,[r0,#0]
000146  f3c02000          UBFX     r0,r0,#8,#1
00014a  b150              CBZ      r0,|L1.354|
;;;240        {
;;;241          /* Tamper callback */ 
;;;242          HAL_RTCEx_Tamper1EventCallback(hrtc);
00014c  4620              MOV      r0,r4
00014e  f7fffffe          BL       HAL_RTCEx_Tamper1EventCallback
;;;243      
;;;244          /* Clear the Tamper interrupt pending bit */
;;;245          __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
000152  4864              LDR      r0,|L1.740|
000154  3008              ADDS     r0,r0,#8
000156  6800              LDR      r0,[r0,#0]
000158  f0400003          ORR      r0,r0,#3
00015c  4961              LDR      r1,|L1.740|
00015e  3108              ADDS     r1,r1,#8
000160  6008              STR      r0,[r1,#0]
                  |L1.354|
;;;246        }
;;;247      }
;;;248    
;;;249      /* Change RTC state */
;;;250      hrtc->State = HAL_RTC_STATE_READY;
000162  2001              MOVS     r0,#1
000164  7460              STRB     r0,[r4,#0x11]
;;;251    }
000166  bd10              POP      {r4,pc}
;;;252    
                          ENDP

                  HAL_RTCEx_PollForTamper1Event PROC
;;;274      */
;;;275    HAL_StatusTypeDef HAL_RTCEx_PollForTamper1Event(RTC_HandleTypeDef *hrtc, uint32_t Timeout)
000168  b570              PUSH     {r4-r6,lr}
;;;276    {  
00016a  4604              MOV      r4,r0
00016c  460d              MOV      r5,r1
;;;277      uint32_t tickstart = HAL_GetTick();
00016e  f7fffffe          BL       HAL_GetTick
000172  4606              MOV      r6,r0
;;;278    
;;;279      /* Check input parameters */
;;;280      if(hrtc == NULL)
000174  b90c              CBNZ     r4,|L1.378|
;;;281      {
;;;282         return HAL_ERROR;
000176  2001              MOVS     r0,#1
                  |L1.376|
;;;283      }
;;;284      
;;;285      /* Get the status of the Interrupt */
;;;286      while(__HAL_RTC_TAMPER_GET_FLAG(hrtc,RTC_FLAG_TAMP1F)== RESET)
;;;287      {
;;;288        if(Timeout != HAL_MAX_DELAY)
;;;289        {
;;;290          if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;291          {
;;;292            hrtc->State = HAL_RTC_STATE_TIMEOUT;
;;;293            return HAL_TIMEOUT;
;;;294          }
;;;295        }
;;;296      }
;;;297    
;;;298      /* Clear the Tamper Flag */
;;;299      __HAL_RTC_TAMPER_CLEAR_FLAG(hrtc,RTC_FLAG_TAMP1F);
;;;300    
;;;301      /* Change RTC state */
;;;302      hrtc->State = HAL_RTC_STATE_READY;
;;;303    
;;;304      return HAL_OK;
;;;305    }
000178  bd70              POP      {r4-r6,pc}
                  |L1.378|
00017a  e00a              B        |L1.402|
                  |L1.380|
00017c  1c68              ADDS     r0,r5,#1              ;288
00017e  b140              CBZ      r0,|L1.402|
000180  b125              CBZ      r5,|L1.396|
000182  f7fffffe          BL       HAL_GetTick
000186  1b80              SUBS     r0,r0,r6              ;290
000188  42a8              CMP      r0,r5                 ;290
00018a  d902              BLS      |L1.402|
                  |L1.396|
00018c  2003              MOVS     r0,#3                 ;292
00018e  7460              STRB     r0,[r4,#0x11]         ;292
000190  e7f2              B        |L1.376|
                  |L1.402|
000192  4854              LDR      r0,|L1.740|
000194  3008              ADDS     r0,r0,#8              ;286
000196  6800              LDR      r0,[r0,#0]            ;286
000198  f3c02000          UBFX     r0,r0,#8,#1           ;286
00019c  2800              CMP      r0,#0                 ;286
00019e  d0ed              BEQ      |L1.380|
0001a0  4850              LDR      r0,|L1.740|
0001a2  3008              ADDS     r0,r0,#8              ;299
0001a4  6800              LDR      r0,[r0,#0]            ;299
0001a6  f0400003          ORR      r0,r0,#3              ;299
0001aa  494e              LDR      r1,|L1.740|
0001ac  3108              ADDS     r1,r1,#8              ;299
0001ae  6008              STR      r0,[r1,#0]            ;299
0001b0  2001              MOVS     r0,#1                 ;302
0001b2  7460              STRB     r0,[r4,#0x11]         ;302
0001b4  2000              MOVS     r0,#0                 ;304
0001b6  e7df              B        |L1.376|
;;;306    
                          ENDP

                  HAL_RTCEx_SetSecond_IT PROC
;;;330      */
;;;331    HAL_StatusTypeDef HAL_RTCEx_SetSecond_IT(RTC_HandleTypeDef *hrtc)
0001b8  4601              MOV      r1,r0
;;;332    {
;;;333      /* Check input parameters */
;;;334      if(hrtc == NULL)
0001ba  b909              CBNZ     r1,|L1.448|
;;;335      {
;;;336         return HAL_ERROR;
0001bc  2001              MOVS     r0,#1
                  |L1.446|
;;;337      }
;;;338      
;;;339      /* Process Locked */
;;;340      __HAL_LOCK(hrtc);
;;;341    
;;;342      hrtc->State = HAL_RTC_STATE_BUSY;
;;;343    
;;;344      /* Enable Second interuption */
;;;345      __HAL_RTC_SECOND_ENABLE_IT(hrtc, RTC_IT_SEC);
;;;346      
;;;347      hrtc->State = HAL_RTC_STATE_READY;
;;;348    
;;;349      /* Process Unlocked */
;;;350      __HAL_UNLOCK(hrtc);
;;;351    
;;;352      return HAL_OK;
;;;353    }
0001be  4770              BX       lr
                  |L1.448|
0001c0  bf00              NOP                            ;340
0001c2  7c08              LDRB     r0,[r1,#0x10]         ;340
0001c4  2801              CMP      r0,#1                 ;340
0001c6  d101              BNE      |L1.460|
0001c8  2002              MOVS     r0,#2                 ;340
0001ca  e7f8              B        |L1.446|
                  |L1.460|
0001cc  2001              MOVS     r0,#1                 ;340
0001ce  7408              STRB     r0,[r1,#0x10]         ;340
0001d0  bf00              NOP                            ;340
0001d2  2002              MOVS     r0,#2                 ;342
0001d4  7448              STRB     r0,[r1,#0x11]         ;342
0001d6  6808              LDR      r0,[r1,#0]            ;345
0001d8  6800              LDR      r0,[r0,#0]            ;345
0001da  f0400001          ORR      r0,r0,#1              ;345
0001de  680a              LDR      r2,[r1,#0]            ;345
0001e0  6010              STR      r0,[r2,#0]            ;345
0001e2  2001              MOVS     r0,#1                 ;347
0001e4  7448              STRB     r0,[r1,#0x11]         ;347
0001e6  bf00              NOP                            ;350
0001e8  2000              MOVS     r0,#0                 ;350
0001ea  7408              STRB     r0,[r1,#0x10]         ;350
0001ec  bf00              NOP                            ;350
0001ee  bf00              NOP                            ;352
0001f0  e7e5              B        |L1.446|
;;;354    
                          ENDP

                  HAL_RTCEx_DeactivateSecond PROC
;;;360      */
;;;361    HAL_StatusTypeDef HAL_RTCEx_DeactivateSecond(RTC_HandleTypeDef *hrtc)
0001f2  4601              MOV      r1,r0
;;;362    {
;;;363      /* Check input parameters */
;;;364      if(hrtc == NULL)
0001f4  b909              CBNZ     r1,|L1.506|
;;;365      {
;;;366         return HAL_ERROR;
0001f6  2001              MOVS     r0,#1
                  |L1.504|
;;;367      }
;;;368      
;;;369      /* Process Locked */
;;;370      __HAL_LOCK(hrtc);
;;;371    
;;;372      hrtc->State = HAL_RTC_STATE_BUSY;
;;;373    
;;;374      /* Deactivate Second interuption*/ 
;;;375      __HAL_RTC_SECOND_DISABLE_IT(hrtc, RTC_IT_SEC);
;;;376      
;;;377      hrtc->State = HAL_RTC_STATE_READY;
;;;378    
;;;379      /* Process Unlocked */
;;;380      __HAL_UNLOCK(hrtc);
;;;381    
;;;382      return HAL_OK;
;;;383    }
0001f8  4770              BX       lr
                  |L1.506|
0001fa  bf00              NOP                            ;370
0001fc  7c08              LDRB     r0,[r1,#0x10]         ;370
0001fe  2801              CMP      r0,#1                 ;370
000200  d101              BNE      |L1.518|
000202  2002              MOVS     r0,#2                 ;370
000204  e7f8              B        |L1.504|
                  |L1.518|
000206  2001              MOVS     r0,#1                 ;370
000208  7408              STRB     r0,[r1,#0x10]         ;370
00020a  bf00              NOP                            ;370
00020c  2002              MOVS     r0,#2                 ;372
00020e  7448              STRB     r0,[r1,#0x11]         ;372
000210  6808              LDR      r0,[r1,#0]            ;375
000212  6800              LDR      r0,[r0,#0]            ;375
000214  f0200001          BIC      r0,r0,#1              ;375
000218  680a              LDR      r2,[r1,#0]            ;375
00021a  6010              STR      r0,[r2,#0]            ;375
00021c  2001              MOVS     r0,#1                 ;377
00021e  7448              STRB     r0,[r1,#0x11]         ;377
000220  bf00              NOP                            ;380
000222  2000              MOVS     r0,#0                 ;380
000224  7408              STRB     r0,[r1,#0x10]         ;380
000226  bf00              NOP                            ;380
000228  bf00              NOP                            ;382
00022a  e7e5              B        |L1.504|
;;;384    
                          ENDP

                  HAL_RTCEx_RTCEventCallback PROC
;;;430      */
;;;431    __weak void HAL_RTCEx_RTCEventCallback(RTC_HandleTypeDef *hrtc)
00022c  4770              BX       lr
;;;432    {
;;;433      /* Prevent unused argument(s) compilation warning */
;;;434      UNUSED(hrtc);
;;;435      /* NOTE : This function Should not be modified, when the callback is needed,
;;;436                the HAL_RTCEx_RTCEventCallback could be implemented in the user file
;;;437       */
;;;438    }
;;;439    
                          ENDP

                  HAL_RTCEx_RTCEventErrorCallback PROC
;;;445      */
;;;446    __weak void HAL_RTCEx_RTCEventErrorCallback(RTC_HandleTypeDef *hrtc)
00022e  4770              BX       lr
;;;447    {
;;;448      /* Prevent unused argument(s) compilation warning */
;;;449      UNUSED(hrtc);
;;;450      /* NOTE : This function Should not be modified, when the callback is needed,
;;;451                the HAL_RTCEx_RTCEventErrorCallback could be implemented in the user file
;;;452       */
;;;453    }
;;;454    
                          ENDP

                  HAL_RTCEx_RTCIRQHandler PROC
;;;390      */
;;;391    void HAL_RTCEx_RTCIRQHandler(RTC_HandleTypeDef* hrtc)
000230  b510              PUSH     {r4,lr}
;;;392    {
000232  4604              MOV      r4,r0
;;;393      if(__HAL_RTC_SECOND_GET_IT_SOURCE(hrtc, RTC_IT_SEC))
000234  6820              LDR      r0,[r4,#0]
000236  6800              LDR      r0,[r0,#0]
000238  f0000001          AND      r0,r0,#1
00023c  b1e0              CBZ      r0,|L1.632|
;;;394      {
;;;395        /* Get the status of the Interrupt */
;;;396        if(__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_SEC))
00023e  6820              LDR      r0,[r4,#0]
000240  6840              LDR      r0,[r0,#4]
000242  f0000001          AND      r0,r0,#1
000246  b1b8              CBZ      r0,|L1.632|
;;;397        {
;;;398          /* Check if Overrun occurred */
;;;399          if (__HAL_RTC_SECOND_GET_FLAG(hrtc, RTC_FLAG_OW))
000248  6820              LDR      r0,[r4,#0]
00024a  6840              LDR      r0,[r0,#4]
00024c  f3c00080          UBFX     r0,r0,#2,#1
000250  b148              CBZ      r0,|L1.614|
;;;400          {
;;;401            /* Second error callback */ 
;;;402            HAL_RTCEx_RTCEventErrorCallback(hrtc);
000252  4620              MOV      r0,r4
000254  f7fffffe          BL       HAL_RTCEx_RTCEventErrorCallback
;;;403            
;;;404            /* Clear flag Second */
;;;405            __HAL_RTC_OVERFLOW_CLEAR_FLAG(hrtc, RTC_FLAG_OW);
000258  f06f0004          MVN      r0,#4
00025c  6821              LDR      r1,[r4,#0]
00025e  6048              STR      r0,[r1,#4]
;;;406            
;;;407            /* Change RTC state */
;;;408            hrtc->State = HAL_RTC_STATE_ERROR; 
000260  2004              MOVS     r0,#4
000262  7460              STRB     r0,[r4,#0x11]
000264  e004              B        |L1.624|
                  |L1.614|
;;;409          }
;;;410          else 
;;;411          {
;;;412            /* Second callback */ 
;;;413            HAL_RTCEx_RTCEventCallback(hrtc);
000266  4620              MOV      r0,r4
000268  f7fffffe          BL       HAL_RTCEx_RTCEventCallback
;;;414            
;;;415            /* Change RTC state */
;;;416            hrtc->State = HAL_RTC_STATE_READY; 
00026c  2001              MOVS     r0,#1
00026e  7460              STRB     r0,[r4,#0x11]
                  |L1.624|
;;;417          }
;;;418          
;;;419          /* Clear flag Second */
;;;420          __HAL_RTC_SECOND_CLEAR_FLAG(hrtc, RTC_FLAG_SEC);
000270  f06f0001          MVN      r0,#1
000274  6821              LDR      r1,[r4,#0]
000276  6048              STR      r0,[r1,#4]
                  |L1.632|
;;;421        }
;;;422      }
;;;423    }
000278  bd10              POP      {r4,pc}
;;;424    
                          ENDP

                  HAL_RTCEx_BKUPWrite PROC
;;;485      */
;;;486    void HAL_RTCEx_BKUPWrite(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister, uint32_t Data)
00027a  b510              PUSH     {r4,lr}
;;;487    {
00027c  4603              MOV      r3,r0
;;;488      uint32_t tmp = 0;
00027e  2000              MOVS     r0,#0
;;;489    
;;;490      /* Check the parameters */
;;;491      assert_param(IS_RTC_BKP(BackupRegister));
;;;492      
;;;493      tmp = (uint32_t)BKP_BASE; 
000280  4818              LDR      r0,|L1.740|
000282  382c              SUBS     r0,r0,#0x2c
;;;494      tmp += (BackupRegister * 4);
000284  eb000081          ADD      r0,r0,r1,LSL #2
;;;495    
;;;496      *(__IO uint32_t *) tmp = (Data & BKP_DR1_D);
000288  b294              UXTH     r4,r2
00028a  6004              STR      r4,[r0,#0]
;;;497    }
00028c  bd10              POP      {r4,pc}
;;;498    
                          ENDP

                  HAL_RTCEx_BKUPRead PROC
;;;507      */
;;;508    uint32_t HAL_RTCEx_BKUPRead(RTC_HandleTypeDef *hrtc, uint32_t BackupRegister)
00028e  b510              PUSH     {r4,lr}
;;;509    {
000290  4603              MOV      r3,r0
;;;510      uint32_t backupregister = 0;
000292  2200              MOVS     r2,#0
;;;511      uint32_t pvalue = 0;
000294  2000              MOVS     r0,#0
;;;512    
;;;513      /* Check the parameters */
;;;514      assert_param(IS_RTC_BKP(BackupRegister));
;;;515    
;;;516      backupregister = (uint32_t)BKP_BASE; 
000296  4a13              LDR      r2,|L1.740|
000298  3a2c              SUBS     r2,r2,#0x2c
;;;517      backupregister += (BackupRegister * 4);
00029a  eb020281          ADD      r2,r2,r1,LSL #2
;;;518      
;;;519      pvalue = (*(__IO uint32_t *)(backupregister)) & BKP_DR1_D;
00029e  6814              LDR      r4,[r2,#0]
0002a0  b2a0              UXTH     r0,r4
;;;520    
;;;521      /* Read the specified register */
;;;522      return pvalue;
;;;523    }
0002a2  bd10              POP      {r4,pc}
;;;524    
                          ENDP

                  HAL_RTCEx_SetSmoothCalib PROC
;;;534      */
;;;535    HAL_StatusTypeDef HAL_RTCEx_SetSmoothCalib(RTC_HandleTypeDef* hrtc, uint32_t SmoothCalibPeriod, uint32_t SmoothCalibPlusPulses, uint32_t SmouthCalibMinusPulsesValue)
0002a4  b530              PUSH     {r4,r5,lr}
;;;536    {
0002a6  4604              MOV      r4,r0
;;;537      /* Check input parameters */
;;;538      if(hrtc == NULL)
0002a8  b90c              CBNZ     r4,|L1.686|
;;;539      {
;;;540         return HAL_ERROR;
0002aa  2001              MOVS     r0,#1
                  |L1.684|
;;;541      }
;;;542      
;;;543      /* Check the parameters */
;;;544      assert_param(IS_RTC_SMOOTH_CALIB_MINUS(SmouthCalibMinusPulsesValue));
;;;545      
;;;546      /* Process Locked */
;;;547      __HAL_LOCK(hrtc);
;;;548    
;;;549      hrtc->State = HAL_RTC_STATE_BUSY;
;;;550    
;;;551      /* Sets RTC Clock Calibration value.*/
;;;552      MODIFY_REG(BKP->RTCCR, BKP_RTCCR_CAL, SmouthCalibMinusPulsesValue);
;;;553    
;;;554      /* Change RTC state */
;;;555      hrtc->State = HAL_RTC_STATE_READY;
;;;556    
;;;557      /* Process Unlocked */
;;;558      __HAL_UNLOCK(hrtc);
;;;559    
;;;560      return HAL_OK;
;;;561    }
0002ac  bd30              POP      {r4,r5,pc}
                  |L1.686|
0002ae  bf00              NOP                            ;547
0002b0  7c20              LDRB     r0,[r4,#0x10]         ;547
0002b2  2801              CMP      r0,#1                 ;547
0002b4  d101              BNE      |L1.698|
0002b6  2002              MOVS     r0,#2                 ;547
0002b8  e7f8              B        |L1.684|
                  |L1.698|
0002ba  2001              MOVS     r0,#1                 ;547
0002bc  7420              STRB     r0,[r4,#0x10]         ;547
0002be  bf00              NOP                            ;547
0002c0  2002              MOVS     r0,#2                 ;549
0002c2  7460              STRB     r0,[r4,#0x11]         ;549
0002c4  4807              LDR      r0,|L1.740|
0002c6  6800              LDR      r0,[r0,#0]            ;552
0002c8  f020007f          BIC      r0,r0,#0x7f           ;552
0002cc  4318              ORRS     r0,r0,r3              ;552
0002ce  4d05              LDR      r5,|L1.740|
0002d0  6028              STR      r0,[r5,#0]            ;552
0002d2  2001              MOVS     r0,#1                 ;555
0002d4  7460              STRB     r0,[r4,#0x11]         ;555
0002d6  bf00              NOP                            ;558
0002d8  2000              MOVS     r0,#0                 ;558
0002da  7420              STRB     r0,[r4,#0x10]         ;558
0002dc  bf00              NOP                            ;558
0002de  bf00              NOP                            ;560
0002e0  e7e4              B        |L1.684|
;;;562    
                          ENDP

0002e2  0000              DCW      0x0000
                  |L1.740|
                          DCD      0x40006c2c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rtc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rtc_ex_c_3ad0e55f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
