###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.1.13263/W32 for ARM       20/Apr/2017  15:44:01
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
#    Command line =  
#        -f C:\Users\wkxbo\AppData\Local\Temp\EW49EA.tmp
#        (D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D USE_STM32F103ZET6_JJDK_ZK_01_V5 -D
#        DEBUG=1 -lC
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List
#        -lA
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List
#        -o
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\Inc\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\BSP\STM3210C_EVAL\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\include\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\src\flashloader\NXP\FlashQN9080\chip_qn908x\cmsis\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List\heap_4.lst
#    Object file  =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\Obj\heap_4.o
#
###############################################################################

D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c
      1          /*
      2              FreeRTOS V8.2.3 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /*
     71           * A sample implementation of pvPortMalloc() and vPortFree() that combines
     72           * (coalescences) adjacent memory blocks as they are freed, and in so doing
     73           * limits memory fragmentation.
     74           *
     75           * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
     76           * memory management pages of http://www.FreeRTOS.org for more information.
     77           */
     78          #include <stdlib.h>
     79          
     80          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     81          all the API functions to use the MPU wrappers.  That should only be done when
     82          task.h is included from an application file. */
     83          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     84          
     85          #include "FreeRTOS.h"
     86          #include "task.h"
     87          
     88          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     89          
     90          /* Block sizes must not get too small. */
     91          #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize << 1 ) )
     92          
     93          /* Assumes 8bit bytes! */
     94          #define heapBITS_PER_BYTE		( ( size_t ) 8 )
     95          
     96          /* Allocate the memory for the heap. */
     97          #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
     98          	/* The application writer has already defined the array used for the RTOS
     99          	heap - probably so it can be placed in a special segment or address. */
    100          	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
    101          #else

   \                                 In section .bss, align 4
    102          	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
   \                     ucHeap:
   \   00000000                      DS8 10240
    103          #endif /* configAPPLICATION_ALLOCATED_HEAP */
    104          
    105          /* Define the linked list structure.  This is used to link free blocks in order
    106          of their memory address. */
    107          typedef struct A_BLOCK_LINK
    108          {
    109          	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
    110          	size_t xBlockSize;						/*<< The size of the free block. */
    111          } BlockLink_t;
    112          
    113          /*-----------------------------------------------------------*/
    114          
    115          /*
    116           * Inserts a block of memory that is being freed into the correct position in
    117           * the list of free memory blocks.  The block being freed will be merged with
    118           * the block in front it and/or the block behind it if the memory blocks are
    119           * adjacent to each other.
    120           */
    121          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
    122          
    123          /*
    124           * Called automatically to setup the required heap structures the first time
    125           * pvPortMalloc() is called.
    126           */
    127          static void prvHeapInit( void );
    128          
    129          /*-----------------------------------------------------------*/
    130          
    131          /* The size of the structure placed at the beginning of each allocated memory
    132          block must by correctly byte aligned. */

   \                                 In section .rodata, align 4
    133          static const size_t xHeapStructSize	= ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \                     xHeapStructSize:
   \   00000000   0x00000008         DC32 8
    134          
    135          /* Create a couple of list links to mark the start and end of the list. */

   \                                 In section .bss, align 4
    136          static BlockLink_t xStart, *pxEnd = NULL;
   \                     xStart:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
   \                     pxEnd:
   \   00000000                      DS8 4
    137          
    138          /* Keeps track of the number of free bytes remaining, but says nothing about
    139          fragmentation. */

   \                                 In section .bss, align 4
    140          static size_t xFreeBytesRemaining = 0U;
   \                     xFreeBytesRemaining:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    141          static size_t xMinimumEverFreeBytesRemaining = 0U;
   \                     xMinimumEverFreeBytesRemaining:
   \   00000000                      DS8 4
    142          
    143          /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
    144          member of an BlockLink_t structure is set then the block belongs to the
    145          application.  When the bit is free the block is still part of the free heap
    146          space. */

   \                                 In section .bss, align 4
    147          static size_t xBlockAllocatedBit = 0;
   \                     xBlockAllocatedBit:
   \   00000000                      DS8 4
    148          
    149          /*-----------------------------------------------------------*/
    150          

   \                                 In section .text, align 2, keep-with-next
    151          void *pvPortMalloc( size_t xWantedSize )
    152          {
   \                     pvPortMalloc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    153          BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    154          void *pvReturn = NULL;
   \   00000006   0xF05F 0x0800      MOVS     R8,#+0
    155          
    156          	vTaskSuspendAll();
   \   0000000A   0x.... 0x....      BL       vTaskSuspendAll
    157          	{
    158          		/* If this is the first call to malloc then the heap will require
    159          		initialisation to setup the list of free blocks. */
    160          		if( pxEnd == NULL )
   \   0000000E   0x....             LDR.N    R0,??DataTable5
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??pvPortMalloc_0
    161          		{
    162          			prvHeapInit();
   \   00000016   0x.... 0x....      BL       prvHeapInit
    163          		}
    164          		else
    165          		{
    166          			mtCOVERAGE_TEST_MARKER();
    167          		}
    168          
    169          		/* Check the requested block size is not so large that the top bit is
    170          		set.  The top bit of the block size member of the BlockLink_t structure
    171          		is used to determine who owns the block - the application or the
    172          		kernel, so it must be free. */
    173          		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
   \                     ??pvPortMalloc_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable5_1
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x4204             TST      R4,R0
   \   00000020   0xD160             BNE.N    ??pvPortMalloc_1
    174          		{
    175          			/* The wanted size is increased so it can contain a BlockLink_t
    176          			structure in addition to the requested amount of bytes. */
    177          			if( xWantedSize > 0 )
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD010             BEQ.N    ??pvPortMalloc_2
    178          			{
    179          				xWantedSize += xHeapStructSize;
   \   00000026   0x....             LDR.N    R0,??DataTable5_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x1904             ADDS     R4,R0,R4
    180          
    181          				/* Ensure that blocks are always aligned to the required number
    182          				of bytes. */
    183          				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
   \   0000002C   0xF014 0x0F07      TST      R4,#0x7
   \   00000030   0xD00A             BEQ.N    ??pvPortMalloc_2
    184          				{
    185          					/* Byte alignment required. */
    186          					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   \   00000032   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000036   0xF014 0x0407      ANDS     R4,R4,#0x7
   \   0000003A   0x1B04             SUBS     R4,R0,R4
    187          					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
   \   0000003C   0xF014 0x0F07      TST      R4,#0x7
   \   00000040   0xD002             BEQ.N    ??pvPortMalloc_2
   \   00000042   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??pvPortMalloc_3: (+1)
   \   00000046   0xE7FE             B.N      ??pvPortMalloc_3
    188          				}
    189          				else
    190          				{
    191          					mtCOVERAGE_TEST_MARKER();
    192          				}
    193          			}
    194          			else
    195          			{
    196          				mtCOVERAGE_TEST_MARKER();
    197          			}
    198          
    199          			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
   \                     ??pvPortMalloc_2: (+1)
   \   00000048   0x2C00             CMP      R4,#+0
   \   0000004A   0xD04B             BEQ.N    ??pvPortMalloc_1
   \   0000004C   0x....             LDR.N    R0,??DataTable5_3
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x42A0             CMP      R0,R4
   \   00000052   0xD347             BCC.N    ??pvPortMalloc_1
    200          			{
    201          				/* Traverse the list from the start	(lowest address) block until
    202          				one	of adequate size is found. */
    203          				pxPreviousBlock = &xStart;
   \   00000054   0x....             LDR.N    R0,??DataTable5_4
   \   00000056   0x0006             MOVS     R6,R0
    204          				pxBlock = xStart.pxNextFreeBlock;
   \   00000058   0x....             LDR.N    R0,??DataTable5_4
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x0005             MOVS     R5,R0
    205          				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   \                     ??pvPortMalloc_4: (+1)
   \   0000005E   0x6868             LDR      R0,[R5, #+4]
   \   00000060   0x42A0             CMP      R0,R4
   \   00000062   0xD205             BCS.N    ??pvPortMalloc_5
   \   00000064   0x6828             LDR      R0,[R5, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??pvPortMalloc_5
    206          				{
    207          					pxPreviousBlock = pxBlock;
   \   0000006A   0x002E             MOVS     R6,R5
    208          					pxBlock = pxBlock->pxNextFreeBlock;
   \   0000006C   0x682D             LDR      R5,[R5, #+0]
   \   0000006E   0xE7F6             B.N      ??pvPortMalloc_4
    209          				}
    210          
    211          				/* If the end marker was reached then a block of adequate size
    212          				was	not found. */
    213          				if( pxBlock != pxEnd )
   \                     ??pvPortMalloc_5: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable5
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x4285             CMP      R5,R0
   \   00000076   0xD035             BEQ.N    ??pvPortMalloc_1
    214          				{
    215          					/* Return the memory space pointed to - jumping over the
    216          					BlockLink_t structure at its start. */
    217          					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
   \   00000078   0x6830             LDR      R0,[R6, #+0]
   \   0000007A   0x....             LDR.N    R1,??DataTable5_2
   \   0000007C   0x6809             LDR      R1,[R1, #+0]
   \   0000007E   0x4408             ADD      R0,R0,R1
   \   00000080   0x4680             MOV      R8,R0
    218          
    219          					/* This block is being returned for use so must be taken out
    220          					of the list of free blocks. */
    221          					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x6030             STR      R0,[R6, #+0]
    222          
    223          					/* If the block is larger than required it can be split into
    224          					two. */
    225          					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   \   00000086   0x....             LDR.N    R0,??DataTable5_2
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0x0040             LSLS     R0,R0,#+1
   \   0000008C   0x6869             LDR      R1,[R5, #+4]
   \   0000008E   0x1B09             SUBS     R1,R1,R4
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD210             BCS.N    ??pvPortMalloc_6
    226          					{
    227          						/* This block is to be split into two.  Create a new
    228          						block following the number of bytes requested. The void
    229          						cast is used to prevent byte alignment warnings from the
    230          						compiler. */
    231          						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   \   00000094   0xEB05 0x0004      ADD      R0,R5,R4
   \   00000098   0x0007             MOVS     R7,R0
    232          						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   \   0000009A   0xF017 0x0007      ANDS     R0,R7,#0x7
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD002             BEQ.N    ??pvPortMalloc_7
   \   000000A2   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??pvPortMalloc_8: (+1)
   \   000000A6   0xE7FE             B.N      ??pvPortMalloc_8
    233          
    234          						/* Calculate the sizes of two blocks split from the
    235          						single block. */
    236          						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   \                     ??pvPortMalloc_7: (+1)
   \   000000A8   0x6868             LDR      R0,[R5, #+4]
   \   000000AA   0x1B00             SUBS     R0,R0,R4
   \   000000AC   0x6078             STR      R0,[R7, #+4]
    237          						pxBlock->xBlockSize = xWantedSize;
   \   000000AE   0x606C             STR      R4,[R5, #+4]
    238          
    239          						/* Insert the new block into the list of free blocks. */
    240          						prvInsertBlockIntoFreeList( pxNewBlockLink );
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0x.... 0x....      BL       prvInsertBlockIntoFreeList
    241          					}
    242          					else
    243          					{
    244          						mtCOVERAGE_TEST_MARKER();
    245          					}
    246          
    247          					xFreeBytesRemaining -= pxBlock->xBlockSize;
   \                     ??pvPortMalloc_6: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable5_3
   \   000000B8   0x6801             LDR      R1,[R0, #+0]
   \   000000BA   0x6868             LDR      R0,[R5, #+4]
   \   000000BC   0x1A09             SUBS     R1,R1,R0
   \   000000BE   0x....             LDR.N    R0,??DataTable5_3
   \   000000C0   0x6001             STR      R1,[R0, #+0]
    248          
    249          					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
   \   000000C2   0x....             LDR.N    R0,??DataTable5_3
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x....             LDR.N    R1,??DataTable5_5
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xD203             BCS.N    ??pvPortMalloc_9
    250          					{
    251          						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
   \   000000CE   0x....             LDR.N    R0,??DataTable5_3
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x....             LDR.N    R1,??DataTable5_5
   \   000000D4   0x6008             STR      R0,[R1, #+0]
    252          					}
    253          					else
    254          					{
    255          						mtCOVERAGE_TEST_MARKER();
    256          					}
    257          
    258          					/* The block is being returned - it is allocated and owned
    259          					by the application and has no "next" block. */
    260          					pxBlock->xBlockSize |= xBlockAllocatedBit;
   \                     ??pvPortMalloc_9: (+1)
   \   000000D6   0x6869             LDR      R1,[R5, #+4]
   \   000000D8   0x....             LDR.N    R0,??DataTable5_1
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x4301             ORRS     R1,R0,R1
   \   000000DE   0x6069             STR      R1,[R5, #+4]
    261          					pxBlock->pxNextFreeBlock = NULL;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x6028             STR      R0,[R5, #+0]
    262          				}
    263          				else
    264          				{
    265          					mtCOVERAGE_TEST_MARKER();
    266          				}
    267          			}
    268          			else
    269          			{
    270          				mtCOVERAGE_TEST_MARKER();
    271          			}
    272          		}
    273          		else
    274          		{
    275          			mtCOVERAGE_TEST_MARKER();
    276          		}
    277          
    278          		traceMALLOC( pvReturn, xWantedSize );
    279          	}
    280          	( void ) xTaskResumeAll();
   \                     ??pvPortMalloc_1: (+1)
   \   000000E4   0x.... 0x....      BL       xTaskResumeAll
    281          
    282          	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
    283          	{
    284          		if( pvReturn == NULL )
    285          		{
    286          			extern void vApplicationMallocFailedHook( void );
    287          			vApplicationMallocFailedHook();
    288          		}
    289          		else
    290          		{
    291          			mtCOVERAGE_TEST_MARKER();
    292          		}
    293          	}
    294          	#endif
    295          
    296          	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   \   000000E8   0xF018 0x0007      ANDS     R0,R8,#0x7
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD002             BEQ.N    ??pvPortMalloc_10
   \   000000F0   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??pvPortMalloc_11: (+1)
   \   000000F4   0xE7FE             B.N      ??pvPortMalloc_11
    297          	return pvReturn;
   \                     ??pvPortMalloc_10: (+1)
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    298          }
    299          /*-----------------------------------------------------------*/
    300          

   \                                 In section .text, align 2, keep-with-next
    301          void vPortFree( void *pv )
    302          {
   \                     vPortFree: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    303          uint8_t *puc = ( uint8_t * ) pv;
   \   00000004   0x0026             MOVS     R6,R4
    304          BlockLink_t *pxLink;
    305          
    306          	if( pv != NULL )
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD02C             BEQ.N    ??vPortFree_0
    307          	{
    308          		/* The memory being freed will have an BlockLink_t structure immediately
    309          		before it. */
    310          		puc -= xHeapStructSize;
   \   0000000A   0x....             LDR.N    R0,??DataTable5_2
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x4240             RSBS     R0,R0,#+0
   \   00000010   0x4406             ADD      R6,R6,R0
    311          
    312          		/* This casting is to keep the compiler from issuing warnings. */
    313          		pxLink = ( void * ) puc;
   \   00000012   0x0035             MOVS     R5,R6
    314          
    315          		/* Check the block is actually allocated. */
    316          		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
   \   00000014   0x6868             LDR      R0,[R5, #+4]
   \   00000016   0x....             LDR.N    R1,??DataTable5_1
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD102             BNE.N    ??vPortFree_1
   \   0000001E   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??vPortFree_2: (+1)
   \   00000022   0xE7FE             B.N      ??vPortFree_2
    317          		configASSERT( pxLink->pxNextFreeBlock == NULL );
   \                     ??vPortFree_1: (+1)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD002             BEQ.N    ??vPortFree_3
   \   0000002A   0x.... 0x....      BL       ulPortSetInterruptMask
   \                     ??vPortFree_4: (+1)
   \   0000002E   0xE7FE             B.N      ??vPortFree_4
    318          
    319          		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
   \                     ??vPortFree_3: (+1)
   \   00000030   0x6868             LDR      R0,[R5, #+4]
   \   00000032   0x....             LDR.N    R1,??DataTable5_1
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD014             BEQ.N    ??vPortFree_0
    320          		{
    321          			if( pxLink->pxNextFreeBlock == NULL )
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD111             BNE.N    ??vPortFree_0
    322          			{
    323          				/* The block is being returned to the heap - it is no longer
    324          				allocated. */
    325          				pxLink->xBlockSize &= ~xBlockAllocatedBit;
   \   00000040   0x6869             LDR      R1,[R5, #+4]
   \   00000042   0x....             LDR.N    R0,??DataTable5_1
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x4381             BICS     R1,R1,R0
   \   00000048   0x6069             STR      R1,[R5, #+4]
    326          
    327          				vTaskSuspendAll();
   \   0000004A   0x.... 0x....      BL       vTaskSuspendAll
    328          				{
    329          					/* Add this block to the list of free blocks. */
    330          					xFreeBytesRemaining += pxLink->xBlockSize;
   \   0000004E   0x....             LDR.N    R0,??DataTable5_3
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0x6868             LDR      R0,[R5, #+4]
   \   00000054   0x1841             ADDS     R1,R0,R1
   \   00000056   0x....             LDR.N    R0,??DataTable5_3
   \   00000058   0x6001             STR      R1,[R0, #+0]
    331          					traceFREE( pv, pxLink->xBlockSize );
    332          					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       prvInsertBlockIntoFreeList
    333          				}
    334          				( void ) xTaskResumeAll();
   \   00000060   0x.... 0x....      BL       xTaskResumeAll
    335          			}
    336          			else
    337          			{
    338          				mtCOVERAGE_TEST_MARKER();
    339          			}
    340          		}
    341          		else
    342          		{
    343          			mtCOVERAGE_TEST_MARKER();
    344          		}
    345          	}
    346          }
   \                     ??vPortFree_0: (+1)
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return
    347          /*-----------------------------------------------------------*/
    348          

   \                                 In section .text, align 2, keep-with-next
    349          size_t xPortGetFreeHeapSize( void )
    350          {
    351          	return xFreeBytesRemaining;
   \                     xPortGetFreeHeapSize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_3
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    352          }
    353          /*-----------------------------------------------------------*/
    354          

   \                                 In section .text, align 2, keep-with-next
    355          size_t xPortGetMinimumEverFreeHeapSize( void )
    356          {
    357          	return xMinimumEverFreeBytesRemaining;
   \                     xPortGetMinimumEverFreeHeapSize: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable5_5
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    358          }
    359          /*-----------------------------------------------------------*/
    360          

   \                                 In section .text, align 2, keep-with-next
    361          void vPortInitialiseBlocks( void )
    362          {
    363          	/* This just exists to keep the linker quiet. */
    364          }
   \                     vPortInitialiseBlocks: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    365          /*-----------------------------------------------------------*/
    366          

   \                                 In section .text, align 2, keep-with-next
    367          static void prvHeapInit( void )
    368          {
   \                     prvHeapInit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    369          BlockLink_t *pxFirstFreeBlock;
    370          uint8_t *pucAlignedHeap;
    371          size_t uxAddress;
    372          size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
   \   00000002   0xF44F 0x5320      MOV      R3,#+10240
    373          
    374          	/* Ensure the heap starts on a correctly aligned boundary. */
    375          	uxAddress = ( size_t ) ucHeap;
   \   00000006   0x....             LDR.N    R0,??DataTable5_6
   \   00000008   0x0004             MOVS     R4,R0
    376          
    377          	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
   \   0000000A   0xF014 0x0F07      TST      R4,#0x7
   \   0000000E   0xD005             BEQ.N    ??prvHeapInit_0
    378          	{
    379          		uxAddress += ( portBYTE_ALIGNMENT - 1 );
   \   00000010   0x1DE4             ADDS     R4,R4,#+7
    380          		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \   00000012   0x08E4             LSRS     R4,R4,#+3
   \   00000014   0x00E4             LSLS     R4,R4,#+3
    381          		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
   \   00000016   0x1B1B             SUBS     R3,R3,R4
   \   00000018   0x....             LDR.N    R0,??DataTable5_6
   \   0000001A   0x18C3             ADDS     R3,R0,R3
    382          	}
    383          
    384          	pucAlignedHeap = ( uint8_t * ) uxAddress;
   \                     ??prvHeapInit_0: (+1)
   \   0000001C   0x0022             MOVS     R2,R4
    385          
    386          	/* xStart is used to hold a pointer to the first item in the list of free
    387          	blocks.  The void cast is used to prevent compiler warnings. */
    388          	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   \   0000001E   0x....             LDR.N    R0,??DataTable5_4
   \   00000020   0x6002             STR      R2,[R0, #+0]
    389          	xStart.xBlockSize = ( size_t ) 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R5,??DataTable5_4
   \   00000026   0x6068             STR      R0,[R5, #+4]
    390          
    391          	/* pxEnd is used to mark the end of the list of free blocks and is inserted
    392          	at the end of the heap space. */
    393          	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
   \   00000028   0x1898             ADDS     R0,R3,R2
   \   0000002A   0x0004             MOVS     R4,R0
    394          	uxAddress -= xHeapStructSize;
   \   0000002C   0x....             LDR.N    R0,??DataTable5_2
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x1A24             SUBS     R4,R4,R0
    395          	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   \   00000032   0x08E4             LSRS     R4,R4,#+3
   \   00000034   0x00E4             LSLS     R4,R4,#+3
    396          	pxEnd = ( void * ) uxAddress;
   \   00000036   0x....             LDR.N    R0,??DataTable5
   \   00000038   0x6004             STR      R4,[R0, #+0]
    397          	pxEnd->xBlockSize = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R5,??DataTable5
   \   0000003E   0x682D             LDR      R5,[R5, #+0]
   \   00000040   0x6068             STR      R0,[R5, #+4]
    398          	pxEnd->pxNextFreeBlock = NULL;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R5,??DataTable5
   \   00000046   0x682D             LDR      R5,[R5, #+0]
   \   00000048   0x6028             STR      R0,[R5, #+0]
    399          
    400          	/* To start with there is a single free block that is sized to take up the
    401          	entire heap space, minus the space taken by pxEnd. */
    402          	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   \   0000004A   0x0011             MOVS     R1,R2
    403          	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
   \   0000004C   0x1A60             SUBS     R0,R4,R1
   \   0000004E   0x6048             STR      R0,[R1, #+4]
    404          	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   \   00000050   0x....             LDR.N    R0,??DataTable5
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x6008             STR      R0,[R1, #+0]
    405          
    406          	/* Only one block exists - and it covers the entire usable heap space. */
    407          	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   \   00000056   0x6848             LDR      R0,[R1, #+4]
   \   00000058   0x....             LDR.N    R5,??DataTable5_5
   \   0000005A   0x6028             STR      R0,[R5, #+0]
    408          	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   \   0000005C   0x6848             LDR      R0,[R1, #+4]
   \   0000005E   0x....             LDR.N    R5,??DataTable5_3
   \   00000060   0x6028             STR      R0,[R5, #+0]
    409          
    410          	/* Work out the position of the top bit in a size_t variable. */
    411          	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
   \   00000062   0xF05F 0x4000      MOVS     R0,#-2147483648
   \   00000066   0x....             LDR.N    R5,??DataTable5_1
   \   00000068   0x6028             STR      R0,[R5, #+0]
    412          }
   \   0000006A   0xBC30             POP      {R4,R5}
   \   0000006C   0x4770             BX       LR               ;; return
    413          /*-----------------------------------------------------------*/
    414          

   \                                 In section .text, align 2, keep-with-next
    415          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
    416          {
   \                     prvInsertBlockIntoFreeList: (+1)
   \   00000000   0xB410             PUSH     {R4}
    417          BlockLink_t *pxIterator;
    418          uint8_t *puc;
    419          
    420          	/* Iterate through the list until a block is found that has a higher address
    421          	than the block being inserted. */
    422          	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   \   00000002   0x....             LDR.N    R1,??DataTable5_4
   \   00000004   0x000B             MOVS     R3,R1
   \                     ??prvInsertBlockIntoFreeList_0: (+1)
   \   00000006   0x6819             LDR      R1,[R3, #+0]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xD201             BCS.N    ??prvInsertBlockIntoFreeList_1
   \   0000000C   0x681B             LDR      R3,[R3, #+0]
   \   0000000E   0xE7FA             B.N      ??prvInsertBlockIntoFreeList_0
    423          	{
    424          		/* Nothing to do here, just iterate to the right position. */
    425          	}
    426          
    427          	/* Do the block being inserted, and the block it is being inserted after
    428          	make a contiguous block of memory? */
    429          	puc = ( uint8_t * ) pxIterator;
   \                     ??prvInsertBlockIntoFreeList_1: (+1)
   \   00000010   0x001A             MOVS     R2,R3
    430          	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
   \   00000012   0x6859             LDR      R1,[R3, #+4]
   \   00000014   0x4411             ADD      R1,R2,R1
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD104             BNE.N    ??prvInsertBlockIntoFreeList_2
    431          	{
    432          		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   \   0000001A   0x685C             LDR      R4,[R3, #+4]
   \   0000001C   0x6841             LDR      R1,[R0, #+4]
   \   0000001E   0x190C             ADDS     R4,R1,R4
   \   00000020   0x605C             STR      R4,[R3, #+4]
    433          		pxBlockToInsert = pxIterator;
   \   00000022   0x0018             MOVS     R0,R3
    434          	}
    435          	else
    436          	{
    437          		mtCOVERAGE_TEST_MARKER();
    438          	}
    439          
    440          	/* Do the block being inserted, and the block it is being inserted before
    441          	make a contiguous block of memory? */
    442          	puc = ( uint8_t * ) pxBlockToInsert;
   \                     ??prvInsertBlockIntoFreeList_2: (+1)
   \   00000024   0x0002             MOVS     R2,R0
    443          	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
   \   00000026   0x6841             LDR      R1,[R0, #+4]
   \   00000028   0x4411             ADD      R1,R2,R1
   \   0000002A   0x681C             LDR      R4,[R3, #+0]
   \   0000002C   0x42A1             CMP      R1,R4
   \   0000002E   0xD111             BNE.N    ??prvInsertBlockIntoFreeList_3
    444          	{
    445          		if( pxIterator->pxNextFreeBlock != pxEnd )
   \   00000030   0x6819             LDR      R1,[R3, #+0]
   \   00000032   0x....             LDR.N    R4,??DataTable5
   \   00000034   0x6824             LDR      R4,[R4, #+0]
   \   00000036   0x42A1             CMP      R1,R4
   \   00000038   0xD008             BEQ.N    ??prvInsertBlockIntoFreeList_4
    446          		{
    447          			/* Form one big block from the two blocks. */
    448          			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   \   0000003A   0x6844             LDR      R4,[R0, #+4]
   \   0000003C   0x6819             LDR      R1,[R3, #+0]
   \   0000003E   0x6849             LDR      R1,[R1, #+4]
   \   00000040   0x190C             ADDS     R4,R1,R4
   \   00000042   0x6044             STR      R4,[R0, #+4]
    449          			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   \   00000044   0x6819             LDR      R1,[R3, #+0]
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x6001             STR      R1,[R0, #+0]
   \   0000004A   0xE005             B.N      ??prvInsertBlockIntoFreeList_5
    450          		}
    451          		else
    452          		{
    453          			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   \                     ??prvInsertBlockIntoFreeList_4: (+1)
   \   0000004C   0x....             LDR.N    R1,??DataTable5
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x6001             STR      R1,[R0, #+0]
   \   00000052   0xE001             B.N      ??prvInsertBlockIntoFreeList_5
    454          		}
    455          	}
    456          	else
    457          	{
    458          		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
   \                     ??prvInsertBlockIntoFreeList_3: (+1)
   \   00000054   0x6819             LDR      R1,[R3, #+0]
   \   00000056   0x6001             STR      R1,[R0, #+0]
    459          	}
    460          
    461          	/* If the block being inserted plugged a gab, so was merged with the block
    462          	before and the block after, then it's pxNextFreeBlock pointer will have
    463          	already been set, and should not be set here as that would make it point
    464          	to itself. */
    465          	if( pxIterator != pxBlockToInsert )
   \                     ??prvInsertBlockIntoFreeList_5: (+1)
   \   00000058   0x4283             CMP      R3,R0
   \   0000005A   0xD000             BEQ.N    ??prvInsertBlockIntoFreeList_6
    466          	{
    467          		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   \   0000005C   0x6018             STR      R0,[R3, #+0]
    468          	}
    469          	else
    470          	{
    471          		mtCOVERAGE_TEST_MARKER();
    472          	}
    473          }
   \                     ??prvInsertBlockIntoFreeList_6: (+1)
   \   0000005E   0xBC10             POP      {R4}
   \   00000060   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     pxEnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     xBlockAllocatedBit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     xHeapStructSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     xFreeBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     xStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     xMinimumEverFreeBytesRemaining

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     ucHeap
    474          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvHeapInit
       4   prvInsertBlockIntoFreeList
      24   pvPortMalloc
        24   -> prvHeapInit
        24   -> prvInsertBlockIntoFreeList
        24   -> ulPortSetInterruptMask
        24   -> vTaskSuspendAll
        24   -> xTaskResumeAll
      16   vPortFree
        16   -> prvInsertBlockIntoFreeList
        16   -> ulPortSetInterruptMask
        16   -> vTaskSuspendAll
        16   -> xTaskResumeAll
       0   vPortInitialiseBlocks
       0   xPortGetFreeHeapSize
       0   xPortGetMinimumEverFreeHeapSize


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
     110  prvHeapInit
      98  prvInsertBlockIntoFreeList
     252  pvPortMalloc
       4  pxEnd
   10240  ucHeap
     102  vPortFree
       2  vPortInitialiseBlocks
       4  xBlockAllocatedBit
       4  xFreeBytesRemaining
       4  xHeapStructSize
       4  xMinimumEverFreeBytesRemaining
       6  xPortGetFreeHeapSize
       6  xPortGetMinimumEverFreeHeapSize
       8  xStart

 
 10 264 bytes in section .bss
      4 bytes in section .rodata
    604 bytes in section .text
 
    604 bytes of CODE  memory
      4 bytes of CONST memory
 10 264 bytes of DATA  memory

Errors: none
Warnings: none
