###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.1.13263/W32 for ARM       20/Apr/2017  15:44:04
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c
#    Command line =  
#        -f C:\Users\wkxbo\AppData\Local\Temp\EW5523.tmp
#        (D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D USE_STM32F103ZET6_JJDK_ZK_01_V5 -D
#        DEBUG=1 -lC
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List
#        -lA
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List
#        -o
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\Inc\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Drivers\BSP\STM3210C_EVAL\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\
#        -I
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\include\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\src\flashloader\NXP\FlashQN9080\chip_qn908x\cmsis\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\List\stm32f1xx_hal_uart.lst
#    Object file  =  
#        D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32F103ZET6_JJDK_ZK_01_V5\app\freertos\automatic_wine_machine\EWARM\DEBUG\Obj\stm32f1xx_hal_uart.o
#
###############################################################################

D:\development\stm32\src_code\stm32cubef1\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_uart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   UART HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Universal Asynchronous Receiver Transmitter (UART) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + IO operation functions
     12            *           + Peripheral Control functions 
     13            *           + Peripheral State and Errors functions  
     14            @verbatim
     15            ==============================================================================
     16                                  ##### How to use this driver #####
     17            ==============================================================================
     18            [..]
     19              The UART HAL driver can be used as follows:
     20              
     21              (#) Declare a UART_HandleTypeDef handle structure.
     22          
     23              (#) Initialize the UART low level resources by implementing the HAL_UART_MspInit() API:
     24                  (##) Enable the USARTx interface clock.
     25                  (##) UART pins configuration:
     26                      (+++) Enable the clock for the UART GPIOs.
     27                       (+++) Configure the USART pins (TX as alternate function pull-up, RX as alternate function Input).
     28                  (##) NVIC configuration if you need to use interrupt process (HAL_UART_Transmit_IT()
     29                       and HAL_UART_Receive_IT() APIs):
     30                      (+++) Configure the USARTx interrupt priority.
     31                      (+++) Enable the NVIC USART IRQ handle.
     32                  (##) DMA Configuration if you need to use DMA process (HAL_UART_Transmit_DMA()
     33                       and HAL_UART_Receive_DMA() APIs):
     34                      (+++) Declare a DMA handle structure for the Tx/Rx channel.
     35                      (+++) Enable the DMAx interface clock.
     36                      (+++) Configure the declared DMA handle structure with the required 
     37                            Tx/Rx parameters.                
     38                      (+++) Configure the DMA Tx/Rx channel.
     39                      (+++) Associate the initialized DMA handle to the UART DMA Tx/Rx handle.
     40                      (+++) Configure the priority and enable the NVIC for the transfer complete 
     41                            interrupt on the DMA Tx/Rx channel.
     42                      (+++) Configure the USARTx interrupt priority and enable the NVIC USART IRQ handle
     43                            (used for last byte sending completion detection in DMA non circular mode)
     44          
     45              (#) Program the Baud Rate, Word Length, Stop Bit, Parity, Hardware 
     46                  flow control and Mode(Receiver/Transmitter) in the huart Init structure.
     47          
     48              (#) For the UART asynchronous mode, initialize the UART registers by calling
     49                  the HAL_UART_Init() API.
     50          
     51              (#) For the UART Half duplex mode, initialize the UART registers by calling 
     52                  the HAL_HalfDuplex_Init() API.
     53          
     54              (#) For the LIN mode, initialize the UART registers by calling the HAL_LIN_Init() API.
     55          
     56              (#) For the Multi-Processor mode, initialize the UART registers by calling 
     57                  the HAL_MultiProcessor_Init() API.
     58          
     59               [..] 
     60                 (@) The specific UART interrupts (Transmission complete interrupt, 
     61                      RXNE interrupt and Error Interrupts) will be managed using the macros
     62                      __HAL_UART_ENABLE_IT() and __HAL_UART_DISABLE_IT() inside the transmit 
     63                      and receive process.
     64          
     65               [..] 
     66                 (@) These APIs (HAL_UART_Init() and HAL_HalfDuplex_Init()) configure also the 
     67                      low level Hardware GPIO, CLOCK, CORTEX...etc) by calling the customed 
     68                      HAL_UART_MspInit() API.
     69          
     70               [..] 
     71                  Three operation modes are available within this driver :
     72          
     73               *** Polling mode IO operation ***
     74               =================================
     75               [..]    
     76                 (+) Send an amount of data in blocking mode using HAL_UART_Transmit() 
     77                 (+) Receive an amount of data in blocking mode using HAL_UART_Receive()
     78                 
     79               *** Interrupt mode IO operation ***
     80               ===================================
     81               [..]
     82                 (+) Send an amount of data in non blocking mode using HAL_UART_Transmit_IT() 
     83                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     84                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     85                 (+) Receive an amount of data in non blocking mode using HAL_UART_Receive_IT() 
     86                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
     87                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
     88                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
     89                      add his own code by customization of function pointer HAL_UART_ErrorCallback
     90          
     91               *** DMA mode IO operation ***
     92               ==============================
     93               [..] 
     94                 (+) Send an amount of data in non blocking mode (DMA) using HAL_UART_Transmit_DMA() 
     95                 (+) At transmission end of half transfer HAL_UART_TxHalfCpltCallback is executed and user can 
     96                      add his own code by customization of function pointer HAL_UART_TxHalfCpltCallback 
     97                 (+) At transmission end of transfer HAL_UART_TxCpltCallback is executed and user can 
     98                      add his own code by customization of function pointer HAL_UART_TxCpltCallback
     99                 (+) Receive an amount of data in non blocking mode (DMA) using HAL_UART_Receive_DMA() 
    100                 (+) At reception end of half transfer HAL_UART_RxHalfCpltCallback is executed and user can 
    101                      add his own code by customization of function pointer HAL_UART_RxHalfCpltCallback 
    102                 (+) At reception end of transfer HAL_UART_RxCpltCallback is executed and user can 
    103                      add his own code by customization of function pointer HAL_UART_RxCpltCallback
    104                 (+) In case of transfer Error, HAL_UART_ErrorCallback() function is executed and user can 
    105                      add his own code by customization of function pointer HAL_UART_ErrorCallback
    106                 (+) Pause the DMA Transfer using HAL_UART_DMAPause()
    107                 (+) Resume the DMA Transfer using HAL_UART_DMAResume()
    108                 (+) Stop the DMA Transfer using HAL_UART_DMAStop()
    109          
    110               *** UART HAL driver macros list ***
    111               =============================================
    112               [..]
    113                 Below the list of most used macros in UART HAL driver.
    114          
    115                (+) __HAL_UART_ENABLE: Enable the UART peripheral 
    116                (+) __HAL_UART_DISABLE: Disable the UART peripheral
    117                (+) __HAL_UART_GET_FLAG : Check whether the specified UART flag is set or not
    118                (+) __HAL_UART_CLEAR_FLAG : Clear the specified UART pending flag
    119                (+) __HAL_UART_ENABLE_IT: Enable the specified UART interrupt
    120                (+) __HAL_UART_DISABLE_IT: Disable the specified UART interrupt
    121                (+) __HAL_UART_GET_IT_SOURCE: Check whether the specified UART interrupt has occurred or not
    122          
    123               [..]
    124                 (@) You can refer to the UART HAL driver header file for more useful macros 
    125                
    126            @endverbatim
    127            ******************************************************************************
    128            * @attention
    129            *
    130            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    131            *
    132            * Redistribution and use in source and binary forms, with or without modification,
    133            * are permitted provided that the following conditions are met:
    134            *   1. Redistributions of source code must retain the above copyright notice,
    135            *      this list of conditions and the following disclaimer.
    136            *   2. Redistributions in binary form must reproduce the above copyright notice,
    137            *      this list of conditions and the following disclaimer in the documentation
    138            *      and/or other materials provided with the distribution.
    139            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    140            *      may be used to endorse or promote products derived from this software
    141            *      without specific prior written permission.
    142            *
    143            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    144            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    145            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    146            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    147            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    148            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    149            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    150            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    151            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    152            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    153            *
    154            ******************************************************************************
    155            */
    156          
    157          /* Includes ------------------------------------------------------------------*/
    158          #include "stm32f1xx_hal.h"
    159          
    160          /** @addtogroup STM32F1xx_HAL_Driver
    161            * @{
    162            */
    163          
    164          /** @defgroup UART UART
    165            * @brief HAL UART module driver
    166            * @{
    167            */
    168          #ifdef HAL_UART_MODULE_ENABLED
    169              
    170          /* Private typedef -----------------------------------------------------------*/
    171          /* Private define ------------------------------------------------------------*/
    172          /* Private macros ------------------------------------------------------------*/
    173          /* Private variables ---------------------------------------------------------*/
    174          /* Private function prototypes -----------------------------------------------*/
    175          /** @addtogroup UART_Private_Functions   UART Private Functions
    176            * @{
    177            */
    178          static void UART_SetConfig (UART_HandleTypeDef *huart);
    179          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart);
    180          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart);
    181          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart);
    182          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma);
    183          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma);
    184          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma);
    185          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma);
    186          static void UART_DMAError(DMA_HandleTypeDef *hdma); 
    187          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout);
    188          /**
    189            * @}
    190            */
    191          
    192          /* Exported functions ---------------------------------------------------------*/
    193          
    194          /** @defgroup UART_Exported_Functions UART Exported Functions
    195            * @{
    196            */
    197          
    198          /** @defgroup UART_Exported_Functions_Group1 Initialization and de-initialization functions 
    199            *  @brief    Initialization and Configuration functions 
    200            *
    201          @verbatim
    202          ===============================================================================
    203                      ##### Initialization and Configuration functions #####
    204           ===============================================================================  
    205              [..]
    206              This subsection provides a set of functions allowing to initialize the USARTx or the UARTy 
    207              in asynchronous mode.
    208                (+) For the asynchronous mode only these parameters can be configured: 
    209                  (++) Baud Rate
    210                  (++) Word Length 
    211                  (++) Stop Bit
    212                  (++) Parity
    213                  (++) Hardware flow control
    214                  (++) Receiver/transmitter modes
    215              [..]
    216              The HAL_UART_Init(), HAL_HalfDuplex_Init(), HAL_LIN_Init() and HAL_MultiProcessor_Init() APIs 
    217              follow respectively the UART asynchronous, UART Half duplex, LIN and Multi-Processor
    218              configuration procedures (details for the procedures are available in reference manuals 
    219              (RM0008 for STM32F10Xxx MCUs and RM0041 for STM32F100xx MCUs)).
    220          
    221          
    222          @endverbatim
    223            * @{
    224            */
    225          
    226          /*
    227            Additionnal remark: If the parity is enabled, then the MSB bit of the data written
    228                                in the data register is transmitted but is changed by the parity bit.
    229                                Depending on the frame length defined by the M bit (8-bits or 9-bits),
    230                                the possible UART frame formats are as listed in the following table:
    231              +-------------------------------------------------------------+
    232              |   M bit |  PCE bit  |            UART frame                 |
    233              |---------------------|---------------------------------------|
    234              |    0    |    0      |    | SB | 8 bit data | STB |          |
    235              |---------|-----------|---------------------------------------|
    236              |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    237              |---------|-----------|---------------------------------------|
    238              |    1    |    0      |    | SB | 9 bit data | STB |          |
    239              |---------|-----------|---------------------------------------|
    240              |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    241              +-------------------------------------------------------------+
    242          */
    243          
    244          /**
    245            * @brief  Initializes the UART mode according to the specified parameters in
    246            *         the UART_InitTypeDef and create the associated handle.
    247            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    248            *                the configuration information for the specified UART module.
    249            * @retval HAL status
    250            */

   \                                 In section .text, align 2, keep-with-next
    251          HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
    252          {
   \                     HAL_UART_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    253            /* Check the UART handle allocation */
    254            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_Init_0
    255            {
    256              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE030             B.N      ??HAL_UART_Init_1
    257            }
    258          
    259            /* Check the parameters */
    260            if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
   \                     ??HAL_UART_Init_0: (+1)
   \   0000000C   0x69A0             LDR      R0,[R4, #+24]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD1FF             BNE.N    ??HAL_UART_Init_2
    261            {
    262              /* The hardware flow control is available only for USART1, USART2, USART3 */
    263              assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
    264              assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
    265            }
    266            else
    267            {
    268              assert_param(IS_UART_INSTANCE(huart->Instance));
    269            }
    270            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    271            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    272            
    273            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_UART_Init_3: (+1)
   \                     ??HAL_UART_Init_2: (+1)
   \   00000012   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD105             BNE.N    ??HAL_UART_Init_4
    274            {  
    275              /* Allocate lock resource and initialize it */
    276              huart->Lock = HAL_UNLOCKED;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF884 0x0038      STRB     R0,[R4, #+56]
    277              
    278              /* Init the low level hardware */
    279              HAL_UART_MspInit(huart);
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       HAL_UART_MspInit
    280            }
    281          
    282            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_Init_4: (+1)
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0xF884 0x0039      STRB     R0,[R4, #+57]
    283          
    284            /* Disable the peripheral */
    285            __HAL_UART_DISABLE(huart);
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x68C0             LDR      R0,[R0, #+12]
   \   00000030   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0x60C8             STR      R0,[R1, #+12]
    286            
    287            /* Set the UART Communication parameters */
    288            UART_SetConfig(huart);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       UART_SetConfig
    289            
    290            /* In asynchronous mode, the following bits must be kept cleared: 
    291               - LINEN and CLKEN bits in the USART_CR2 register,
    292               - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
    293            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6900             LDR      R0,[R0, #+16]
   \   00000042   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000046   0x6821             LDR      R1,[R4, #+0]
   \   00000048   0x6108             STR      R0,[R1, #+16]
    294            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6940             LDR      R0,[R0, #+20]
   \   0000004E   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000052   0x6821             LDR      R1,[R4, #+0]
   \   00000054   0x6148             STR      R0,[R1, #+20]
    295            
    296            /* Enable the peripheral */
    297            __HAL_UART_ENABLE(huart);
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x68C0             LDR      R0,[R0, #+12]
   \   0000005A   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000005E   0x6821             LDR      R1,[R4, #+0]
   \   00000060   0x60C8             STR      R0,[R1, #+12]
    298            
    299            /* Initialize the UART state */
    300            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x63E0             STR      R0,[R4, #+60]
    301            huart->State= HAL_UART_STATE_READY;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xF884 0x0039      STRB     R0,[R4, #+57]
    302            
    303            return HAL_OK;
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_Init_1: (+1)
   \   0000006E   0xBD10             POP      {R4,PC}          ;; return
    304          }
    305          
    306          /**
    307            * @brief  Initializes the half-duplex mode according to the specified
    308            *         parameters in the UART_InitTypeDef and create the associated handle.
    309            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    310            *                the configuration information for the specified UART module.
    311            * @retval HAL status
    312            */

   \                                 In section .text, align 2, keep-with-next
    313          HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
    314          {
   \                     HAL_HalfDuplex_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    315            /* Check the UART handle allocation */
    316            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_HalfDuplex_Init_0
    317            {
    318              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE033             B.N      ??HAL_HalfDuplex_Init_1
    319            }
    320            
    321            /* Check UART instance */
    322            assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
    323            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    324            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    325          
    326            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_HalfDuplex_Init_0: (+1)
   \   0000000C   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD105             BNE.N    ??HAL_HalfDuplex_Init_2
    327            {   
    328              /* Allocate lock resource and initialize it */
    329              huart->Lock = HAL_UNLOCKED;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xF884 0x0038      STRB     R0,[R4, #+56]
    330          
    331              /* Init the low level hardware */
    332              HAL_UART_MspInit(huart);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_UART_MspInit
    333            }
    334          
    335            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_HalfDuplex_Init_2: (+1)
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
    336          
    337            /* Disable the peripheral */
    338            __HAL_UART_DISABLE(huart);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x68C0             LDR      R0,[R0, #+12]
   \   0000002A   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x60C8             STR      R0,[R1, #+12]
    339            
    340            /* Set the UART Communication parameters */
    341            UART_SetConfig(huart);
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_SetConfig
    342            
    343            /* In half-duplex mode, the following bits must be kept cleared: 
    344               - LINEN and CLKEN bits in the USART_CR2 register,
    345               - SCEN and IREN bits in the USART_CR3 register.*/
    346            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6900             LDR      R0,[R0, #+16]
   \   0000003C   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6108             STR      R0,[R1, #+16]
    347            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x6940             LDR      R0,[R0, #+20]
   \   00000048   0xF030 0x0022      BICS     R0,R0,#0x22
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x6148             STR      R0,[R1, #+20]
    348            
    349            /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    350            SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6940             LDR      R0,[R0, #+20]
   \   00000054   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x6148             STR      R0,[R1, #+20]
    351           
    352            /* Enable the peripheral */
    353            __HAL_UART_ENABLE(huart);
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x68C0             LDR      R0,[R0, #+12]
   \   00000060   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x60C8             STR      R0,[R1, #+12]
    354            
    355            /* Initialize the UART state*/
    356            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x63E0             STR      R0,[R4, #+60]
    357            huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF884 0x0039      STRB     R0,[R4, #+57]
    358            
    359            return HAL_OK;
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_Init_1: (+1)
   \   00000074   0xBD10             POP      {R4,PC}          ;; return
    360          }
    361          
    362          /**
    363            * @brief  Initializes the LIN mode according to the specified
    364            *         parameters in the UART_InitTypeDef and create the associated handle.
    365            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    366            *                the configuration information for the specified UART module.
    367            * @param  BreakDetectLength: Specifies the LIN break detection length.
    368            *         This parameter can be one of the following values:
    369            *            @arg UART_LINBREAKDETECTLENGTH_10B: 10-bit break detection
    370            *            @arg UART_LINBREAKDETECTLENGTH_11B: 11-bit break detection
    371            * @retval HAL status
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
    374          {
   \                     HAL_LIN_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    375            /* Check the UART handle allocation */
    376            if(huart == NULL)
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??HAL_LIN_Init_0
    377            {
    378              return HAL_ERROR;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE03A             B.N      ??HAL_LIN_Init_1
    379            }
    380            
    381            /* Check the LIN UART instance */  
    382            assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
    383            /* Check the Break detection length parameter */
    384            assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
    385            assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
    386            assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
    387            
    388            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_LIN_Init_0: (+1)
   \   0000000E   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD105             BNE.N    ??HAL_LIN_Init_2
    389            {   
    390              /* Allocate lock resource and initialize it */
    391              huart->Lock = HAL_UNLOCKED;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x0038      STRB     R0,[R4, #+56]
    392          
    393              /* Init the low level hardware */
    394              HAL_UART_MspInit(huart);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       HAL_UART_MspInit
    395            }
    396          
    397            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_LIN_Init_2: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xF884 0x0039      STRB     R0,[R4, #+57]
    398          
    399            /* Disable the peripheral */
    400            __HAL_UART_DISABLE(huart);
   \   00000028   0x6820             LDR      R0,[R4, #+0]
   \   0000002A   0x68C0             LDR      R0,[R0, #+12]
   \   0000002C   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000030   0x6821             LDR      R1,[R4, #+0]
   \   00000032   0x60C8             STR      R0,[R1, #+12]
    401            
    402            /* Set the UART Communication parameters */
    403            UART_SetConfig(huart);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       UART_SetConfig
    404            
    405            /* In LIN mode, the following bits must be kept cleared: 
    406               - CLKEN bits in the USART_CR2 register,
    407               - SCEN and IREN bits in the USART_CR3 register.*/
    408            CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6900             LDR      R0,[R0, #+16]
   \   0000003E   0xF430 0x6000      BICS     R0,R0,#0x800
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0x6108             STR      R0,[R1, #+16]
    409            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x6940             LDR      R0,[R0, #+20]
   \   0000004A   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x6148             STR      R0,[R1, #+20]
    410            
    411            /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    412            SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x6900             LDR      R0,[R0, #+16]
   \   00000056   0xF450 0x4080      ORRS     R0,R0,#0x4000
   \   0000005A   0x6821             LDR      R1,[R4, #+0]
   \   0000005C   0x6108             STR      R0,[R1, #+16]
    413            
    414            /* Set the USART LIN Break detection length. */
    415            MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6900             LDR      R0,[R0, #+16]
   \   00000062   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000066   0x4328             ORRS     R0,R5,R0
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6108             STR      R0,[R1, #+16]
    416            
    417            /* Enable the peripheral */
    418            __HAL_UART_ENABLE(huart);
   \   0000006C   0x6820             LDR      R0,[R4, #+0]
   \   0000006E   0x68C0             LDR      R0,[R0, #+12]
   \   00000070   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x60C8             STR      R0,[R1, #+12]
    419            
    420            /* Initialize the UART state*/
    421            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x63E0             STR      R0,[R4, #+60]
    422            huart->State= HAL_UART_STATE_READY;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF884 0x0039      STRB     R0,[R4, #+57]
    423            
    424            return HAL_OK;
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_Init_1: (+1)
   \   00000084   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    425          }
    426          
    427          /**
    428            * @brief  Initializes the Multi-Processor mode according to the specified
    429            *         parameters in the UART_InitTypeDef and create the associated handle.
    430            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    431            *                the configuration information for the specified UART module.
    432            * @param  Address: UART node address
    433            * @param  WakeUpMethod: specifies the UART wakeup method.
    434            *         This parameter can be one of the following values:
    435            *            @arg UART_WAKEUPMETHOD_IDLELINE: Wakeup by an idle line detection
    436            *            @arg UART_WAKEUPMETHOD_ADDRESSMARK: Wakeup by an address mark
    437            * @retval HAL status
    438            */

   \                                 In section .text, align 2, keep-with-next
    439          HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
    440          {
   \                     HAL_MultiProcessor_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    441            /* Check the UART handle allocation */
    442            if(huart == NULL)
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??HAL_MultiProcessor_Init_0
    443            {
    444              return HAL_ERROR;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE03C             B.N      ??HAL_MultiProcessor_Init_1
    445            }
    446          
    447            /* Check UART instance capabilities */  
    448            assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
    449          
    450            /* Check the Address & wake up method parameters */
    451            assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
    452            assert_param(IS_UART_ADDRESS(Address));
    453            assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
    454            assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
    455          
    456            if(huart->State == HAL_UART_STATE_RESET)
   \                     ??HAL_MultiProcessor_Init_0: (+1)
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??HAL_MultiProcessor_Init_2
    457            {   
    458              /* Allocate lock resource and initialize it */
    459              huart->Lock = HAL_UNLOCKED;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x0038      STRB     R0,[R4, #+56]
    460          
    461              /* Init the low level hardware */
    462              HAL_UART_MspInit(huart);
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       HAL_UART_MspInit
    463            }
    464          
    465            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_MultiProcessor_Init_2: (+1)
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xF884 0x0039      STRB     R0,[R4, #+57]
    466          
    467            /* Disable the peripheral */
    468            __HAL_UART_DISABLE(huart);
   \   0000002A   0x6820             LDR      R0,[R4, #+0]
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   00000032   0x6821             LDR      R1,[R4, #+0]
   \   00000034   0x60C8             STR      R0,[R1, #+12]
    469            
    470            /* Set the UART Communication parameters */
    471            UART_SetConfig(huart);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       UART_SetConfig
    472            
    473            /* In Multi-Processor mode, the following bits must be kept cleared: 
    474               - LINEN and CLKEN bits in the USART_CR2 register,
    475               - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
    476            CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x6900             LDR      R0,[R0, #+16]
   \   00000040   0xF430 0x4090      BICS     R0,R0,#0x4800
   \   00000044   0x6821             LDR      R1,[R4, #+0]
   \   00000046   0x6108             STR      R0,[R1, #+16]
    477            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF030 0x002A      BICS     R0,R0,#0x2A
   \   00000050   0x6821             LDR      R1,[R4, #+0]
   \   00000052   0x6148             STR      R0,[R1, #+20]
    478            
    479            /* Set the USART address node */
    480            MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
   \   00000054   0x6820             LDR      R0,[R4, #+0]
   \   00000056   0x6900             LDR      R0,[R0, #+16]
   \   00000058   0x0900             LSRS     R0,R0,#+4
   \   0000005A   0x0100             LSLS     R0,R0,#+4
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x4328             ORRS     R0,R5,R0
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6108             STR      R0,[R1, #+16]
    481            
    482            /* Set the wake up method by setting the WAKE bit in the CR1 register */
    483            MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF430 0x6000      BICS     R0,R0,#0x800
   \   0000006C   0x4330             ORRS     R0,R6,R0
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x60C8             STR      R0,[R1, #+12]
    484            
    485            /* Enable the peripheral */
    486            __HAL_UART_ENABLE(huart);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF450 0x5000      ORRS     R0,R0,#0x2000
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x60C8             STR      R0,[R1, #+12]
    487            
    488            /* Initialize the UART state */
    489            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x63E0             STR      R0,[R4, #+60]
    490            huart->State= HAL_UART_STATE_READY;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0xF884 0x0039      STRB     R0,[R4, #+57]
    491            
    492            return HAL_OK;
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_Init_1: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    493          }
    494          
    495          /**
    496            * @brief  DeInitializes the UART peripheral. 
    497            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    498            *                the configuration information for the specified UART module.
    499            * @retval HAL status
    500            */

   \                                 In section .text, align 2, keep-with-next
    501          HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
    502          {
   \                     HAL_UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    503            /* Check the UART handle allocation */
    504            if(huart == NULL)
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??HAL_UART_DeInit_0
    505            {
    506              return HAL_ERROR;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE01D             B.N      ??HAL_UART_DeInit_1
    507            }
    508            
    509            /* Check the parameters */
    510            assert_param(IS_UART_INSTANCE(huart->Instance));
    511          
    512            huart->State = HAL_UART_STATE_BUSY;
   \                     ??HAL_UART_DeInit_0: (+1)
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xF884 0x0039      STRB     R0,[R4, #+57]
    513            
    514            /* Disable the Peripheral */
    515            __HAL_UART_DISABLE(huart);
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x68C0             LDR      R0,[R0, #+12]
   \   00000016   0xF430 0x5000      BICS     R0,R0,#0x2000
   \   0000001A   0x6821             LDR      R1,[R4, #+0]
   \   0000001C   0x60C8             STR      R0,[R1, #+12]
    516            
    517            huart->Instance->CR1 = 0x0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x60C8             STR      R0,[R1, #+12]
    518            huart->Instance->CR2 = 0x0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x6108             STR      R0,[R1, #+16]
    519            huart->Instance->CR3 = 0x0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6821             LDR      R1,[R4, #+0]
   \   0000002E   0x6148             STR      R0,[R1, #+20]
    520            
    521            /* DeInit the low level hardware */
    522            HAL_UART_MspDeInit(huart);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       HAL_UART_MspDeInit
    523          
    524            huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x63E0             STR      R0,[R4, #+60]
    525            huart->State = HAL_UART_STATE_RESET;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF884 0x0039      STRB     R0,[R4, #+57]
    526          
    527            /* Process Unlock */
    528            __HAL_UNLOCK(huart);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xF884 0x0038      STRB     R0,[R4, #+56]
    529          
    530            return HAL_OK;
   \   00000046   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DeInit_1: (+1)
   \   00000048   0xBD10             POP      {R4,PC}          ;; return
    531          }
    532          
    533          /**
    534            * @brief  UART MSP Init.
    535            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    536            *                the configuration information for the specified UART module.
    537            * @retval None
    538            */

   \                                 In section .text, align 2
    539           __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
    540          {
    541            /* Prevent unused argument(s) compilation warning */
    542            UNUSED(huart);
    543            /* NOTE: This function should not be modified, when the callback is needed,
    544                     the HAL_UART_MspInit can be implemented in the user file
    545             */ 
    546          }
   \                     HAL_UART_MspInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    547          
    548          /**
    549            * @brief  UART MSP DeInit.
    550            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    551            *                the configuration information for the specified UART module.
    552            * @retval None
    553            */

   \                                 In section .text, align 2
    554           __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
    555          {
    556            /* Prevent unused argument(s) compilation warning */
    557            UNUSED(huart);
    558            /* NOTE: This function should not be modified, when the callback is needed,
    559                     the HAL_UART_MspDeInit can be implemented in the user file
    560             */ 
    561          }
   \                     HAL_UART_MspDeInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    562          
    563          /**
    564            * @}
    565            */
    566          
    567          /** @defgroup UART_Exported_Functions_Group2 IO operation functions 
    568            *  @brief UART Transmit and Receive functions 
    569            *
    570          @verbatim
    571            ==============================================================================
    572                                ##### IO operation functions #####
    573            ==============================================================================  
    574            [..]
    575              This subsection provides a set of functions allowing to manage the UART asynchronous
    576              and Half duplex data transfers.
    577          
    578              (#) There are two modes of transfer:
    579                 (++) Blocking mode: The communication is performed in polling mode. 
    580                      The HAL status of all data processing is returned by the same function 
    581                      after finishing transfer.  
    582                 (++) Non blocking mode: The communication is performed using Interrupts 
    583                      or DMA, these APIs return the HAL status.
    584                      The end of the data processing will be indicated through the 
    585                      dedicated UART IRQ when using Interrupt mode or the DMA IRQ when 
    586                      using DMA mode.
    587                      The HAL_UART_TxCpltCallback(), HAL_UART_RxCpltCallback() user callbacks 
    588                      will be executed respectively at the end of the transmit or receive process.
    589                      The HAL_UART_ErrorCallback() user callback will be executed when 
    590                      a communication error is detected.
    591          
    592              (#) Blocking mode APIs are:
    593                  (++) HAL_UART_Transmit()
    594                  (++) HAL_UART_Receive() 
    595          
    596              (#) Non Blocking mode APIs with Interrupt are:
    597                  (++) HAL_UART_Transmit_IT()
    598                  (++) HAL_UART_Receive_IT()
    599                  (++) HAL_UART_IRQHandler()
    600          
    601              (#) Non Blocking mode functions with DMA are:
    602                  (++) HAL_UART_Transmit_DMA()
    603                  (++) HAL_UART_Receive_DMA()
    604                  (++) HAL_UART_DMAPause()
    605                  (++) HAL_UART_DMAResume()
    606                  (++) HAL_UART_DMAStop()
    607          
    608              (#) A set of Transfer Complete Callbacks are provided in non blocking mode:
    609                  (++) HAL_UART_TxHalfCpltCallback()
    610                  (++) HAL_UART_TxCpltCallback()
    611                  (++) HAL_UART_RxHalfCpltCallback()
    612                  (++) HAL_UART_RxCpltCallback()
    613                  (++) HAL_UART_ErrorCallback()
    614          
    615              [..] 
    616                (@) In the Half duplex communication, it is forbidden to run the transmit 
    617                    and receive process in parallel, the UART state HAL_UART_STATE_BUSY_TX_RX 
    618                    can't be useful.
    619                
    620          @endverbatim
    621            * @{
    622            */
    623          
    624          /**
    625            * @brief  Sends an amount of data in blocking mode. 
    626            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    627            *                the configuration information for the specified UART module.
    628            * @param  pData: Pointer to data buffer
    629            * @param  Size: Amount of data to be sent
    630            * @param  Timeout: Timeout duration  
    631            * @retval HAL status
    632            */

   \                                 In section .text, align 2, keep-with-next
    633          HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    634          {
   \                     HAL_UART_Transmit: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001F             MOVS     R7,R3
    635            uint16_t* tmp;
    636            uint32_t tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    637            
    638            tmp_state = huart->State;
   \   00000010   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   00000014   0x4681             MOV      R9,R0
    639            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_0
   \   0000001C   0xF1B9 0x0F22      CMP      R9,#+34
   \   00000020   0xD169             BNE.N    ??HAL_UART_Transmit_1
    640            {
    641              if((pData == NULL) || (Size == 0))
   \                     ??HAL_UART_Transmit_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Transmit_2
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Transmit_3
    642              {
    643                return  HAL_ERROR;
   \                     ??HAL_UART_Transmit_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE063             B.N      ??HAL_UART_Transmit_4
    644              }
    645          
    646              /* Process Locked */
    647              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_3: (+1)
   \   00000030   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Transmit_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE05D             B.N      ??HAL_UART_Transmit_4
   \                     ??HAL_UART_Transmit_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF886 0x0038      STRB     R0,[R6, #+56]
    648          
    649              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63F0             STR      R0,[R6, #+60]
    650              /* Check if a non-blocking receive process is ongoing or not */
    651              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   00000046   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   0000004A   0x2822             CMP      R0,#+34
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Transmit_6
    652              {
    653                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF886 0x0039      STRB     R0,[R6, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Transmit_7
    654              }
    655              else
    656              {
    657                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_6: (+1)
   \   00000056   0x2012             MOVS     R0,#+18
   \   00000058   0xF886 0x0039      STRB     R0,[R6, #+57]
    658              }
    659          
    660              huart->TxXferSize = Size;
   \                     ??HAL_UART_Transmit_7: (+1)
   \   0000005C   0x84B5             STRH     R5,[R6, #+36]
    661              huart->TxXferCount = Size;
   \   0000005E   0x84F5             STRH     R5,[R6, #+38]
    662              while(huart->TxXferCount > 0)
   \                     ??HAL_UART_Transmit_8: (+1)
   \   00000060   0x8CF0             LDRH     R0,[R6, #+38]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD02D             BEQ.N    ??HAL_UART_Transmit_9
    663              {
    664                huart->TxXferCount--;
   \   00000066   0x8CF0             LDRH     R0,[R6, #+38]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x84F0             STRH     R0,[R6, #+38]
    665                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68B0             LDR      R0,[R6, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD117             BNE.N    ??HAL_UART_Transmit_10
    666                {
    667                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2180             MOVS     R1,#+128
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Transmit_11
    668                  {
    669                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE037             B.N      ??HAL_UART_Transmit_4
    670                  }
    671                  tmp = (uint16_t*) pData;
   \                     ??HAL_UART_Transmit_11: (+1)
   \   00000088   0x46A0             MOV      R8,R4
    672                  huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
   \   0000008A   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   0000008E   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000090   0x0DC0             LSRS     R0,R0,#+23
   \   00000092   0x6831             LDR      R1,[R6, #+0]
   \   00000094   0x6048             STR      R0,[R1, #+4]
    673                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000096   0x6930             LDR      R0,[R6, #+16]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD101             BNE.N    ??HAL_UART_Transmit_12
    674                  {
    675                    pData +=2;
   \   0000009C   0x1CA4             ADDS     R4,R4,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Transmit_8
    676                  }
    677                  else
    678                  { 
    679                    pData +=1;
   \                     ??HAL_UART_Transmit_12: (+1)
   \   000000A0   0x1C64             ADDS     R4,R4,#+1
   \   000000A2   0xE7DD             B.N      ??HAL_UART_Transmit_8
    680                  }
    681                } 
    682                else
    683                {
    684                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_10: (+1)
   \   000000A4   0x003B             MOVS     R3,R7
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x2180             MOVS     R1,#+128
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD001             BEQ.N    ??HAL_UART_Transmit_13
    685                  {
    686                    return HAL_TIMEOUT;
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE01F             B.N      ??HAL_UART_Transmit_4
    687                  }
    688                  huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
   \                     ??HAL_UART_Transmit_13: (+1)
   \   000000B8   0x7820             LDRB     R0,[R4, #+0]
   \   000000BA   0x6831             LDR      R1,[R6, #+0]
   \   000000BC   0x6048             STR      R0,[R1, #+4]
   \   000000BE   0x1C64             ADDS     R4,R4,#+1
   \   000000C0   0xE7CE             B.N      ??HAL_UART_Transmit_8
    689                }
    690              }
    691          
    692              if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Transmit_9: (+1)
   \   000000C2   0x003B             MOVS     R3,R7
   \   000000C4   0x2200             MOVS     R2,#+0
   \   000000C6   0x2140             MOVS     R1,#+64
   \   000000C8   0x0030             MOVS     R0,R6
   \   000000CA   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD001             BEQ.N    ??HAL_UART_Transmit_14
    693              { 
    694                return HAL_TIMEOUT;
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xE010             B.N      ??HAL_UART_Transmit_4
    695              }
    696          
    697              /* Check if a non-blocking receive process is ongoing or not */
    698              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Transmit_14: (+1)
   \   000000D6   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   000000DA   0x2832             CMP      R0,#+50
   \   000000DC   0xD103             BNE.N    ??HAL_UART_Transmit_15
    699              {
    700                huart->State = HAL_UART_STATE_BUSY_RX;
   \   000000DE   0x2022             MOVS     R0,#+34
   \   000000E0   0xF886 0x0039      STRB     R0,[R6, #+57]
   \   000000E4   0xE002             B.N      ??HAL_UART_Transmit_16
    701              }
    702              else
    703              {
    704                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Transmit_15: (+1)
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xF886 0x0039      STRB     R0,[R6, #+57]
    705              }
    706          
    707              /* Process Unlocked */
    708              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_16: (+1)
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xF886 0x0038      STRB     R0,[R6, #+56]
    709          
    710              return HAL_OK;
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE000             B.N      ??HAL_UART_Transmit_4
    711            }
    712            else
    713            {
    714              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_1: (+1)
   \   000000F6   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_4: (+1)
   \   000000F8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    715            }
    716          }
    717          
    718          /**
    719            * @brief  Receives an amount of data in blocking mode. 
    720            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    721            *                the configuration information for the specified UART module.
    722            * @param  pData: Pointer to data buffer
    723            * @param  Size: Amount of data to be received
    724            * @param  Timeout: Timeout duration
    725            * @retval HAL status
    726            */

   \                                 In section .text, align 2, keep-with-next
    727          HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
    728          {
   \                     HAL_UART_Receive: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001F             MOVS     R7,R3
    729            uint16_t* tmp;
    730            uint32_t  tmp_state = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    731          
    732            tmp_state = huart->State;
   \   00000010   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   00000014   0x4681             MOV      R9,R0
    733            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   00000016   0xF1B9 0x0F01      CMP      R9,#+1
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_0
   \   0000001C   0xF1B9 0x0F12      CMP      R9,#+18
   \   00000020   0xD16F             BNE.N    ??HAL_UART_Receive_1
    734            {
    735              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD002             BEQ.N    ??HAL_UART_Receive_2
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD101             BNE.N    ??HAL_UART_Receive_3
    736              {
    737                return  HAL_ERROR;
   \                     ??HAL_UART_Receive_2: (+1)
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE069             B.N      ??HAL_UART_Receive_4
    738              }
    739          
    740              /* Process Locked */
    741              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_3: (+1)
   \   00000030   0xF896 0x0038      LDRB     R0,[R6, #+56]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD101             BNE.N    ??HAL_UART_Receive_5
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0xE063             B.N      ??HAL_UART_Receive_4
   \                     ??HAL_UART_Receive_5: (+1)
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xF886 0x0038      STRB     R0,[R6, #+56]
    742          
    743              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x63F0             STR      R0,[R6, #+60]
    744              /* Check if a non-blocking transmit process is ongoing or not */
    745              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000046   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   0000004A   0x2812             CMP      R0,#+18
   \   0000004C   0xD103             BNE.N    ??HAL_UART_Receive_6
    746              {
    747                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004E   0x2032             MOVS     R0,#+50
   \   00000050   0xF886 0x0039      STRB     R0,[R6, #+57]
   \   00000054   0xE002             B.N      ??HAL_UART_Receive_7
    748              }
    749              else
    750              {
    751                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_6: (+1)
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0xF886 0x0039      STRB     R0,[R6, #+57]
    752              }
    753          
    754              huart->RxXferSize = Size;
   \                     ??HAL_UART_Receive_7: (+1)
   \   0000005C   0x85B5             STRH     R5,[R6, #+44]
    755              huart->RxXferCount = Size;
   \   0000005E   0x85F5             STRH     R5,[R6, #+46]
    756          
    757              /* Check the remain data to be received */
    758              while(huart->RxXferCount > 0)
   \                     ??HAL_UART_Receive_8: (+1)
   \   00000060   0x8DF0             LDRH     R0,[R6, #+46]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD03D             BEQ.N    ??HAL_UART_Receive_9
    759              {
    760                huart->RxXferCount--;
   \   00000066   0x8DF0             LDRH     R0,[R6, #+46]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x85F0             STRH     R0,[R6, #+46]
    761                if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \   0000006C   0x68B0             LDR      R0,[R6, #+8]
   \   0000006E   0xF5B0 0x5F80      CMP      R0,#+4096
   \   00000072   0xD11D             BNE.N    ??HAL_UART_Receive_10
    762                {
    763                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \   00000074   0x003B             MOVS     R3,R7
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2120             MOVS     R1,#+32
   \   0000007A   0x0030             MOVS     R0,R6
   \   0000007C   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD001             BEQ.N    ??HAL_UART_Receive_11
    764                  {
    765                    return HAL_TIMEOUT;
   \   00000084   0x2003             MOVS     R0,#+3
   \   00000086   0xE03D             B.N      ??HAL_UART_Receive_4
    766                  }
    767                  tmp = (uint16_t*) pData ;
   \                     ??HAL_UART_Receive_11: (+1)
   \   00000088   0x46A0             MOV      R8,R4
    768                  if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000008A   0x6930             LDR      R0,[R6, #+16]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD107             BNE.N    ??HAL_UART_Receive_12
    769                  {
    770                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000090   0x6830             LDR      R0,[R6, #+0]
   \   00000092   0x6840             LDR      R0,[R0, #+4]
   \   00000094   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000096   0x0DC0             LSRS     R0,R0,#+23
   \   00000098   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    771                    pData +=2;
   \   0000009C   0x1CA4             ADDS     R4,R4,#+2
   \   0000009E   0xE7DF             B.N      ??HAL_UART_Receive_8
    772                  }
    773                  else
    774                  {
    775                    *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??HAL_UART_Receive_12: (+1)
   \   000000A0   0x6830             LDR      R0,[R6, #+0]
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   000000A8   0xF8A8 0x0000      STRH     R0,[R8, #+0]
    776                    pData +=1;
   \   000000AC   0x1C64             ADDS     R4,R4,#+1
   \   000000AE   0xE7D7             B.N      ??HAL_UART_Receive_8
    777                  }
    778          
    779                }
    780                else
    781                {
    782                  if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
   \                     ??HAL_UART_Receive_10: (+1)
   \   000000B0   0x003B             MOVS     R3,R7
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2120             MOVS     R1,#+32
   \   000000B6   0x0030             MOVS     R0,R6
   \   000000B8   0x.... 0x....      BL       UART_WaitOnFlagUntilTimeout
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD001             BEQ.N    ??HAL_UART_Receive_13
    783                  {
    784                    return HAL_TIMEOUT;
   \   000000C0   0x2003             MOVS     R0,#+3
   \   000000C2   0xE01F             B.N      ??HAL_UART_Receive_4
    785                  }
    786                  if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??HAL_UART_Receive_13: (+1)
   \   000000C4   0x6930             LDR      R0,[R6, #+16]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD104             BNE.N    ??HAL_UART_Receive_14
    787                  {
    788                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   000000CA   0x6830             LDR      R0,[R6, #+0]
   \   000000CC   0x6840             LDR      R0,[R0, #+4]
   \   000000CE   0x7020             STRB     R0,[R4, #+0]
   \   000000D0   0x1C64             ADDS     R4,R4,#+1
   \   000000D2   0xE7C5             B.N      ??HAL_UART_Receive_8
    789                  }
    790                  else
    791                  {
    792                    *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??HAL_UART_Receive_14: (+1)
   \   000000D4   0x6830             LDR      R0,[R6, #+0]
   \   000000D6   0x6840             LDR      R0,[R0, #+4]
   \   000000D8   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000DC   0x7020             STRB     R0,[R4, #+0]
   \   000000DE   0x1C64             ADDS     R4,R4,#+1
   \   000000E0   0xE7BE             B.N      ??HAL_UART_Receive_8
    793                  }
    794          
    795                }
    796              }
    797          
    798              /* Check if a non-blocking transmit process is ongoing or not */
    799              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \                     ??HAL_UART_Receive_9: (+1)
   \   000000E2   0xF896 0x0039      LDRB     R0,[R6, #+57]
   \   000000E6   0x2832             CMP      R0,#+50
   \   000000E8   0xD103             BNE.N    ??HAL_UART_Receive_15
    800              {
    801                huart->State = HAL_UART_STATE_BUSY_TX;
   \   000000EA   0x2012             MOVS     R0,#+18
   \   000000EC   0xF886 0x0039      STRB     R0,[R6, #+57]
   \   000000F0   0xE002             B.N      ??HAL_UART_Receive_16
    802              }
    803              else
    804              {
    805                huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_Receive_15: (+1)
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xF886 0x0039      STRB     R0,[R6, #+57]
    806              }
    807              /* Process Unlocked */
    808              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_16: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0xF886 0x0038      STRB     R0,[R6, #+56]
    809          
    810              return HAL_OK;
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0xE000             B.N      ??HAL_UART_Receive_4
    811            }
    812            else
    813            {
    814              return HAL_BUSY;
   \                     ??HAL_UART_Receive_1: (+1)
   \   00000102   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_4: (+1)
   \   00000104   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    815            }
    816          }
    817          
    818          /**
    819            * @brief  Sends an amount of data in non blocking mode.
    820            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    821            *                the configuration information for the specified UART module.
    822            * @param  pData: Pointer to data buffer
    823            * @param  Size: Amount of data to be sent
    824            * @retval HAL status
    825            */

   \                                 In section .text, align 2, keep-with-next
    826          HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    827          {
   \                     HAL_UART_Transmit_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    828            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    829          
    830            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    831            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Transmit_IT_0
   \   00000010   0x2C22             CMP      R4,#+34
   \   00000012   0xD12A             BNE.N    ??HAL_UART_Transmit_IT_1
    832            {
    833              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Transmit_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Transmit_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Transmit_IT_3
    834              {
    835                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE024             B.N      ??HAL_UART_Transmit_IT_4
    836              }
    837              
    838              /* Process Locked */
    839              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Transmit_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE01E             B.N      ??HAL_UART_Transmit_IT_4
   \                     ??HAL_UART_Transmit_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    840              
    841              huart->pTxBuffPtr = pData;
   \   00000034   0x6219             STR      R1,[R3, #+32]
    842              huart->TxXferSize = Size;
   \   00000036   0x849A             STRH     R2,[R3, #+36]
    843              huart->TxXferCount = Size;
   \   00000038   0x84DA             STRH     R2,[R3, #+38]
    844          
    845              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    846              /* Check if a receive process is ongoing or not */
    847              if(huart->State == HAL_UART_STATE_BUSY_RX) 
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2822             CMP      R0,#+34
   \   00000044   0xD103             BNE.N    ??HAL_UART_Transmit_IT_6
    848              {
    849                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Transmit_IT_7
    850              }
    851              else
    852              {
    853                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_IT_6: (+1)
   \   0000004E   0x2012             MOVS     R0,#+18
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    854              }
    855          
    856              /* Process Unlocked */
    857              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Transmit_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    858          
    859              /* Enable the UART Transmit data register empty Interrupt */
    860              __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x60E8             STR      R0,[R5, #+12]
    861              
    862              return HAL_OK;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE000             B.N      ??HAL_UART_Transmit_IT_4
    863            }
    864            else
    865            {
    866              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_IT_1: (+1)
   \   0000006A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_IT_4: (+1)
   \   0000006C   0xBC30             POP      {R4,R5}
   \   0000006E   0x4770             BX       LR               ;; return
    867            }
    868          }
    869          
    870          /**
    871            * @brief  Receives an amount of data in non blocking mode 
    872            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    873            *                the configuration information for the specified UART module.
    874            * @param  pData: Pointer to data buffer
    875            * @param  Size: Amount of data to be received
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    879          {
   \                     HAL_UART_Receive_IT: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
    880            uint32_t tmp_state = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    881            
    882            tmp_state = huart->State;
   \   00000006   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   0000000A   0x0004             MOVS     R4,R0
    883            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD001             BEQ.N    ??HAL_UART_Receive_IT_0
   \   00000010   0x2C12             CMP      R4,#+18
   \   00000012   0xD136             BNE.N    ??HAL_UART_Receive_IT_1
    884            {
    885              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_IT_0: (+1)
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD002             BEQ.N    ??HAL_UART_Receive_IT_2
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD101             BNE.N    ??HAL_UART_Receive_IT_3
    886              {
    887                return HAL_ERROR;
   \                     ??HAL_UART_Receive_IT_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE030             B.N      ??HAL_UART_Receive_IT_4
    888              }
    889          
    890              /* Process Locked */
    891              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_IT_3: (+1)
   \   00000022   0xF893 0x0038      LDRB     R0,[R3, #+56]
   \   00000026   0x2801             CMP      R0,#+1
   \   00000028   0xD101             BNE.N    ??HAL_UART_Receive_IT_5
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0xE02A             B.N      ??HAL_UART_Receive_IT_4
   \                     ??HAL_UART_Receive_IT_5: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF883 0x0038      STRB     R0,[R3, #+56]
    892          
    893              huart->pRxBuffPtr = pData;
   \   00000034   0x6299             STR      R1,[R3, #+40]
    894              huart->RxXferSize = Size;
   \   00000036   0x859A             STRH     R2,[R3, #+44]
    895              huart->RxXferCount = Size;
   \   00000038   0x85DA             STRH     R2,[R3, #+46]
    896          
    897              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x63D8             STR      R0,[R3, #+60]
    898              /* Check if a transmit process is ongoing or not */
    899              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   0000003E   0xF893 0x0039      LDRB     R0,[R3, #+57]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xD103             BNE.N    ??HAL_UART_Receive_IT_6
    900              {
    901                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   00000046   0x2032             MOVS     R0,#+50
   \   00000048   0xF883 0x0039      STRB     R0,[R3, #+57]
   \   0000004C   0xE002             B.N      ??HAL_UART_Receive_IT_7
    902              }
    903              else
    904              {
    905                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_IT_6: (+1)
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xF883 0x0039      STRB     R0,[R3, #+57]
    906              }
    907          
    908              /* Process Unlocked */
    909              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_Receive_IT_7: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xF883 0x0038      STRB     R0,[R3, #+56]
    910          
    911              /* Enable the UART Parity Error Interrupt */
    912              __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
   \   0000005A   0x6818             LDR      R0,[R3, #+0]
   \   0000005C   0x68C0             LDR      R0,[R0, #+12]
   \   0000005E   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000062   0x681D             LDR      R5,[R3, #+0]
   \   00000064   0x60E8             STR      R0,[R5, #+12]
    913          
    914              /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    915              __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
   \   00000066   0x6818             LDR      R0,[R3, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000006E   0x681D             LDR      R5,[R3, #+0]
   \   00000070   0x6168             STR      R0,[R5, #+20]
    916          
    917              /* Enable the UART Data Register not empty Interrupt */
    918              __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
   \   00000072   0x6818             LDR      R0,[R3, #+0]
   \   00000074   0x68C0             LDR      R0,[R0, #+12]
   \   00000076   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007A   0x681D             LDR      R5,[R3, #+0]
   \   0000007C   0x60E8             STR      R0,[R5, #+12]
    919          
    920              return HAL_OK;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xE000             B.N      ??HAL_UART_Receive_IT_4
    921            }
    922            else
    923            {
    924              return HAL_BUSY;
   \                     ??HAL_UART_Receive_IT_1: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_IT_4: (+1)
   \   00000084   0xBC30             POP      {R4,R5}
   \   00000086   0x4770             BX       LR               ;; return
    925            }
    926          }
    927          
    928          /**
    929            * @brief  Sends an amount of data in non blocking mode. 
    930            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
    931            *                the configuration information for the specified UART module.
    932            * @param  pData: Pointer to data buffer
    933            * @param  Size: Amount of data to be sent
    934            * @retval HAL status
    935            */

   \                                 In section .text, align 2, keep-with-next
    936          HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
    937          {
   \                     HAL_UART_Transmit_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0014             MOVS     R4,R2
    938            uint32_t *tmp;
    939            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    940          
    941            tmp_state = huart->State;
   \   00000008   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
    942            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Transmit_DMA_0
   \   00000012   0x2F22             CMP      R7,#+34
   \   00000014   0xD146             BNE.N    ??HAL_UART_Transmit_DMA_1
    943            {
    944              if((pData == NULL ) || (Size == 0)) 
   \                     ??HAL_UART_Transmit_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Transmit_DMA_2
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_3
    945              {
    946                return HAL_ERROR;
   \                     ??HAL_UART_Transmit_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03F             B.N      ??HAL_UART_Transmit_DMA_4
    947              }
    948          
    949              /* Process Locked */
    950              __HAL_LOCK(huart);
   \                     ??HAL_UART_Transmit_DMA_3: (+1)
   \   00000026   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Transmit_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE039             B.N      ??HAL_UART_Transmit_DMA_4
   \                     ??HAL_UART_Transmit_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF885 0x0038      STRB     R0,[R5, #+56]
    951          
    952              huart->pTxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6228             STR      R0,[R5, #+32]
    953              huart->TxXferSize = Size;
   \   0000003C   0x84AC             STRH     R4,[R5, #+36]
    954              huart->TxXferCount = Size;
   \   0000003E   0x84EC             STRH     R4,[R5, #+38]
    955          
    956              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x63E8             STR      R0,[R5, #+60]
    957              /* Check if a receive process is ongoing or not */
    958              if(huart->State == HAL_UART_STATE_BUSY_RX)
   \   00000044   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000048   0x2822             CMP      R0,#+34
   \   0000004A   0xD103             BNE.N    ??HAL_UART_Transmit_DMA_6
    959              {
    960                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004C   0x2032             MOVS     R0,#+50
   \   0000004E   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000052   0xE002             B.N      ??HAL_UART_Transmit_DMA_7
    961              }
    962              else
    963              {
    964                huart->State = HAL_UART_STATE_BUSY_TX;
   \                     ??HAL_UART_Transmit_DMA_6: (+1)
   \   00000054   0x2012             MOVS     R0,#+18
   \   00000056   0xF885 0x0039      STRB     R0,[R5, #+57]
    965              }
    966          
    967              /* Set the UART DMA transfer complete callback */
    968              huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
   \                     ??HAL_UART_Transmit_DMA_7: (+1)
   \   0000005A   0x.... 0x....      ADR.W    R0,UART_DMATransmitCplt
   \   0000005E   0x6B29             LDR      R1,[R5, #+48]
   \   00000060   0x6288             STR      R0,[R1, #+40]
    969          
    970              /* Set the UART DMA Half transfer complete callback */
    971              huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
   \   00000062   0x.... 0x....      ADR.W    R0,UART_DMATxHalfCplt
   \   00000066   0x6B29             LDR      R1,[R5, #+48]
   \   00000068   0x62C8             STR      R0,[R1, #+44]
    972          
    973              /* Set the DMA error callback */
    974              huart->hdmatx->XferErrorCallback = UART_DMAError;
   \   0000006A   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006E   0x6B29             LDR      R1,[R5, #+48]
   \   00000070   0x6308             STR      R0,[R1, #+48]
    975          
    976              /* Enable the UART transmit DMA channel */
    977              tmp = (uint32_t*)&pData;
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x0006             MOVS     R6,R0
    978              HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
   \   00000076   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000078   0x0023             MOVS     R3,R4
   \   0000007A   0x6828             LDR      R0,[R5, #+0]
   \   0000007C   0x1D02             ADDS     R2,R0,#+4
   \   0000007E   0x6831             LDR      R1,[R6, #+0]
   \   00000080   0x6B28             LDR      R0,[R5, #+48]
   \   00000082   0x.... 0x....      BL       HAL_DMA_Start_IT
    979          
    980              /* Clear the TC flag in the SR register by writing 0 to it */
    981              __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
   \   00000086   0xF07F 0x0040      MVNS     R0,#+64
   \   0000008A   0x6829             LDR      R1,[R5, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    982          
    983              /* Enable the DMA transfer for transmit request by setting the DMAT bit
    984                 in the UART CR3 register */
    985              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000008E   0x6828             LDR      R0,[R5, #+0]
   \   00000090   0x6940             LDR      R0,[R0, #+20]
   \   00000092   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000096   0x6829             LDR      R1,[R5, #+0]
   \   00000098   0x6148             STR      R0,[R1, #+20]
    986          
    987              /* Process Unlocked */
    988              __HAL_UNLOCK(huart);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0xF885 0x0038      STRB     R0,[R5, #+56]
    989          
    990              return HAL_OK;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE000             B.N      ??HAL_UART_Transmit_DMA_4
    991            }
    992            else
    993            {
    994              return HAL_BUSY;
   \                     ??HAL_UART_Transmit_DMA_1: (+1)
   \   000000A4   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Transmit_DMA_4: (+1)
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    995            }
    996          }
    997          
    998          /**
    999            * @brief  Receives an amount of data in non blocking mode. 
   1000            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1001            *                the configuration information for the specified UART module.
   1002            * @param  pData: Pointer to data buffer
   1003            * @param  Size: Amount of data to be received
   1004            * @note   When the UART parity is enabled (PCE = 1), the received data contain 
   1005            *         the parity bit (MSB position)     
   1006            * @retval HAL status
   1007            */

   \                                 In section .text, align 2, keep-with-next
   1008          HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
   1009          {
   \                     HAL_UART_Receive_DMA: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0014             MOVS     R4,R2
   1010            uint32_t *tmp;
   1011            uint32_t tmp_state = 0;
   \   00000006   0x2700             MOVS     R7,#+0
   1012          
   1013            tmp_state = huart->State;
   \   00000008   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   0000000C   0x0007             MOVS     R7,R0
   1014            if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
   \   0000000E   0x2F01             CMP      R7,#+1
   \   00000010   0xD001             BEQ.N    ??HAL_UART_Receive_DMA_0
   \   00000012   0x2F12             CMP      R7,#+18
   \   00000014   0xD141             BNE.N    ??HAL_UART_Receive_DMA_1
   1015            {
   1016              if((pData == NULL ) || (Size == 0))
   \                     ??HAL_UART_Receive_DMA_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??HAL_UART_Receive_DMA_2
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD101             BNE.N    ??HAL_UART_Receive_DMA_3
   1017              {
   1018                return HAL_ERROR;
   \                     ??HAL_UART_Receive_DMA_2: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE03A             B.N      ??HAL_UART_Receive_DMA_4
   1019              }
   1020          
   1021              /* Process Locked */
   1022              __HAL_LOCK(huart);
   \                     ??HAL_UART_Receive_DMA_3: (+1)
   \   00000026   0xF895 0x0038      LDRB     R0,[R5, #+56]
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD101             BNE.N    ??HAL_UART_Receive_DMA_5
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE034             B.N      ??HAL_UART_Receive_DMA_4
   \                     ??HAL_UART_Receive_DMA_5: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF885 0x0038      STRB     R0,[R5, #+56]
   1023          
   1024              huart->pRxBuffPtr = pData;
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x62A8             STR      R0,[R5, #+40]
   1025              huart->RxXferSize = Size;
   \   0000003C   0x85AC             STRH     R4,[R5, #+44]
   1026          
   1027              huart->ErrorCode = HAL_UART_ERROR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x63E8             STR      R0,[R5, #+60]
   1028              /* Check if a transmit process is ongoing or not */
   1029              if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000042   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000046   0x2812             CMP      R0,#+18
   \   00000048   0xD103             BNE.N    ??HAL_UART_Receive_DMA_6
   1030              {
   1031                huart->State = HAL_UART_STATE_BUSY_TX_RX;
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   00000050   0xE002             B.N      ??HAL_UART_Receive_DMA_7
   1032              }
   1033              else
   1034              {
   1035                huart->State = HAL_UART_STATE_BUSY_RX;
   \                     ??HAL_UART_Receive_DMA_6: (+1)
   \   00000052   0x2022             MOVS     R0,#+34
   \   00000054   0xF885 0x0039      STRB     R0,[R5, #+57]
   1036              }
   1037          
   1038              /* Set the UART DMA transfer complete callback */
   1039              huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
   \                     ??HAL_UART_Receive_DMA_7: (+1)
   \   00000058   0x.... 0x....      ADR.W    R0,UART_DMAReceiveCplt
   \   0000005C   0x6B69             LDR      R1,[R5, #+52]
   \   0000005E   0x6288             STR      R0,[R1, #+40]
   1040          
   1041              /* Set the UART DMA Half transfer complete callback */
   1042              huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
   \   00000060   0x.... 0x....      ADR.W    R0,UART_DMARxHalfCplt
   \   00000064   0x6B69             LDR      R1,[R5, #+52]
   \   00000066   0x62C8             STR      R0,[R1, #+44]
   1043          
   1044              /* Set the DMA error callback */
   1045              huart->hdmarx->XferErrorCallback = UART_DMAError;
   \   00000068   0x.... 0x....      ADR.W    R0,UART_DMAError
   \   0000006C   0x6B69             LDR      R1,[R5, #+52]
   \   0000006E   0x6308             STR      R0,[R1, #+48]
   1046          
   1047              /* Enable the DMA channel */
   1048              tmp = (uint32_t*)&pData;
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x0006             MOVS     R6,R0
   1049              HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
   \   00000074   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000076   0x0023             MOVS     R3,R4
   \   00000078   0x6832             LDR      R2,[R6, #+0]
   \   0000007A   0x6828             LDR      R0,[R5, #+0]
   \   0000007C   0x1D01             ADDS     R1,R0,#+4
   \   0000007E   0x6B68             LDR      R0,[R5, #+52]
   \   00000080   0x.... 0x....      BL       HAL_DMA_Start_IT
   1050          
   1051              /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
   1052                 in the UART CR3 register */
   1053              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x6940             LDR      R0,[R0, #+20]
   \   00000088   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000008C   0x6829             LDR      R1,[R5, #+0]
   \   0000008E   0x6148             STR      R0,[R1, #+20]
   1054          
   1055              /* Process Unlocked */
   1056              __HAL_UNLOCK(huart);
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0xF885 0x0038      STRB     R0,[R5, #+56]
   1057          
   1058              return HAL_OK;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE000             B.N      ??HAL_UART_Receive_DMA_4
   1059            }
   1060            else
   1061            {
   1062              return HAL_BUSY;
   \                     ??HAL_UART_Receive_DMA_1: (+1)
   \   0000009A   0x2002             MOVS     R0,#+2
   \                     ??HAL_UART_Receive_DMA_4: (+1)
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1063            }
   1064          }
   1065              
   1066          /**
   1067            * @brief Pauses the DMA Transfer.
   1068            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1069            *                the configuration information for the specified UART module.
   1070            * @retval HAL status
   1071            */

   \                                 In section .text, align 2, keep-with-next
   1072          HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
   1073          {
   \                     HAL_UART_DMAPause: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1074            /* Process Locked */
   1075            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_UART_DMAPause_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE02C             B.N      ??HAL_UART_DMAPause_1
   \                     ??HAL_UART_DMAPause_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1076            
   1077            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000014   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000018   0x2812             CMP      R0,#+18
   \   0000001A   0xD106             BNE.N    ??HAL_UART_DMAPause_2
   1078            {
   1079              /* Disable the UART DMA Tx request */
   1080              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001C   0x6808             LDR      R0,[R1, #+0]
   \   0000001E   0x6940             LDR      R0,[R0, #+20]
   \   00000020   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000024   0x680A             LDR      R2,[R1, #+0]
   \   00000026   0x6150             STR      R0,[R2, #+20]
   \   00000028   0xE01A             B.N      ??HAL_UART_DMAPause_3
   1081            }
   1082            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAPause_2: (+1)
   \   0000002A   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000002E   0x2822             CMP      R0,#+34
   \   00000030   0xD106             BNE.N    ??HAL_UART_DMAPause_4
   1083            {
   1084              /* Disable the UART DMA Rx request */
   1085              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000032   0x6808             LDR      R0,[R1, #+0]
   \   00000034   0x6940             LDR      R0,[R0, #+20]
   \   00000036   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x6150             STR      R0,[R2, #+20]
   \   0000003E   0xE00F             B.N      ??HAL_UART_DMAPause_3
   1086            }
   1087            else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAPause_4: (+1)
   \   00000040   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000044   0x2832             CMP      R0,#+50
   \   00000046   0xD106             BNE.N    ??HAL_UART_DMAPause_5
   1088            {
   1089              /* Disable the UART DMA Tx & Rx requests */
   1090              CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000048   0x6808             LDR      R0,[R1, #+0]
   \   0000004A   0x6940             LDR      R0,[R0, #+20]
   \   0000004C   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   00000050   0x680A             LDR      R2,[R1, #+0]
   \   00000052   0x6150             STR      R0,[R2, #+20]
   \   00000054   0xE004             B.N      ??HAL_UART_DMAPause_3
   1091            }
   1092            else
   1093            {
   1094              /* Process Unlocked */
   1095              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_5: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF881 0x0038      STRB     R0,[R1, #+56]
   1096            
   1097              return HAL_ERROR; 
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0xE003             B.N      ??HAL_UART_DMAPause_1
   1098            }
   1099            
   1100            /* Process Unlocked */
   1101            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAPause_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF881 0x0038      STRB     R0,[R1, #+56]
   1102          
   1103            return HAL_OK; 
   \   00000066   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAPause_1: (+1)
   \   00000068   0x4770             BX       LR               ;; return
   1104          }
   1105          
   1106          /**
   1107            * @brief Resumes the DMA Transfer.
   1108            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1109            *                the configuration information for the specified UART module.
   1110            * @retval HAL status
   1111            */

   \                                 In section .text, align 2, keep-with-next
   1112          HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
   1113          {
   \                     HAL_UART_DMAResume: (+1)
   \   00000000   0xB081             SUB      SP,SP,#+4
   \   00000002   0x0001             MOVS     R1,R0
   1114            /* Process Locked */
   1115            __HAL_LOCK(huart);
   \   00000004   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??HAL_UART_DMAResume_0
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0xE03A             B.N      ??HAL_UART_DMAResume_1
   \                     ??HAL_UART_DMAResume_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF881 0x0038      STRB     R0,[R1, #+56]
   1116          
   1117            if(huart->State == HAL_UART_STATE_BUSY_TX)
   \   00000016   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000001A   0x2812             CMP      R0,#+18
   \   0000001C   0xD106             BNE.N    ??HAL_UART_DMAResume_2
   1118            {
   1119              /* Enable the UART DMA Tx request */
   1120              SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   0000001E   0x6808             LDR      R0,[R1, #+0]
   \   00000020   0x6940             LDR      R0,[R0, #+20]
   \   00000022   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x6150             STR      R0,[R2, #+20]
   \   0000002A   0xE028             B.N      ??HAL_UART_DMAResume_3
   1121            }
   1122            else if(huart->State == HAL_UART_STATE_BUSY_RX)
   \                     ??HAL_UART_DMAResume_2: (+1)
   \   0000002C   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000030   0x2822             CMP      R0,#+34
   \   00000032   0xD10D             BNE.N    ??HAL_UART_DMAResume_4
   1123            {
   1124              /* Clear the Overrun flag before resumming the Rx transfer*/
   1125              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000034   0x6808             LDR      R0,[R1, #+0]
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x6808             LDR      R0,[R1, #+0]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   1126              /* Enable the UART DMA Rx request */
   1127              SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000042   0x6808             LDR      R0,[R1, #+0]
   \   00000044   0x6940             LDR      R0,[R0, #+20]
   \   00000046   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000004A   0x680A             LDR      R2,[R1, #+0]
   \   0000004C   0x6150             STR      R0,[R2, #+20]
   \   0000004E   0xE016             B.N      ??HAL_UART_DMAResume_3
   1128            }
   1129            else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
   \                     ??HAL_UART_DMAResume_4: (+1)
   \   00000050   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   00000054   0x2832             CMP      R0,#+50
   \   00000056   0xD10D             BNE.N    ??HAL_UART_DMAResume_5
   1130            {
   1131              /* Clear the Overrun flag before resumming the Rx transfer*/
   1132              __HAL_UART_CLEAR_OREFLAG(huart);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0x6808             LDR      R0,[R1, #+0]
   \   00000060   0x6840             LDR      R0,[R0, #+4]
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   1133              /* Enable the UART DMA Tx & Rx request */
   1134              SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000066   0x6808             LDR      R0,[R1, #+0]
   \   00000068   0x6940             LDR      R0,[R0, #+20]
   \   0000006A   0xF050 0x00C0      ORRS     R0,R0,#0xC0
   \   0000006E   0x680A             LDR      R2,[R1, #+0]
   \   00000070   0x6150             STR      R0,[R2, #+20]
   \   00000072   0xE004             B.N      ??HAL_UART_DMAResume_3
   1135            }
   1136            else
   1137            {
   1138              /* Process Unlocked */
   1139              __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_5: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xF881 0x0038      STRB     R0,[R1, #+56]
   1140          
   1141              return HAL_ERROR; 
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0xE003             B.N      ??HAL_UART_DMAResume_1
   1142            }
   1143          
   1144            /* Process Unlocked */
   1145            __HAL_UNLOCK(huart);
   \                     ??HAL_UART_DMAResume_3: (+1)
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0xF881 0x0038      STRB     R0,[R1, #+56]
   1146          
   1147            return HAL_OK;
   \   00000084   0x2000             MOVS     R0,#+0
   \                     ??HAL_UART_DMAResume_1: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0x4770             BX       LR               ;; return
   1148          }
   1149          
   1150          /**
   1151            * @brief Stops the DMA Transfer.
   1152            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1153            *                the configuration information for the specified UART module.
   1154            * @retval HAL status
   1155            */

   \                                 In section .text, align 2, keep-with-next
   1156          HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
   1157          {
   \                     HAL_UART_DMAStop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1158            /* The Lock is not implemented on this API to allow the user application
   1159               to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
   1160               when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
   1161               and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
   1162               */
   1163            
   1164            /* Disable the UART Tx/Rx DMA requests */
   1165            CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x6940             LDR      R0,[R0, #+20]
   \   00000008   0xF030 0x00C0      BICS     R0,R0,#0xC0
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x6148             STR      R0,[R1, #+20]
   1166            
   1167            /* Abort the UART DMA tx channel */
   1168            if(huart->hdmatx != NULL)
   \   00000010   0x6B20             LDR      R0,[R4, #+48]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??HAL_UART_DMAStop_0
   1169            {
   1170              HAL_DMA_Abort(huart->hdmatx);
   \   00000016   0x6B20             LDR      R0,[R4, #+48]
   \   00000018   0x.... 0x....      BL       HAL_DMA_Abort
   1171            }
   1172            /* Abort the UART DMA rx channel */
   1173            if(huart->hdmarx != NULL)
   \                     ??HAL_UART_DMAStop_0: (+1)
   \   0000001C   0x6B60             LDR      R0,[R4, #+52]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD002             BEQ.N    ??HAL_UART_DMAStop_1
   1174            {
   1175              HAL_DMA_Abort(huart->hdmarx);
   \   00000022   0x6B60             LDR      R0,[R4, #+52]
   \   00000024   0x.... 0x....      BL       HAL_DMA_Abort
   1176            }
   1177            
   1178            huart->State = HAL_UART_STATE_READY;
   \                     ??HAL_UART_DMAStop_1: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0039      STRB     R0,[R4, #+57]
   1179            
   1180            return HAL_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
   1181          }
   1182          
   1183          /**
   1184            * @brief  This function handles UART interrupt request.
   1185            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1186            *                the configuration information for the specified UART module.
   1187            * @retval None
   1188            */

   \                                 In section .text, align 2, keep-with-next
   1189          void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
   1190          {
   \                     HAL_UART_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   1191            uint32_t tmp_flag = 0, tmp_it_source = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   1192          
   1193            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
   \   0000000A   0x6830             LDR      R0,[R6, #+0]
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000012   0x0004             MOVS     R4,R0
   1194            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
   \   00000014   0x6830             LDR      R0,[R6, #+0]
   \   00000016   0x68C0             LDR      R0,[R0, #+12]
   \   00000018   0xF410 0x7080      ANDS     R0,R0,#0x100
   \   0000001C   0x0005             MOVS     R5,R0
   1195            /* UART parity error interrupt occurred ------------------------------------*/
   1196            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD005             BEQ.N    ??HAL_UART_IRQHandler_0
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD003             BEQ.N    ??HAL_UART_IRQHandler_0
   1197            { 
   1198              huart->ErrorCode |= HAL_UART_ERROR_PE;
   \   00000026   0x6BF0             LDR      R0,[R6, #+60]
   \   00000028   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002C   0x63F0             STR      R0,[R6, #+60]
   1199            }
   1200            
   1201            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
   \                     ??HAL_UART_IRQHandler_0: (+1)
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x0840             LSRS     R0,R0,#+1
   \   00000034   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000038   0x0004             MOVS     R4,R0
   1202            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0x6940             LDR      R0,[R0, #+20]
   \   0000003E   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000042   0x0005             MOVS     R5,R0
   1203            /* UART frame error interrupt occurred -------------------------------------*/
   1204            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD005             BEQ.N    ??HAL_UART_IRQHandler_1
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD003             BEQ.N    ??HAL_UART_IRQHandler_1
   1205            { 
   1206              huart->ErrorCode |= HAL_UART_ERROR_FE;
   \   0000004C   0x6BF0             LDR      R0,[R6, #+60]
   \   0000004E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000052   0x63F0             STR      R0,[R6, #+60]
   1207            }
   1208            
   1209            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
   \                     ??HAL_UART_IRQHandler_1: (+1)
   \   00000054   0x6830             LDR      R0,[R6, #+0]
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x0880             LSRS     R0,R0,#+2
   \   0000005A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000005E   0x0004             MOVS     R4,R0
   1210            /* UART noise error interrupt occurred -------------------------------------*/
   1211            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD005             BEQ.N    ??HAL_UART_IRQHandler_2
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD003             BEQ.N    ??HAL_UART_IRQHandler_2
   1212            { 
   1213              huart->ErrorCode |= HAL_UART_ERROR_NE;
   \   00000068   0x6BF0             LDR      R0,[R6, #+60]
   \   0000006A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000006E   0x63F0             STR      R0,[R6, #+60]
   1214            }
   1215            
   1216            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
   \                     ??HAL_UART_IRQHandler_2: (+1)
   \   00000070   0x6830             LDR      R0,[R6, #+0]
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x08C0             LSRS     R0,R0,#+3
   \   00000076   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000007A   0x0004             MOVS     R4,R0
   1217            /* UART Over-Run interrupt occurred ----------------------------------------*/
   1218            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   0000007C   0x2C00             CMP      R4,#+0
   \   0000007E   0xD005             BEQ.N    ??HAL_UART_IRQHandler_3
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xD003             BEQ.N    ??HAL_UART_IRQHandler_3
   1219            { 
   1220              huart->ErrorCode |= HAL_UART_ERROR_ORE;
   \   00000084   0x6BF0             LDR      R0,[R6, #+60]
   \   00000086   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000008A   0x63F0             STR      R0,[R6, #+60]
   1221            }
   1222            
   1223            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
   \                     ??HAL_UART_IRQHandler_3: (+1)
   \   0000008C   0x6830             LDR      R0,[R6, #+0]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x0940             LSRS     R0,R0,#+5
   \   00000092   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000096   0x0004             MOVS     R4,R0
   1224            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
   \   00000098   0x6830             LDR      R0,[R6, #+0]
   \   0000009A   0x68C0             LDR      R0,[R0, #+12]
   \   0000009C   0xF010 0x0020      ANDS     R0,R0,#0x20
   \   000000A0   0x0005             MOVS     R5,R0
   1225            /* UART in mode Receiver ---------------------------------------------------*/
   1226            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000A2   0x2C00             CMP      R4,#+0
   \   000000A4   0xD004             BEQ.N    ??HAL_UART_IRQHandler_4
   \   000000A6   0x2D00             CMP      R5,#+0
   \   000000A8   0xD002             BEQ.N    ??HAL_UART_IRQHandler_4
   1227            { 
   1228              UART_Receive_IT(huart);
   \   000000AA   0x0030             MOVS     R0,R6
   \   000000AC   0x.... 0x....      BL       UART_Receive_IT
   1229            }
   1230            
   1231            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
   \                     ??HAL_UART_IRQHandler_4: (+1)
   \   000000B0   0x6830             LDR      R0,[R6, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x09C0             LSRS     R0,R0,#+7
   \   000000B6   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000BA   0x0004             MOVS     R4,R0
   1232            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
   \   000000BC   0x6830             LDR      R0,[R6, #+0]
   \   000000BE   0x68C0             LDR      R0,[R0, #+12]
   \   000000C0   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   000000C4   0x0005             MOVS     R5,R0
   1233            /* UART in mode Transmitter ------------------------------------------------*/
   1234            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000C6   0x2C00             CMP      R4,#+0
   \   000000C8   0xD004             BEQ.N    ??HAL_UART_IRQHandler_5
   \   000000CA   0x2D00             CMP      R5,#+0
   \   000000CC   0xD002             BEQ.N    ??HAL_UART_IRQHandler_5
   1235            {
   1236              UART_Transmit_IT(huart);
   \   000000CE   0x0030             MOVS     R0,R6
   \   000000D0   0x.... 0x....      BL       UART_Transmit_IT
   1237            }
   1238          
   1239            tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
   \                     ??HAL_UART_IRQHandler_5: (+1)
   \   000000D4   0x6830             LDR      R0,[R6, #+0]
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x0980             LSRS     R0,R0,#+6
   \   000000DA   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   000000DE   0x0004             MOVS     R4,R0
   1240            tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
   \   000000E0   0x6830             LDR      R0,[R6, #+0]
   \   000000E2   0x68C0             LDR      R0,[R0, #+12]
   \   000000E4   0xF010 0x0040      ANDS     R0,R0,#0x40
   \   000000E8   0x0005             MOVS     R5,R0
   1241            /* UART in mode Transmitter end --------------------------------------------*/
   1242            if((tmp_flag != RESET) && (tmp_it_source != RESET))
   \   000000EA   0x2C00             CMP      R4,#+0
   \   000000EC   0xD004             BEQ.N    ??HAL_UART_IRQHandler_6
   \   000000EE   0x2D00             CMP      R5,#+0
   \   000000F0   0xD002             BEQ.N    ??HAL_UART_IRQHandler_6
   1243            {
   1244              UART_EndTransmit_IT(huart);
   \   000000F2   0x0030             MOVS     R0,R6
   \   000000F4   0x.... 0x....      BL       UART_EndTransmit_IT
   1245            }  
   1246          
   1247            if(huart->ErrorCode != HAL_UART_ERROR_NONE)
   \                     ??HAL_UART_IRQHandler_6: (+1)
   \   000000F8   0x6BF0             LDR      R0,[R6, #+60]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD00C             BEQ.N    ??HAL_UART_IRQHandler_7
   1248            {
   1249              /* Clear all the error flag at once */
   1250              __HAL_UART_CLEAR_PEFLAG(huart);
   \   000000FE   0x6830             LDR      R0,[R6, #+0]
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x6830             LDR      R0,[R6, #+0]
   \   00000106   0x6840             LDR      R0,[R0, #+4]
   \   00000108   0x9000             STR      R0,[SP, #+0]
   \   0000010A   0x9800             LDR      R0,[SP, #+0]
   1251              
   1252              /* Set the UART state ready to be able to start again the process */
   1253              huart->State = HAL_UART_STATE_READY;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0xF886 0x0039      STRB     R0,[R6, #+57]
   1254              
   1255              HAL_UART_ErrorCallback(huart);
   \   00000112   0x0030             MOVS     R0,R6
   \   00000114   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1256            }  
   1257          }
   \                     ??HAL_UART_IRQHandler_7: (+1)
   \   00000118   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1258          
   1259          /**
   1260            * @brief  Tx Transfer completed callbacks.
   1261            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1262            *                the configuration information for the specified UART module.
   1263            * @retval None
   1264            */

   \                                 In section .text, align 2
   1265           __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
   1266          {
   1267            /* Prevent unused argument(s) compilation warning */
   1268            UNUSED(huart);
   1269            /* NOTE: This function should not be modified, when the callback is needed,
   1270                     the HAL_UART_TxCpltCallback can be implemented in the user file
   1271             */ 
   1272          }
   \                     HAL_UART_TxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1273          
   1274          /**
   1275            * @brief  Tx Half Transfer completed callbacks.
   1276            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1277            *                the configuration information for the specified UART module.
   1278            * @retval None
   1279            */

   \                                 In section .text, align 2
   1280           __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
   1281          {
   1282            /* Prevent unused argument(s) compilation warning */
   1283            UNUSED(huart);
   1284            /* NOTE: This function should not be modified, when the callback is needed,
   1285                     the HAL_UART_TxHalfCpltCallback can be implemented in the user file
   1286             */ 
   1287          }
   \                     HAL_UART_TxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1288          
   1289          /**
   1290            * @brief  Rx Transfer completed callbacks.
   1291            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1292            *                the configuration information for the specified UART module.
   1293            * @retval None
   1294            */

   \                                 In section .text, align 2
   1295          __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
   1296          {
   1297            /* Prevent unused argument(s) compilation warning */
   1298            UNUSED(huart);
   1299            /* NOTE: This function should not be modified, when the callback is needed,
   1300                     the HAL_UART_RxCpltCallback can be implemented in the user file
   1301             */
   1302          }
   \                     HAL_UART_RxCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1303          
   1304          /**
   1305            * @brief  Rx Half Transfer completed callbacks.
   1306            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1307            *                the configuration information for the specified UART module.
   1308            * @retval None
   1309            */

   \                                 In section .text, align 2
   1310          __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
   1311          {
   1312            /* Prevent unused argument(s) compilation warning */
   1313            UNUSED(huart);
   1314            /* NOTE: This function should not be modified, when the callback is needed,
   1315                     the HAL_UART_RxHalfCpltCallback can be implemented in the user file
   1316             */
   1317          }
   \                     HAL_UART_RxHalfCpltCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1318          
   1319          /**
   1320            * @brief  UART error callbacks.
   1321            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1322            *                the configuration information for the specified UART module.
   1323            * @retval None
   1324            */

   \                                 In section .text, align 2
   1325           __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
   1326          {
   1327            /* Prevent unused argument(s) compilation warning */
   1328            UNUSED(huart);
   1329            /* NOTE: This function should not be modified, when the callback is needed,
   1330                     the HAL_UART_ErrorCallback can be implemented in the user file
   1331             */ 
   1332          }
   \                     HAL_UART_ErrorCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1333          
   1334          /**
   1335            * @}
   1336            */
   1337          
   1338          /** @defgroup UART_Exported_Functions_Group3 Peripheral Control functions 
   1339            *  @brief   UART control functions 
   1340            *
   1341          @verbatim   
   1342            ==============================================================================
   1343                                ##### Peripheral Control functions #####
   1344            ==============================================================================  
   1345            [..]
   1346              This subsection provides a set of functions allowing to control the UART:
   1347              (+) HAL_LIN_SendBreak() API can be helpful to transmit the break character.
   1348              (+) HAL_MultiProcessor_EnterMuteMode() API can be helpful to enter the UART in mute mode. 
   1349              (+) HAL_MultiProcessor_ExitMuteMode() API can be helpful to exit the UART mute mode by software.
   1350              (+) HAL_HalfDuplex_EnableTransmitter() API to enable the UART transmitter and disables the UART receiver in Half Duplex mode
   1351              (+) HAL_HalfDuplex_EnableReceiver() API to enable the UART receiver and disables the UART transmitter in Half Duplex mode
   1352              
   1353          @endverbatim
   1354            * @{
   1355            */
   1356          
   1357          /**
   1358            * @brief  Transmits break characters.
   1359            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1360            *                the configuration information for the specified UART module.
   1361            * @retval HAL status
   1362            */

   \                                 In section .text, align 2, keep-with-next
   1363          HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
   1364          {
   \                     HAL_LIN_SendBreak: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1365            /* Check the parameters */
   1366            assert_param(IS_UART_INSTANCE(huart->Instance));
   1367            
   1368            /* Process Locked */
   1369            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_LIN_SendBreak_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_LIN_SendBreak_1
   \                     ??HAL_LIN_SendBreak_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1370            
   1371            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1372            
   1373            /* Send break characters */
   1374            SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1375           
   1376            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1377            
   1378            /* Process Unlocked */
   1379            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1380            
   1381            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_LIN_SendBreak_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1382          }
   1383          
   1384          /**
   1385            * @brief  Enters the UART in mute mode. 
   1386            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1387            *                the configuration information for the specified UART module.
   1388            * @retval HAL status
   1389            */

   \                                 In section .text, align 2, keep-with-next
   1390          HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
   1391          {
   \                     HAL_MultiProcessor_EnterMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1392            /* Check the parameters */
   1393            assert_param(IS_UART_INSTANCE(huart->Instance));
   1394            
   1395            /* Process Locked */
   1396            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_EnterMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_MultiProcessor_EnterMuteMode_1
   \                     ??HAL_MultiProcessor_EnterMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1397            
   1398            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1399            
   1400            /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
   1401            SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1402            
   1403            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1404            
   1405            /* Process Unlocked */
   1406            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1407            
   1408            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_EnterMuteMode_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1409          }
   1410          
   1411          /**
   1412            * @brief  Exits the UART mute mode: wake up software. 
   1413            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1414            *                the configuration information for the specified UART module.
   1415            * @retval HAL status
   1416            */

   \                                 In section .text, align 2, keep-with-next
   1417          HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
   1418          {
   \                     HAL_MultiProcessor_ExitMuteMode: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1419            /* Check the parameters */
   1420            assert_param(IS_UART_INSTANCE(huart->Instance));
   1421            
   1422            /* Process Locked */
   1423            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_MultiProcessor_ExitMuteMode_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE012             B.N      ??HAL_MultiProcessor_ExitMuteMode_1
   \                     ??HAL_MultiProcessor_ExitMuteMode_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1424            
   1425            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1426            
   1427            /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
   1428            CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000022   0x680A             LDR      R2,[R1, #+0]
   \   00000024   0x60D0             STR      R0,[R2, #+12]
   1429            
   1430            huart->State = HAL_UART_STATE_READY;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF881 0x0039      STRB     R0,[R1, #+57]
   1431            
   1432            /* Process Unlocked */
   1433            __HAL_UNLOCK(huart);
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF881 0x0038      STRB     R0,[R1, #+56]
   1434            
   1435            return HAL_OK; 
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??HAL_MultiProcessor_ExitMuteMode_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
   1436          }
   1437          
   1438          /**
   1439            * @brief  Enables the UART transmitter and disables the UART receiver.
   1440            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1441            *                the configuration information for the specified UART module.
   1442            * @retval HAL status
   1443            */

   \                                 In section .text, align 2, keep-with-next
   1444          HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
   1445          {
   \                     HAL_HalfDuplex_EnableTransmitter: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1446            /* Process Locked */
   1447            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableTransmitter_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_HalfDuplex_EnableTransmitter_1
   \                     ??HAL_HalfDuplex_EnableTransmitter_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1448            
   1449            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1450          
   1451            /*-------------------------- USART CR1 Configuration -----------------------*/
   1452            /* Clear TE and RE bits */
   1453            /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
   1454            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x60D0             STR      R0,[R2, #+12]
   1455           
   1456            huart->State = HAL_UART_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x0039      STRB     R0,[R1, #+57]
   1457            
   1458            /* Process Unlocked */
   1459            __HAL_UNLOCK(huart);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x0038      STRB     R0,[R1, #+56]
   1460            
   1461            return HAL_OK; 
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableTransmitter_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1462          }
   1463          
   1464          /**
   1465            * @brief  Enables the UART receiver and disables the UART transmitter.
   1466            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1467            *                the configuration information for the specified UART module.
   1468            * @retval HAL status
   1469            */

   \                                 In section .text, align 2, keep-with-next
   1470          HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
   1471          {
   \                     HAL_HalfDuplex_EnableReceiver: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1472            /* Process Locked */
   1473            __HAL_LOCK(huart);
   \   00000002   0xF891 0x0038      LDRB     R0,[R1, #+56]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??HAL_HalfDuplex_EnableReceiver_0
   \   0000000A   0x2002             MOVS     R0,#+2
   \   0000000C   0xE014             B.N      ??HAL_HalfDuplex_EnableReceiver_1
   \                     ??HAL_HalfDuplex_EnableReceiver_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF881 0x0038      STRB     R0,[R1, #+56]
   1474            
   1475            huart->State = HAL_UART_STATE_BUSY;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xF881 0x0039      STRB     R0,[R1, #+57]
   1476          
   1477            /*-------------------------- USART CR1 Configuration -----------------------*/
   1478            /* Clear TE and RE bits */
   1479            /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
   1480            MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0x68C0             LDR      R0,[R0, #+12]
   \   0000001E   0xF030 0x000C      BICS     R0,R0,#0xC
   \   00000022   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000026   0x680A             LDR      R2,[R1, #+0]
   \   00000028   0x60D0             STR      R0,[R2, #+12]
   1481            
   1482            huart->State = HAL_UART_STATE_READY;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xF881 0x0039      STRB     R0,[R1, #+57]
   1483            
   1484            /* Process Unlocked */
   1485            __HAL_UNLOCK(huart);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF881 0x0038      STRB     R0,[R1, #+56]
   1486            
   1487            return HAL_OK; 
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??HAL_HalfDuplex_EnableReceiver_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   1488          }
   1489          
   1490          /**
   1491            * @}
   1492            */
   1493          
   1494          /** @defgroup UART_Exported_Functions_Group4 Peripheral State and Errors functions 
   1495            *  @brief   UART State and Errors functions 
   1496            *
   1497          @verbatim   
   1498            ==============================================================================
   1499                           ##### Peripheral State and Errors functions #####
   1500            ==============================================================================  
   1501           [..]
   1502             This subsection provides a set of functions allowing to return the State of 
   1503             UART communication process, return Peripheral Errors occurred during communication 
   1504             process
   1505             (+) HAL_UART_GetState() API can be helpful to check in run-time the state of the UART peripheral.
   1506             (+) HAL_UART_GetError() check in run-time errors that could be occurred during communication. 
   1507          
   1508          @endverbatim
   1509            * @{
   1510            */
   1511            
   1512          /**
   1513            * @brief  Returns the UART state.
   1514            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1515            *                the configuration information for the specified UART module.
   1516            * @retval HAL state
   1517            */

   \                                 In section .text, align 2, keep-with-next
   1518          HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
   1519          {
   1520            return huart->State;
   \                     HAL_UART_GetState: (+1)
   \   00000000   0xF890 0x0039      LDRB     R0,[R0, #+57]
   \   00000004   0x4770             BX       LR               ;; return
   1521          }
   1522          
   1523          /**
   1524          * @brief  Return the UART error code
   1525          * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1526            *              the configuration information for the specified UART.
   1527          * @retval UART Error Code
   1528          */

   \                                 In section .text, align 2, keep-with-next
   1529          uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
   1530          {
   1531            return huart->ErrorCode;
   \                     HAL_UART_GetError: (+1)
   \   00000000   0x6BC0             LDR      R0,[R0, #+60]
   \   00000002   0x4770             BX       LR               ;; return
   1532          }
   1533          
   1534          /**
   1535            * @}
   1536            */
   1537          
   1538          /**
   1539            * @}
   1540            */
   1541          
   1542          /** @defgroup UART_Private_Functions   UART Private Functions
   1543            *  @brief   UART Private functions 
   1544            * @{
   1545            */
   1546          /**
   1547            * @brief  DMA UART transmit process complete callback. 
   1548            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1549            *               the configuration information for the specified DMA module.
   1550            * @retval None
   1551            */

   \                                 In section .text, align 4, keep-with-next
   1552          static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
   1553          {
   \                     UART_DMATransmitCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1554            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1555            /* DMA Normal mode*/
   1556            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD40E             BMI.N    ??UART_DMATransmitCplt_0
   1557            {
   1558              huart->TxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x84E8             STRH     R0,[R5, #+38]
   1559          
   1560              /* Disable the DMA transfer for transmit request by setting the DMAT bit
   1561                 in the UART CR3 register */
   1562              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF030 0x0080      BICS     R0,R0,#0x80
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
   1563          
   1564              /* Enable the UART Transmit Complete Interrupt */    
   1565              __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   0000001E   0x6828             LDR      R0,[R5, #+0]
   \   00000020   0x68C0             LDR      R0,[R0, #+12]
   \   00000022   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x60C8             STR      R0,[R1, #+12]
   \   0000002A   0xE002             B.N      ??UART_DMATransmitCplt_1
   1566            }
   1567            /* DMA Circular mode */
   1568            else
   1569            {
   1570              HAL_UART_TxCpltCallback(huart);
   \                     ??UART_DMATransmitCplt_0: (+1)
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1571            }
   1572          }
   \                     ??UART_DMATransmitCplt_1: (+1)
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1573          
   1574          /**
   1575            * @brief DMA UART transmit process half complete callback 
   1576            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1577            *               the configuration information for the specified DMA module.
   1578            * @retval None
   1579            */

   \                                 In section .text, align 4, keep-with-next
   1580          static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
   1581          {
   \                     UART_DMATxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1582            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1583          
   1584            HAL_UART_TxHalfCpltCallback(huart);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_TxHalfCpltCallback
   1585          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1586          
   1587          /**
   1588            * @brief  DMA UART receive process complete callback. 
   1589            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1590            *               the configuration information for the specified DMA module.
   1591            * @retval None
   1592            */

   \                                 In section .text, align 4, keep-with-next
   1593          static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
   1594          {
   \                     UART_DMAReceiveCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1595            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1596            /* DMA Normal mode*/
   1597            if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0680             LSLS     R0,R0,#+26
   \   0000000C   0xD412             BMI.N    ??UART_DMAReceiveCplt_0
   1598            {
   1599              huart->RxXferCount = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x85E8             STRH     R0,[R5, #+46]
   1600            
   1601              /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
   1602                 in the UART CR3 register */
   1603              CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000001A   0x6829             LDR      R1,[R5, #+0]
   \   0000001C   0x6148             STR      R0,[R1, #+20]
   1604          
   1605              /* Check if a transmit process is ongoing or not */
   1606              if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   0000001E   0xF895 0x0039      LDRB     R0,[R5, #+57]
   \   00000022   0x2832             CMP      R0,#+50
   \   00000024   0xD103             BNE.N    ??UART_DMAReceiveCplt_1
   1607              {
   1608                huart->State = HAL_UART_STATE_BUSY_TX;
   \   00000026   0x2012             MOVS     R0,#+18
   \   00000028   0xF885 0x0039      STRB     R0,[R5, #+57]
   \   0000002C   0xE002             B.N      ??UART_DMAReceiveCplt_0
   1609              }
   1610              else
   1611              {
   1612                huart->State = HAL_UART_STATE_READY;
   \                     ??UART_DMAReceiveCplt_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xF885 0x0039      STRB     R0,[R5, #+57]
   1613              }
   1614            }
   1615            HAL_UART_RxCpltCallback(huart);
   \                     ??UART_DMAReceiveCplt_0: (+1)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1616          }
   \   0000003A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1617          
   1618          /**
   1619            * @brief DMA UART receive process half complete callback 
   1620            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1621            *               the configuration information for the specified DMA module.
   1622            * @retval None
   1623            */

   \                                 In section .text, align 4, keep-with-next
   1624          static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
   1625          {
   \                     UART_DMARxHalfCplt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1626            UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1627          
   1628            HAL_UART_RxHalfCpltCallback(huart); 
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       HAL_UART_RxHalfCpltCallback
   1629          }
   \   0000000C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1630          
   1631          /**
   1632            * @brief  DMA UART communication error callback.
   1633            * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
   1634            *               the configuration information for the specified DMA module.
   1635            * @retval None
   1636            */

   \                                 In section .text, align 4, keep-with-next
   1637          static void UART_DMAError(DMA_HandleTypeDef *hdma)   
   1638          {
   \                     UART_DMAError: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1639            UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   \   00000004   0x6A65             LDR      R5,[R4, #+36]
   1640            huart->RxXferCount = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x85E8             STRH     R0,[R5, #+46]
   1641            huart->TxXferCount = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x84E8             STRH     R0,[R5, #+38]
   1642            huart->State= HAL_UART_STATE_READY;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF885 0x0039      STRB     R0,[R5, #+57]
   1643            huart->ErrorCode |= HAL_UART_ERROR_DMA;
   \   00000014   0x6BE8             LDR      R0,[R5, #+60]
   \   00000016   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   0000001A   0x63E8             STR      R0,[R5, #+60]
   1644            HAL_UART_ErrorCallback(huart);
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       HAL_UART_ErrorCallback
   1645          }
   \   00000022   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1646          
   1647          /**
   1648            * @brief  This function handles UART Communication Timeout.
   1649            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1650            *                the configuration information for the specified UART module.
   1651            * @param  Flag: specifies the UART flag to check.
   1652            * @param  Status: The new Flag status (SET or RESET).
   1653            * @param  Timeout: Timeout duration
   1654            * @retval HAL status
   1655            */

   \                                 In section .text, align 2, keep-with-next
   1656          static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
   1657          {
   \                     UART_WaitOnFlagUntilTimeout: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001C             MOVS     R4,R3
   1658            uint32_t tickstart = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   1659          
   1660            /* Get tick */ 
   1661            tickstart = HAL_GetTick();
   \   00000010   0x.... 0x....      BL       HAL_GetTick
   \   00000014   0x4680             MOV      R8,R0
   1662          
   1663            /* Wait until flag is set */
   1664            if(Status == RESET)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD12F             BNE.N    ??UART_WaitOnFlagUntilTimeout_0
   1665            {
   1666              while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_1: (+1)
   \   0000001C   0x6830             LDR      R0,[R6, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4038             ANDS     R0,R7,R0
   \   00000022   0x42B8             CMP      R0,R7
   \   00000024   0xD05A             BEQ.N    ??UART_WaitOnFlagUntilTimeout_2
   1667              {
   1668                /* Check for the Timeout */
   1669                if(Timeout != HAL_MAX_DELAY)
   \   00000026   0xF114 0x0F01      CMN      R4,#+1
   \   0000002A   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_1
   1670                {
   1671                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_3
   \   00000030   0x.... 0x....      BL       HAL_GetTick
   \   00000034   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD2EF             BCS.N    ??UART_WaitOnFlagUntilTimeout_1
   1672                  {
   1673                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1674                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_3: (+1)
   \   0000003C   0x6830             LDR      R0,[R6, #+0]
   \   0000003E   0x68C0             LDR      R0,[R0, #+12]
   \   00000040   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000044   0x6831             LDR      R1,[R6, #+0]
   \   00000046   0x60C8             STR      R0,[R1, #+12]
   1675                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   00000048   0x6830             LDR      R0,[R6, #+0]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000050   0x6831             LDR      R1,[R6, #+0]
   \   00000052   0x60C8             STR      R0,[R1, #+12]
   1676                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   00000054   0x6830             LDR      R0,[R6, #+0]
   \   00000056   0x68C0             LDR      R0,[R0, #+12]
   \   00000058   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000005C   0x6831             LDR      R1,[R6, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
   1677                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   00000060   0x6830             LDR      R0,[R6, #+0]
   \   00000062   0x6940             LDR      R0,[R0, #+20]
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x0040             LSLS     R0,R0,#+1
   \   00000068   0x6831             LDR      R1,[R6, #+0]
   \   0000006A   0x6148             STR      R0,[R1, #+20]
   1678          
   1679                    huart->State= HAL_UART_STATE_READY;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xF886 0x0039      STRB     R0,[R6, #+57]
   1680          
   1681                    /* Process Unlocked */
   1682                    __HAL_UNLOCK(huart);
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xF886 0x0038      STRB     R0,[R6, #+56]
   1683          
   1684                    return HAL_TIMEOUT;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xE030             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1685                  }
   1686                }
   1687              }
   1688            }
   1689            else
   1690            {
   1691              while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
   \                     ??UART_WaitOnFlagUntilTimeout_0: (+1)
   \   0000007C   0x6830             LDR      R0,[R6, #+0]
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x4038             ANDS     R0,R7,R0
   \   00000082   0x42B8             CMP      R0,R7
   \   00000084   0xD12A             BNE.N    ??UART_WaitOnFlagUntilTimeout_2
   1692              {
   1693                /* Check for the Timeout */
   1694                if(Timeout != HAL_MAX_DELAY)
   \   00000086   0xF114 0x0F01      CMN      R4,#+1
   \   0000008A   0xD0F7             BEQ.N    ??UART_WaitOnFlagUntilTimeout_0
   1695                {
   1696                  if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
   \   0000008C   0x2C00             CMP      R4,#+0
   \   0000008E   0xD005             BEQ.N    ??UART_WaitOnFlagUntilTimeout_5
   \   00000090   0x.... 0x....      BL       HAL_GetTick
   \   00000094   0xEBB0 0x0008      SUBS     R0,R0,R8
   \   00000098   0x4284             CMP      R4,R0
   \   0000009A   0xD2EF             BCS.N    ??UART_WaitOnFlagUntilTimeout_0
   1697                  {
   1698                    /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
   1699                    __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \                     ??UART_WaitOnFlagUntilTimeout_5: (+1)
   \   0000009C   0x6830             LDR      R0,[R6, #+0]
   \   0000009E   0x68C0             LDR      R0,[R0, #+12]
   \   000000A0   0xF030 0x0080      BICS     R0,R0,#0x80
   \   000000A4   0x6831             LDR      R1,[R6, #+0]
   \   000000A6   0x60C8             STR      R0,[R1, #+12]
   1700                    __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   000000A8   0x6830             LDR      R0,[R6, #+0]
   \   000000AA   0x68C0             LDR      R0,[R0, #+12]
   \   000000AC   0xF030 0x0020      BICS     R0,R0,#0x20
   \   000000B0   0x6831             LDR      R1,[R6, #+0]
   \   000000B2   0x60C8             STR      R0,[R1, #+12]
   1701                    __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \   000000B4   0x6830             LDR      R0,[R6, #+0]
   \   000000B6   0x68C0             LDR      R0,[R0, #+12]
   \   000000B8   0xF430 0x7080      BICS     R0,R0,#0x100
   \   000000BC   0x6831             LDR      R1,[R6, #+0]
   \   000000BE   0x60C8             STR      R0,[R1, #+12]
   1702                    __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000C0   0x6830             LDR      R0,[R6, #+0]
   \   000000C2   0x6940             LDR      R0,[R0, #+20]
   \   000000C4   0x0840             LSRS     R0,R0,#+1
   \   000000C6   0x0040             LSLS     R0,R0,#+1
   \   000000C8   0x6831             LDR      R1,[R6, #+0]
   \   000000CA   0x6148             STR      R0,[R1, #+20]
   1703          
   1704                    huart->State= HAL_UART_STATE_READY;
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xF886 0x0039      STRB     R0,[R6, #+57]
   1705          
   1706                    /* Process Unlocked */
   1707                    __HAL_UNLOCK(huart);
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0xF886 0x0038      STRB     R0,[R6, #+56]
   1708          
   1709                    return HAL_TIMEOUT;
   \   000000D8   0x2003             MOVS     R0,#+3
   \   000000DA   0xE000             B.N      ??UART_WaitOnFlagUntilTimeout_4
   1710                  }
   1711                }
   1712              }
   1713            }
   1714            return HAL_OK;
   \                     ??UART_WaitOnFlagUntilTimeout_2: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??UART_WaitOnFlagUntilTimeout_4: (+1)
   \   000000DE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1715          }
   1716          
   1717          /**
   1718            * @brief  Sends an amount of data in non blocking mode.
   1719            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1720            *                the configuration information for the specified UART module.
   1721            * @retval HAL status
   1722            */

   \                                 In section .text, align 2, keep-with-next
   1723          static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
   1724          {
   \                     UART_Transmit_IT: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1725            uint16_t* tmp;
   1726            uint32_t tmp_state = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   1727            
   1728            tmp_state = huart->State;
   \   00000006   0xF891 0x0039      LDRB     R0,[R1, #+57]
   \   0000000A   0x0003             MOVS     R3,R0
   1729            if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2B12             CMP      R3,#+18
   \   0000000E   0xD001             BEQ.N    ??UART_Transmit_IT_0
   \   00000010   0x2B32             CMP      R3,#+50
   \   00000012   0xD12F             BNE.N    ??UART_Transmit_IT_1
   1730            {
   1731              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Transmit_IT_0: (+1)
   \   00000014   0x6888             LDR      R0,[R1, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD111             BNE.N    ??UART_Transmit_IT_2
   1732              {
   1733                tmp = (uint16_t*) huart->pTxBuffPtr;
   \   0000001C   0x6A08             LDR      R0,[R1, #+32]
   \   0000001E   0x0002             MOVS     R2,R0
   1734                huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
   \   00000020   0x8810             LDRH     R0,[R2, #+0]
   \   00000022   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000024   0x0DC0             LSRS     R0,R0,#+23
   \   00000026   0x680C             LDR      R4,[R1, #+0]
   \   00000028   0x6060             STR      R0,[R4, #+4]
   1735                if(huart->Init.Parity == UART_PARITY_NONE)
   \   0000002A   0x6908             LDR      R0,[R1, #+16]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??UART_Transmit_IT_3
   1736                {
   1737                  huart->pTxBuffPtr += 2;
   \   00000030   0x6A08             LDR      R0,[R1, #+32]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x6208             STR      R0,[R1, #+32]
   \   00000036   0xE009             B.N      ??UART_Transmit_IT_4
   1738                }
   1739                else
   1740                {
   1741                  huart->pTxBuffPtr += 1;
   \                     ??UART_Transmit_IT_3: (+1)
   \   00000038   0x6A08             LDR      R0,[R1, #+32]
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x6208             STR      R0,[R1, #+32]
   \   0000003E   0xE005             B.N      ??UART_Transmit_IT_4
   1742                }
   1743              } 
   1744              else
   1745              {
   1746                huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
   \                     ??UART_Transmit_IT_2: (+1)
   \   00000040   0x6A08             LDR      R0,[R1, #+32]
   \   00000042   0x1C44             ADDS     R4,R0,#+1
   \   00000044   0x620C             STR      R4,[R1, #+32]
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0x680C             LDR      R4,[R1, #+0]
   \   0000004A   0x6060             STR      R0,[R4, #+4]
   1747              }
   1748          
   1749              if(--huart->TxXferCount == 0)
   \                     ??UART_Transmit_IT_4: (+1)
   \   0000004C   0x8CC8             LDRH     R0,[R1, #+38]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x84C8             STRH     R0,[R1, #+38]
   \   00000052   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10B             BNE.N    ??UART_Transmit_IT_5
   1750              {
   1751                /* Disable the UART Transmit Complete Interrupt */
   1752                __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
   \   00000058   0x6808             LDR      R0,[R1, #+0]
   \   0000005A   0x68C0             LDR      R0,[R0, #+12]
   \   0000005C   0xF030 0x0080      BICS     R0,R0,#0x80
   \   00000060   0x680C             LDR      R4,[R1, #+0]
   \   00000062   0x60E0             STR      R0,[R4, #+12]
   1753          
   1754                /* Enable the UART Transmit Complete Interrupt */    
   1755                __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
   \   00000064   0x6808             LDR      R0,[R1, #+0]
   \   00000066   0x68C0             LDR      R0,[R0, #+12]
   \   00000068   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000006C   0x680C             LDR      R4,[R1, #+0]
   \   0000006E   0x60E0             STR      R0,[R4, #+12]
   1756              }
   1757              return HAL_OK;
   \                     ??UART_Transmit_IT_5: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xE000             B.N      ??UART_Transmit_IT_6
   1758            }
   1759            else
   1760            {
   1761              return HAL_BUSY;
   \                     ??UART_Transmit_IT_1: (+1)
   \   00000074   0x2002             MOVS     R0,#+2
   \                     ??UART_Transmit_IT_6: (+1)
   \   00000076   0xBC10             POP      {R4}
   \   00000078   0x4770             BX       LR               ;; return
   1762            }
   1763          }
   1764          
   1765          
   1766          /**
   1767            * @brief  Wraps up transmission in non blocking mode.
   1768            * @param  huart: pointer to a UART_HandleTypeDef structure that contains
   1769            *                the configuration information for the specified UART module.
   1770            * @retval HAL status
   1771            */

   \                                 In section .text, align 2, keep-with-next
   1772          static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
   1773          {
   \                     UART_EndTransmit_IT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1774            /* Disable the UART Transmit Complete Interrupt */    
   1775            __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
   \   00000004   0x6820             LDR      R0,[R4, #+0]
   \   00000006   0x68C0             LDR      R0,[R0, #+12]
   \   00000008   0xF030 0x0040      BICS     R0,R0,#0x40
   \   0000000C   0x6821             LDR      R1,[R4, #+0]
   \   0000000E   0x60C8             STR      R0,[R1, #+12]
   1776            
   1777            /* Check if a receive process is ongoing or not */
   1778            if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000010   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000014   0x2832             CMP      R0,#+50
   \   00000016   0xD103             BNE.N    ??UART_EndTransmit_IT_0
   1779            {
   1780              huart->State = HAL_UART_STATE_BUSY_RX;
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   0000001E   0xE002             B.N      ??UART_EndTransmit_IT_1
   1781            }
   1782            else
   1783            {
   1784              huart->State = HAL_UART_STATE_READY;
   \                     ??UART_EndTransmit_IT_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xF884 0x0039      STRB     R0,[R4, #+57]
   1785            }
   1786            
   1787            HAL_UART_TxCpltCallback(huart);
   \                     ??UART_EndTransmit_IT_1: (+1)
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       HAL_UART_TxCpltCallback
   1788            
   1789            return HAL_OK;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1790          }
   1791          
   1792          /**
   1793            * @brief  Receives an amount of data in non blocking mode 
   1794            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1795            *                the configuration information for the specified UART module.
   1796            * @retval HAL status
   1797            */

   \                                 In section .text, align 2, keep-with-next
   1798          static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
   1799          {
   \                     UART_Receive_IT: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1800            uint16_t* tmp;
   1801            uint32_t tmp_state = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   1802            
   1803            tmp_state = huart->State; 
   \   00000006   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000000A   0x0006             MOVS     R6,R0
   1804            if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
   \   0000000C   0x2E22             CMP      R6,#+34
   \   0000000E   0xD001             BEQ.N    ??UART_Receive_IT_0
   \   00000010   0x2E32             CMP      R6,#+50
   \   00000012   0xD156             BNE.N    ??UART_Receive_IT_1
   1805            {
   1806              if(huart->Init.WordLength == UART_WORDLENGTH_9B)
   \                     ??UART_Receive_IT_0: (+1)
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xF5B0 0x5F80      CMP      R0,#+4096
   \   0000001A   0xD116             BNE.N    ??UART_Receive_IT_2
   1807              {
   1808                tmp = (uint16_t*) huart->pRxBuffPtr;
   \   0000001C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000001E   0x0005             MOVS     R5,R0
   1809                if(huart->Init.Parity == UART_PARITY_NONE)
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD108             BNE.N    ??UART_Receive_IT_3
   1810                {
   1811                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   0000002C   0x0DC0             LSRS     R0,R0,#+23
   \   0000002E   0x8028             STRH     R0,[R5, #+0]
   1812                  huart->pRxBuffPtr += 2;
   \   00000030   0x6AA0             LDR      R0,[R4, #+40]
   \   00000032   0x1C80             ADDS     R0,R0,#+2
   \   00000034   0x62A0             STR      R0,[R4, #+40]
   \   00000036   0xE01A             B.N      ??UART_Receive_IT_4
   1813                }
   1814                else
   1815                {
   1816                  *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
   \                     ??UART_Receive_IT_3: (+1)
   \   00000038   0x6820             LDR      R0,[R4, #+0]
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0xF000 0x00FF      AND      R0,R0,#0xFF
   \   00000040   0x8028             STRH     R0,[R5, #+0]
   1817                  huart->pRxBuffPtr += 1;
   \   00000042   0x6AA0             LDR      R0,[R4, #+40]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0x62A0             STR      R0,[R4, #+40]
   \   00000048   0xE011             B.N      ??UART_Receive_IT_4
   1818                }
   1819              }
   1820              else
   1821              {
   1822                if(huart->Init.Parity == UART_PARITY_NONE)
   \                     ??UART_Receive_IT_2: (+1)
   \   0000004A   0x6920             LDR      R0,[R4, #+16]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD106             BNE.N    ??UART_Receive_IT_5
   1823                {
   1824                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
   \   00000050   0x6AA0             LDR      R0,[R4, #+40]
   \   00000052   0x1C41             ADDS     R1,R0,#+1
   \   00000054   0x62A1             STR      R1,[R4, #+40]
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0x6849             LDR      R1,[R1, #+4]
   \   0000005A   0x7001             STRB     R1,[R0, #+0]
   \   0000005C   0xE007             B.N      ??UART_Receive_IT_4
   1825                }
   1826                else
   1827                {
   1828                  *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
   \                     ??UART_Receive_IT_5: (+1)
   \   0000005E   0x6AA0             LDR      R0,[R4, #+40]
   \   00000060   0x1C41             ADDS     R1,R0,#+1
   \   00000062   0x62A1             STR      R1,[R4, #+40]
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x6849             LDR      R1,[R1, #+4]
   \   00000068   0xF011 0x017F      ANDS     R1,R1,#0x7F
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   1829                }
   1830              }
   1831          
   1832              if(--huart->RxXferCount == 0)
   \                     ??UART_Receive_IT_4: (+1)
   \   0000006E   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x85E0             STRH     R0,[R4, #+46]
   \   00000074   0x8DE0             LDRH     R0,[R4, #+46]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD121             BNE.N    ??UART_Receive_IT_6
   1833              {
   1834                __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x68C0             LDR      R0,[R0, #+12]
   \   0000007E   0xF030 0x0020      BICS     R0,R0,#0x20
   \   00000082   0x6821             LDR      R1,[R4, #+0]
   \   00000084   0x60C8             STR      R0,[R1, #+12]
   1835          
   1836                /* Check if a transmit process is ongoing or not */
   1837                if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
   \   00000086   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   0000008A   0x2832             CMP      R0,#+50
   \   0000008C   0xD103             BNE.N    ??UART_Receive_IT_7
   1838                {
   1839                  huart->State = HAL_UART_STATE_BUSY_TX;
   \   0000008E   0x2012             MOVS     R0,#+18
   \   00000090   0xF884 0x0039      STRB     R0,[R4, #+57]
   \   00000094   0xE00E             B.N      ??UART_Receive_IT_8
   1840                }
   1841                else
   1842                {
   1843                  /* Disable the UART Parity Error Interrupt */
   1844                  __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
   \                     ??UART_Receive_IT_7: (+1)
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x68C0             LDR      R0,[R0, #+12]
   \   0000009A   0xF430 0x7080      BICS     R0,R0,#0x100
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x60C8             STR      R0,[R1, #+12]
   1845          
   1846                  /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
   1847                  __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
   \   000000A2   0x6820             LDR      R0,[R4, #+0]
   \   000000A4   0x6940             LDR      R0,[R0, #+20]
   \   000000A6   0x0840             LSRS     R0,R0,#+1
   \   000000A8   0x0040             LSLS     R0,R0,#+1
   \   000000AA   0x6821             LDR      R1,[R4, #+0]
   \   000000AC   0x6148             STR      R0,[R1, #+20]
   1848          
   1849                  huart->State = HAL_UART_STATE_READY;
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xF884 0x0039      STRB     R0,[R4, #+57]
   1850                }
   1851                HAL_UART_RxCpltCallback(huart);
   \                     ??UART_Receive_IT_8: (+1)
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0x.... 0x....      BL       HAL_UART_RxCpltCallback
   1852          
   1853                return HAL_OK;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE002             B.N      ??UART_Receive_IT_9
   1854              }
   1855              return HAL_OK;
   \                     ??UART_Receive_IT_6: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0xE000             B.N      ??UART_Receive_IT_9
   1856            }
   1857            else
   1858            {
   1859              return HAL_BUSY; 
   \                     ??UART_Receive_IT_1: (+1)
   \   000000C2   0x2002             MOVS     R0,#+2
   \                     ??UART_Receive_IT_9: (+1)
   \   000000C4   0xBD70             POP      {R4-R6,PC}       ;; return
   1860            }
   1861          }
   1862          
   1863          /**
   1864            * @brief  Configures the UART peripheral. 
   1865            * @param  huart: Pointer to a UART_HandleTypeDef structure that contains
   1866            *                the configuration information for the specified UART module.
   1867            * @retval None
   1868            */

   \                                 In section .text, align 2, keep-with-next
   1869          static void UART_SetConfig(UART_HandleTypeDef *huart)
   1870          {
   \                     UART_SetConfig: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1871            uint32_t tmpreg = 0x00;
   \   00000006   0x2500             MOVS     R5,#+0
   1872            
   1873            /* Check the parameters */
   1874            assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
   1875            assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
   1876            assert_param(IS_UART_PARITY(huart->Init.Parity));
   1877            assert_param(IS_UART_MODE(huart->Init.Mode));
   1878          
   1879            /*------- UART-associated USART registers setting : CR2 Configuration ------*/
   1880            /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
   1881             * to huart->Init.StopBits value */
   1882            MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
   \   00000008   0x6820             LDR      R0,[R4, #+0]
   \   0000000A   0x6901             LDR      R1,[R0, #+16]
   \   0000000C   0xF431 0x5140      BICS     R1,R1,#0x3000
   \   00000010   0x68E0             LDR      R0,[R4, #+12]
   \   00000012   0x4301             ORRS     R1,R0,R1
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x6101             STR      R1,[R0, #+16]
   1883          
   1884            /*------- UART-associated USART registers setting : CR1 Configuration ------*/
   1885            /* Configure the UART Word Length, Parity and mode: 
   1886               Set the M bits according to huart->Init.WordLength value 
   1887               Set PCE and PS bits according to huart->Init.Parity value
   1888               Set TE and RE bits according to huart->Init.Mode value */
   1889            tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode ;
   \   00000018   0x68A1             LDR      R1,[R4, #+8]
   \   0000001A   0x6920             LDR      R0,[R4, #+16]
   \   0000001C   0x4301             ORRS     R1,R0,R1
   \   0000001E   0x6960             LDR      R0,[R4, #+20]
   \   00000020   0x4301             ORRS     R1,R0,R1
   \   00000022   0x000D             MOVS     R5,R1
   1890            MODIFY_REG(huart->Instance->CR1, 
   1891                       (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
   1892                       tmpreg);
   \   00000024   0x6820             LDR      R0,[R4, #+0]
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0x....             LDR.N    R0,??DataTable1  ;; 0xffffe9f3
   \   0000002A   0x4001             ANDS     R1,R0,R1
   \   0000002C   0x4329             ORRS     R1,R5,R1
   \   0000002E   0x6820             LDR      R0,[R4, #+0]
   \   00000030   0x60C1             STR      R1,[R0, #+12]
   1893            
   1894            /*------- UART-associated USART registers setting : CR3 Configuration ------*/
   1895            /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
   1896            MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x6941             LDR      R1,[R0, #+20]
   \   00000036   0xF431 0x7140      BICS     R1,R1,#0x300
   \   0000003A   0x69A0             LDR      R0,[R4, #+24]
   \   0000003C   0x4301             ORRS     R1,R0,R1
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6141             STR      R1,[R0, #+20]
   1897            
   1898            /*------- UART-associated USART registers setting : BRR Configuration ------*/
   1899            if((huart->Instance == USART1))
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x....             LDR.N    R1,??DataTable1_1  ;; 0x40013800
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD150             BNE.N    ??UART_SetConfig_0
   1900            {
   1901              huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
   \   0000004A   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000004E   0x4681             MOV      R9,R0
   \   00000050   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000054   0x4680             MOV      R8,R0
   \   00000056   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000060   0x0006             MOVS     R6,R0
   \   00000062   0x.... 0x....      BL       HAL_RCC_GetPCLK2Freq
   \   00000066   0x2119             MOVS     R1,#+25
   \   00000068   0xFB01 0xF909      MUL      R9,R1,R9
   \   0000006C   0x6861             LDR      R1,[R4, #+4]
   \   0000006E   0x0089             LSLS     R1,R1,#+2
   \   00000070   0xFBB9 0xF1F1      UDIV     R1,R9,R1
   \   00000074   0x2264             MOVS     R2,#+100
   \   00000076   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \   0000007A   0x2119             MOVS     R1,#+25
   \   0000007C   0xFB01 0xF808      MUL      R8,R1,R8
   \   00000080   0x6861             LDR      R1,[R4, #+4]
   \   00000082   0x0089             LSLS     R1,R1,#+2
   \   00000084   0xFBB8 0xF3F1      UDIV     R3,R8,R1
   \   00000088   0x2119             MOVS     R1,#+25
   \   0000008A   0x434F             MULS     R7,R1,R7
   \   0000008C   0x6861             LDR      R1,[R4, #+4]
   \   0000008E   0x0089             LSLS     R1,R1,#+2
   \   00000090   0xFBB7 0xF1F1      UDIV     R1,R7,R1
   \   00000094   0x2764             MOVS     R7,#+100
   \   00000096   0xFBB1 0xF7F7      UDIV     R7,R1,R7
   \   0000009A   0x2164             MOVS     R1,#+100
   \   0000009C   0xFB01 0x3317      MLS      R3,R1,R7,R3
   \   000000A0   0x0119             LSLS     R1,R3,#+4
   \   000000A2   0x3132             ADDS     R1,R1,#+50
   \   000000A4   0x2364             MOVS     R3,#+100
   \   000000A6   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \   000000AA   0xF013 0x03F0      ANDS     R3,R3,#0xF0
   \   000000AE   0xEB13 0x1302      ADDS     R3,R3,R2, LSL #+4
   \   000000B2   0x2119             MOVS     R1,#+25
   \   000000B4   0x434E             MULS     R6,R1,R6
   \   000000B6   0x6861             LDR      R1,[R4, #+4]
   \   000000B8   0x0089             LSLS     R1,R1,#+2
   \   000000BA   0xFBB6 0xF2F1      UDIV     R2,R6,R1
   \   000000BE   0x2119             MOVS     R1,#+25
   \   000000C0   0x4348             MULS     R0,R1,R0
   \   000000C2   0x6861             LDR      R1,[R4, #+4]
   \   000000C4   0x0089             LSLS     R1,R1,#+2
   \   000000C6   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000CA   0x2164             MOVS     R1,#+100
   \   000000CC   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000D0   0x2064             MOVS     R0,#+100
   \   000000D2   0xFB00 0x2211      MLS      R2,R0,R1,R2
   \   000000D6   0x0110             LSLS     R0,R2,#+4
   \   000000D8   0x3032             ADDS     R0,R0,#+50
   \   000000DA   0x2164             MOVS     R1,#+100
   \   000000DC   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   000000E0   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000000E4   0x18C3             ADDS     R3,R0,R3
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x6083             STR      R3,[R0, #+8]
   \   000000EA   0xE04F             B.N      ??UART_SetConfig_1
   1902            }
   1903            else
   1904            {
   1905              huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
   \                     ??UART_SetConfig_0: (+1)
   \   000000EC   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000F0   0x4681             MOV      R9,R0
   \   000000F2   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000F6   0x4680             MOV      R8,R0
   \   000000F8   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   000000FC   0x0007             MOVS     R7,R0
   \   000000FE   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000102   0x0006             MOVS     R6,R0
   \   00000104   0x.... 0x....      BL       HAL_RCC_GetPCLK1Freq
   \   00000108   0x2119             MOVS     R1,#+25
   \   0000010A   0xFB01 0xF909      MUL      R9,R1,R9
   \   0000010E   0x6861             LDR      R1,[R4, #+4]
   \   00000110   0x0089             LSLS     R1,R1,#+2
   \   00000112   0xFBB9 0xF1F1      UDIV     R1,R9,R1
   \   00000116   0x2264             MOVS     R2,#+100
   \   00000118   0xFBB1 0xF2F2      UDIV     R2,R1,R2
   \   0000011C   0x2119             MOVS     R1,#+25
   \   0000011E   0xFB01 0xF808      MUL      R8,R1,R8
   \   00000122   0x6861             LDR      R1,[R4, #+4]
   \   00000124   0x0089             LSLS     R1,R1,#+2
   \   00000126   0xFBB8 0xF3F1      UDIV     R3,R8,R1
   \   0000012A   0x2119             MOVS     R1,#+25
   \   0000012C   0x434F             MULS     R7,R1,R7
   \   0000012E   0x6861             LDR      R1,[R4, #+4]
   \   00000130   0x0089             LSLS     R1,R1,#+2
   \   00000132   0xFBB7 0xF1F1      UDIV     R1,R7,R1
   \   00000136   0x2764             MOVS     R7,#+100
   \   00000138   0xFBB1 0xF7F7      UDIV     R7,R1,R7
   \   0000013C   0x2164             MOVS     R1,#+100
   \   0000013E   0xFB01 0x3317      MLS      R3,R1,R7,R3
   \   00000142   0x0119             LSLS     R1,R3,#+4
   \   00000144   0x3132             ADDS     R1,R1,#+50
   \   00000146   0x2364             MOVS     R3,#+100
   \   00000148   0xFBB1 0xF3F3      UDIV     R3,R1,R3
   \   0000014C   0xF013 0x03F0      ANDS     R3,R3,#0xF0
   \   00000150   0xEB13 0x1302      ADDS     R3,R3,R2, LSL #+4
   \   00000154   0x2119             MOVS     R1,#+25
   \   00000156   0x434E             MULS     R6,R1,R6
   \   00000158   0x6861             LDR      R1,[R4, #+4]
   \   0000015A   0x0089             LSLS     R1,R1,#+2
   \   0000015C   0xFBB6 0xF2F1      UDIV     R2,R6,R1
   \   00000160   0x2119             MOVS     R1,#+25
   \   00000162   0x4348             MULS     R0,R1,R0
   \   00000164   0x6861             LDR      R1,[R4, #+4]
   \   00000166   0x0089             LSLS     R1,R1,#+2
   \   00000168   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000016C   0x2164             MOVS     R1,#+100
   \   0000016E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000172   0x2064             MOVS     R0,#+100
   \   00000174   0xFB00 0x2211      MLS      R2,R0,R1,R2
   \   00000178   0x0110             LSLS     R0,R2,#+4
   \   0000017A   0x3032             ADDS     R0,R0,#+50
   \   0000017C   0x2164             MOVS     R1,#+100
   \   0000017E   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000182   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000186   0x18C3             ADDS     R3,R0,R3
   \   00000188   0x6820             LDR      R0,[R4, #+0]
   \   0000018A   0x6083             STR      R3,[R0, #+8]
   1906            }
   1907          }
   \                     ??UART_SetConfig_1: (+1)
   \   0000018C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xFFFFE9F3         DC32     0xffffe9f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40013800         DC32     0x40013800
   1908          /**
   1909            * @}
   1910            */
   1911          
   1912          #endif /* HAL_UART_MODULE_ENABLED */
   1913          /**
   1914            * @}
   1915            */
   1916          
   1917          /**
   1918            * @}
   1919            */
   1920          
   1921          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_HalfDuplex_EnableReceiver
       0   HAL_HalfDuplex_EnableTransmitter
       8   HAL_HalfDuplex_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
      16   HAL_LIN_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_LIN_SendBreak
       0   HAL_MultiProcessor_EnterMuteMode
       0   HAL_MultiProcessor_ExitMuteMode
      16   HAL_MultiProcessor_Init
        16   -> HAL_UART_MspInit
        16   -> UART_SetConfig
       0   HAL_UART_DMAPause
       4   HAL_UART_DMAResume
       8   HAL_UART_DMAStop
         8   -> HAL_DMA_Abort
       8   HAL_UART_DeInit
         8   -> HAL_UART_MspDeInit
       0   HAL_UART_ErrorCallback
       0   HAL_UART_GetError
       0   HAL_UART_GetState
      24   HAL_UART_IRQHandler
        24   -> HAL_UART_ErrorCallback
        24   -> UART_EndTransmit_IT
        24   -> UART_Receive_IT
        24   -> UART_Transmit_IT
       8   HAL_UART_Init
         8   -> HAL_UART_MspInit
         8   -> UART_SetConfig
       0   HAL_UART_MspDeInit
       0   HAL_UART_MspInit
      32   HAL_UART_Receive
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Receive_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Receive_IT
       0   HAL_UART_RxCpltCallback
       0   HAL_UART_RxHalfCpltCallback
      32   HAL_UART_Transmit
        32   -> UART_WaitOnFlagUntilTimeout
      24   HAL_UART_Transmit_DMA
        24   -> HAL_DMA_Start_IT
       8   HAL_UART_Transmit_IT
       0   HAL_UART_TxCpltCallback
       0   HAL_UART_TxHalfCpltCallback
      16   UART_DMAError
        16   -> HAL_UART_ErrorCallback
      16   UART_DMAReceiveCplt
        16   -> HAL_UART_RxCpltCallback
      16   UART_DMARxHalfCplt
        16   -> HAL_UART_RxHalfCpltCallback
      16   UART_DMATransmitCplt
        16   -> HAL_UART_TxCpltCallback
      16   UART_DMATxHalfCplt
        16   -> HAL_UART_TxHalfCpltCallback
       8   UART_EndTransmit_IT
         8   -> HAL_UART_TxCpltCallback
      16   UART_Receive_IT
        16   -> HAL_UART_RxCpltCallback
      32   UART_SetConfig
        32   -> HAL_RCC_GetPCLK1Freq
        32   -> HAL_RCC_GetPCLK2Freq
       4   UART_Transmit_IT
      24   UART_WaitOnFlagUntilTimeout
        24   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
      58  HAL_HalfDuplex_EnableReceiver
      58  HAL_HalfDuplex_EnableTransmitter
     118  HAL_HalfDuplex_Init
     134  HAL_LIN_Init
      54  HAL_LIN_SendBreak
      54  HAL_MultiProcessor_EnterMuteMode
      54  HAL_MultiProcessor_ExitMuteMode
     140  HAL_MultiProcessor_Init
     106  HAL_UART_DMAPause
     138  HAL_UART_DMAResume
      50  HAL_UART_DMAStop
      74  HAL_UART_DeInit
       2  HAL_UART_ErrorCallback
       4  HAL_UART_GetError
       6  HAL_UART_GetState
     282  HAL_UART_IRQHandler
     112  HAL_UART_Init
       2  HAL_UART_MspDeInit
       2  HAL_UART_MspInit
     264  HAL_UART_Receive
     158  HAL_UART_Receive_DMA
     136  HAL_UART_Receive_IT
       2  HAL_UART_RxCpltCallback
       2  HAL_UART_RxHalfCpltCallback
     252  HAL_UART_Transmit
     168  HAL_UART_Transmit_DMA
     112  HAL_UART_Transmit_IT
       2  HAL_UART_TxCpltCallback
       2  HAL_UART_TxHalfCpltCallback
      36  UART_DMAError
      60  UART_DMAReceiveCplt
      14  UART_DMARxHalfCplt
      52  UART_DMATransmitCplt
      14  UART_DMATxHalfCplt
      48  UART_EndTransmit_IT
     198  UART_Receive_IT
     400  UART_SetConfig
     122  UART_Transmit_IT
     226  UART_WaitOnFlagUntilTimeout

 
 3 724 bytes in section .text
 
 3 710 bytes of CODE memory (+ 14 bytes shared)

Errors: none
Warnings: none
