###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.1.13263/W32 for ARM       14/Apr/2017  11:26:45
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
#    Command line =  
#        -f C:\Users\wkxbo\AppData\Local\Temp\EWC98F.tmp
#        (D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
#        -D USE_HAL_DRIVER -D STM32F103xB -D USE_STM3210C_wkxboot -lC
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List
#        -lA
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List
#        -o
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\Inc\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\BSP\STM3210C_EVAL\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\include\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\src\flashloader\NXP\FlashQN9080\chip_qn908x\cmsis\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List\cmsis_os.lst
#    Object file  =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\Obj\cmsis_os.o
#
###############################################################################

D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
      1          /* ----------------------------------------------------------------------
      2           * $Date:        5. February 2013
      3           * $Revision:    V1.02
      4           *
      5           * Project:      CMSIS-RTOS API
      6           * Title:        cmsis_os.c
      7           *
      8           * Version 0.02
      9           *    Initial Proposal Phase
     10           * Version 0.03
     11           *    osKernelStart added, optional feature: main started as thread
     12           *    osSemaphores have standard behavior
     13           *    osTimerCreate does not start the timer, added osTimerStart
     14           *    osThreadPass is renamed to osThreadYield
     15           * Version 1.01
     16           *    Support for C++ interface
     17           *     - const attribute removed from the osXxxxDef_t typedef's
     18           *     - const attribute added to the osXxxxDef macros
     19           *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
     20           *    Added: osKernelInitialize
     21           * Version 1.02
     22           *    Control functions for short timeouts in microsecond resolution:
     23           *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
     24           *    Removed: osSignalGet 
     25           *    
     26           *  
     27           *----------------------------------------------------------------------------
     28           *
     29           * Portions Copyright © 2016 STMicroelectronics International N.V. All rights reserved.
     30           * Portions Copyright (c) 2013 ARM LIMITED
     31           * All rights reserved.
     32           * Redistribution and use in source and binary forms, with or without
     33           * modification, are permitted provided that the following conditions are met:
     34           *  - Redistributions of source code must retain the above copyright
     35           *    notice, this list of conditions and the following disclaimer.
     36           *  - Redistributions in binary form must reproduce the above copyright
     37           *    notice, this list of conditions and the following disclaimer in the
     38           *    documentation and/or other materials provided with the distribution.
     39           *  - Neither the name of ARM  nor the names of its contributors may be used
     40           *    to endorse or promote products derived from this software without
     41           *    specific prior written permission.
     42           *
     43           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     44           * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     45           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     46           * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
     47           * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     48           * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     49           * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     50           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     51           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     52           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     53           * POSSIBILITY OF SUCH DAMAGE.
     54           *---------------------------------------------------------------------------*/
     55          
     56           /**
     57            ******************************************************************************
     58            * @file    cmsis_os.c
     59            * @author  MCD Application Team
     60            * @date    22-January-2016
     61            * @brief   CMSIS-RTOS API implementation for FreeRTOS V8.2.3
     62            ******************************************************************************
     63            * @attention
     64            *
     65            * Redistribution and use in source and binary forms, with or without 
     66            * modification, are permitted, provided that the following conditions are met:
     67            *
     68            * 1. Redistribution of source code must retain the above copyright notice, 
     69            *    this list of conditions and the following disclaimer.
     70            * 2. Redistributions in binary form must reproduce the above copyright notice,
     71            *    this list of conditions and the following disclaimer in the documentation
     72            *    and/or other materials provided with the distribution.
     73            * 3. Neither the name of STMicroelectronics nor the names of other 
     74            *    contributors to this software may be used to endorse or promote products 
     75            *    derived from this software without specific written permission.
     76            * 4. This software, including modifications and/or derivative works of this 
     77            *    software, must execute solely and exclusively on microcontroller or
     78            *    microprocessor devices manufactured by or for STMicroelectronics.
     79            * 5. Redistribution and use of this software other than as permitted under 
     80            *    this license is void and will automatically terminate your rights under 
     81            *    this license. 
     82            *
     83            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
     84            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
     85            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
     86            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     87            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
     88            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     89            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     90            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
     91            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     92            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
     93            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     94            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97            */ 
     98          
     99          #include <string.h>
    100          #include "cmsis_os.h"
    101          
    102          extern void xPortSysTickHandler(void);
    103          
    104          /* Convert from CMSIS type osPriority to FreeRTOS priority number */

   \                                 In section .text, align 2, keep-with-next
    105          static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
    106          {
   \                     makeFreeRtosPriority: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    107            unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
   \   00000002   0x2000             MOVS     R0,#+0
    108            
    109            if (priority != osPriorityError) {
   \   00000004   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   00000006   0x2A84             CMP      R2,#+132
   \   00000008   0xD002             BEQ.N    ??makeFreeRtosPriority_0
    110              fpriority += (priority - osPriorityIdle);
   \   0000000A   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000000C   0x1CD1             ADDS     R1,R2,#+3
   \   0000000E   0x1808             ADDS     R0,R1,R0
    111            }
    112            
    113            return fpriority;
   \                     ??makeFreeRtosPriority_0: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    114          }
    115          
    116          #if (INCLUDE_uxTaskPriorityGet == 1)
    117          /* Convert from FreeRTOS priority number to CMSIS type osPriority */

   \                                 In section .text, align 2, keep-with-next
    118          static osPriority makeCmsisPriority (unsigned portBASE_TYPE fpriority)
    119          {
   \                     makeCmsisPriority: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    120            osPriority priority = osPriorityError;
   \   00000002   0x2084             MOVS     R0,#+132
    121            
    122            if ((fpriority - tskIDLE_PRIORITY) <= (osPriorityRealtime - osPriorityIdle)) {
   \   00000004   0x2907             CMP      R1,#+7
   \   00000006   0xD202             BCS.N    ??makeCmsisPriority_0
    123              priority = (osPriority)((int)osPriorityIdle + (int)(fpriority - tskIDLE_PRIORITY));
   \   00000008   0x000A             MOVS     R2,R1
   \   0000000A   0x1ED2             SUBS     R2,R2,#+3
   \   0000000C   0x0010             MOVS     R0,R2
    124            }
    125            
    126            return priority;
   \                     ??makeCmsisPriority_0: (+1)
   \   0000000E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000010   0x4770             BX       LR               ;; return
    127          }
    128          #endif
    129          
    130          
    131          /* Determine whether we are in thread mode or handler mode. */

   \                                 In section .text, align 2, keep-with-next
    132          static int inHandlerMode (void)
    133          {
    134            return __get_IPSR() != 0;
   \                     inHandlerMode: (+1)
   \   00000000   0xF3EF 0x8005      MRS      R0,IPSR
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??inHandlerMode_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B.N      ??inHandlerMode_1
   \                     ??inHandlerMode_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??inHandlerMode_1: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x4770             BX       LR               ;; return
    135          }
    136          
    137          /*********************** Kernel Control Functions *****************************/
    138          /**
    139          * @brief  Initialize the RTOS Kernel for creating objects.
    140          * @retval status code that indicates the execution status of the function.
    141          * @note   MUST REMAIN UNCHANGED: \b osKernelInitialize shall be consistent in every CMSIS-RTOS.
    142          */
    143          osStatus osKernelInitialize (void);
    144          
    145          /**
    146          * @brief  Start the RTOS Kernel with executing the specified thread.
    147          * @param  thread_def    thread definition referenced with \ref osThread.
    148          * @param  argument      pointer that is passed to the thread function as start argument.
    149          * @retval status code that indicates the execution status of the function
    150          * @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
    151          */

   \                                 In section .text, align 2, keep-with-next
    152          osStatus osKernelStart (void)
    153          {
   \                     osKernelStart: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    154            vTaskStartScheduler();
   \   00000002   0x.... 0x....      BL       vTaskStartScheduler
    155            
    156            return osOK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    157          }
    158          
    159          /**
    160          * @brief  Check if the RTOS kernel is already started
    161          * @param  None
    162          * @retval (0) RTOS is not started
    163          *         (1) RTOS is started
    164          *         (-1) if this feature is disabled in FreeRTOSConfig.h 
    165          * @note  MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS.
    166          */

   \                                 In section .text, align 2, keep-with-next
    167          int32_t osKernelRunning(void)
    168          {
   \                     osKernelRunning: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    169          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    170            if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
   \   00000002   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??osKernelRunning_0
    171              return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE000             B.N      ??osKernelRunning_1
    172            else
    173              return 1;
   \                     ??osKernelRunning_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \                     ??osKernelRunning_1: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
    174          #else
    175          	return (-1);
    176          #endif	
    177          }
    178          
    179          #if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
    180          /**
    181          * @brief  Get the value of the Kernel SysTick timer
    182          * @param  None
    183          * @retval None
    184          * @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
    185          */

   \                                 In section .text, align 2, keep-with-next
    186          uint32_t osKernelSysTick(void)
    187          {
   \                     osKernelSysTick: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    188            if (inHandlerMode()) {
   \   00000002   0x.... 0x....      BL       inHandlerMode
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ.N    ??osKernelSysTick_0
    189              return xTaskGetTickCountFromISR();
   \   0000000A   0x.... 0x....      BL       xTaskGetTickCountFromISR
   \   0000000E   0xE001             B.N      ??osKernelSysTick_1
    190            }
    191            else {
    192              return xTaskGetTickCount();
   \                     ??osKernelSysTick_0: (+1)
   \   00000010   0x.... 0x....      BL       xTaskGetTickCount
   \                     ??osKernelSysTick_1: (+1)
   \   00000014   0xBD02             POP      {R1,PC}          ;; return
    193            }
    194          }
    195          #endif    // System Timer available
    196          /*********************** Thread Management *****************************/
    197          /**
    198          * @brief  Create a thread and add it to Active Threads and set it to state READY.
    199          * @param  thread_def    thread definition referenced with \ref osThread.
    200          * @param  argument      pointer that is passed to the thread function as start argument.
    201          * @retval thread ID for reference by other functions or NULL in case of error.
    202          * @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
    203          */

   \                                 In section .text, align 2, keep-with-next
    204          osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
    205          {
   \                     osThreadCreate: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    206            TaskHandle_t handle;
    207            
    208            
    209            if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
    210                        thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
    211                        &handle) != pdPASS)  {
   \   00000008   0xF9B4 0x0008      LDRSH    R0,[R4, #+8]
   \   0000000C   0x.... 0x....      BL       makeFreeRtosPriority
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x9103             STR      R1,[SP, #+12]
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x9102             STR      R1,[SP, #+8]
   \   00000018   0xA904             ADD      R1,SP,#+16
   \   0000001A   0x9101             STR      R1,[SP, #+4]
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   \   0000001E   0x002B             MOVS     R3,R5
   \   00000020   0x6922             LDR      R2,[R4, #+16]
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x.... 0x....      BL       xTaskGenericCreate
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD001             BEQ.N    ??osThreadCreate_0
    212              return NULL;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE000             B.N      ??osThreadCreate_1
    213            }
    214            
    215            return handle;
   \                     ??osThreadCreate_0: (+1)
   \   00000034   0x9804             LDR      R0,[SP, #+16]
   \                     ??osThreadCreate_1: (+1)
   \   00000036   0xB005             ADD      SP,SP,#+20
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
    216          }
    217          
    218          /**
    219          * @brief  Return the thread ID of the current running thread.
    220          * @retval thread ID for reference by other functions or NULL in case of error.
    221          * @note   MUST REMAIN UNCHANGED: \b osThreadGetId shall be consistent in every CMSIS-RTOS.
    222          */

   \                                 In section .text, align 2, keep-with-next
    223          osThreadId osThreadGetId (void)
    224          {
   \                     osThreadGetId: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    225          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
    226            return xTaskGetCurrentTaskHandle();
   \   00000002   0x.... 0x....      BL       xTaskGetCurrentTaskHandle
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    227          #else
    228          	return NULL;
    229          #endif
    230          }
    231          
    232          /**
    233          * @brief  Terminate execution of a thread and remove it from Active Threads.
    234          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    235          * @retval  status code that indicates the execution status of the function.
    236          * @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
    237          */

   \                                 In section .text, align 2, keep-with-next
    238          osStatus osThreadTerminate (osThreadId thread_id)
    239          {
   \                     osThreadTerminate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240          #if (INCLUDE_vTaskDelete == 1)
    241            vTaskDelete(thread_id);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       vTaskDelete
    242            return osOK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    243          #else
    244            return osErrorOS;
    245          #endif
    246          }
    247          
    248          /**
    249          * @brief  Pass control to next thread that is in state \b READY.
    250          * @retval status code that indicates the execution status of the function.
    251          * @note   MUST REMAIN UNCHANGED: \b osThreadYield shall be consistent in every CMSIS-RTOS.
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          osStatus osThreadYield (void)
    254          {
   \                     osThreadYield: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255            taskYIELD();
   \   00000002   0x.... 0x....      BL       vPortYield
    256            
    257            return osOK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    258          }
    259          
    260          /**
    261          * @brief   Change priority of an active thread.
    262          * @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    263          * @param   priority      new priority value for the thread function.
    264          * @retval  status code that indicates the execution status of the function.
    265          * @note   MUST REMAIN UNCHANGED: \b osThreadSetPriority shall be consistent in every CMSIS-RTOS.
    266          */

   \                                 In section .text, align 2, keep-with-next
    267          osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority)
    268          {
   \                     osThreadSetPriority: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    269          #if (INCLUDE_vTaskPrioritySet == 1)
    270            vTaskPrioritySet(thread_id, makeFreeRtosPriority(priority));
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000A   0x.... 0x....      BL       makeFreeRtosPriority
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       vTaskPrioritySet
    271            return osOK;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    272          #else
    273            return osErrorOS;
    274          #endif
    275          }
    276          
    277          /**
    278          * @brief   Get current priority of an active thread.
    279          * @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    280          * @retval  current priority value of the thread function.
    281          * @note   MUST REMAIN UNCHANGED: \b osThreadGetPriority shall be consistent in every CMSIS-RTOS.
    282          */

   \                                 In section .text, align 2, keep-with-next
    283          osPriority osThreadGetPriority (osThreadId thread_id)
    284          {
   \                     osThreadGetPriority: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    285          #if (INCLUDE_uxTaskPriorityGet == 1)
    286            if (inHandlerMode())
   \   00000004   0x.... 0x....      BL       inHandlerMode
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??osThreadGetPriority_0
    287            {
    288              return makeCmsisPriority(uxTaskPriorityGetFromISR(thread_id));  
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       uxTaskPriorityGetFromISR
   \   00000012   0x.... 0x....      BL       makeCmsisPriority
   \   00000016   0xE004             B.N      ??osThreadGetPriority_1
    289            }
    290            else
    291            {  
    292              return makeCmsisPriority(uxTaskPriorityGet(thread_id));
   \                     ??osThreadGetPriority_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       uxTaskPriorityGet
   \   0000001E   0x.... 0x....      BL       makeCmsisPriority
   \                     ??osThreadGetPriority_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    293            }
    294          #else
    295            return osPriorityError;
    296          #endif
    297          }
    298          
    299          /*********************** Generic Wait Functions *******************************/
    300          /**
    301          * @brief   Wait for Timeout (Time Delay)
    302          * @param   millisec      time delay value
    303          * @retval  status code that indicates the execution status of the function.
    304          */

   \                                 In section .text, align 2, keep-with-next
    305          osStatus osDelay (uint32_t millisec)
    306          {
   \                     osDelay: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
    307          #if INCLUDE_vTaskDelay
    308            TickType_t ticks = millisec / portTICK_PERIOD_MS;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xFBB5 0xF4F0      UDIV     R4,R5,R0
    309            
    310            vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD001             BEQ.N    ??osDelay_0
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xE000             B.N      ??osDelay_1
   \                     ??osDelay_0: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??osDelay_1: (+1)
   \   00000014   0x.... 0x....      BL       vTaskDelay
    311            
    312            return osOK;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    313          #else
    314            (void) millisec;
    315            
    316            return osErrorResource;
    317          #endif
    318          }
    319          
    320          #if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0)) /* Generic Wait available */
    321          /**
    322          * @brief  Wait for Signal, Message, Mail, or Timeout
    323          * @param   millisec  timeout value or 0 in case of no time-out
    324          * @retval  event that contains signal, message, or mail information or error code.
    325          * @note   MUST REMAIN UNCHANGED: \b osWait shall be consistent in every CMSIS-RTOS.
    326          */
    327          osEvent osWait (uint32_t millisec);
    328          
    329          #endif  /* Generic Wait available */
    330          
    331          /***********************  Timer Management Functions ***************************/
    332          /**
    333          * @brief  Create a timer.
    334          * @param  timer_def     timer object referenced with \ref osTimer.
    335          * @param  type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
    336          * @param  argument      argument to the timer call back function.
    337          * @retval  timer ID for reference by other functions or NULL in case of error.
    338          * @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
    339          */

   \                                 In section .text, align 2, keep-with-next
    340          osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
    341          {
   \                     osTimerCreate: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    342          #if (configUSE_TIMERS == 1)
    343            return xTimerCreate((const char *)"",
    344                                1, // period should be filled when starting the Timer using osTimerStart
    345                                (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
    346                                (void *) argument,
    347                                (TaskFunction_t)timer_def->ptimer);
    348          #else 
    349          	return NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
    350          #endif
    351          }
    352          
    353          /**
    354          * @brief  Start or restart a timer.
    355          * @param  timer_id      timer ID obtained by \ref osTimerCreate.
    356          * @param  millisec      time delay value of the timer.
    357          * @retval  status code that indicates the execution status of the function
    358          * @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
    359          */

   \                                 In section .text, align 2, keep-with-next
    360          osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
    361          {
   \                     osTimerStart: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    362            osStatus result = osOK;
   \   00000002   0x2000             MOVS     R0,#+0
    363          #if (configUSE_TIMERS == 1)  
    364            portBASE_TYPE taskWoken = pdFALSE;
    365            TickType_t ticks = millisec / portTICK_PERIOD_MS;
    366          
    367            if (ticks == 0)
    368              ticks = 1;
    369              
    370            if (inHandlerMode()) 
    371            {
    372              if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
    373              {
    374                result = osErrorOS;
    375              }
    376              else
    377              {
    378                portEND_SWITCHING_ISR(taskWoken);     
    379              }
    380            }
    381            else 
    382            {
    383              if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
    384                result = osErrorOS;
    385            }
    386          
    387          #else 
    388            result = osErrorOS;
   \   00000004   0x23FF             MOVS     R3,#+255
   \   00000006   0x0018             MOVS     R0,R3
    389          #endif
    390            return result;
   \   00000008   0x4770             BX       LR               ;; return
    391          }
    392          
    393          /**
    394          * @brief  Stop a timer.
    395          * @param  timer_id      timer ID obtained by \ref osTimerCreate
    396          * @retval  status code that indicates the execution status of the function.
    397          * @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          osStatus osTimerStop (osTimerId timer_id)
    400          {
   \                     osTimerStop: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    401            osStatus result = osOK;
   \   00000002   0x2000             MOVS     R0,#+0
    402          #if (configUSE_TIMERS == 1)  
    403            portBASE_TYPE taskWoken = pdFALSE;
    404          
    405            if (inHandlerMode()) {
    406              if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
    407                return osErrorOS;
    408              }
    409              portEND_SWITCHING_ISR(taskWoken);
    410            }
    411            else {
    412              if (xTimerStop(timer_id, 0) != pdPASS) {
    413                result = osErrorOS;
    414              }
    415            }
    416          #else 
    417            result = osErrorOS;
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x0010             MOVS     R0,R2
    418          #endif 
    419            return result;
   \   00000008   0x4770             BX       LR               ;; return
    420          }
    421          
    422          /**
    423          * @brief  Delete a timer.
    424          * @param  timer_id      timer ID obtained by \ref osTimerCreate
    425          * @retval  status code that indicates the execution status of the function.
    426          * @note   MUST REMAIN UNCHANGED: \b osTimerDelete shall be consistent in every CMSIS-RTOS.
    427          */

   \                                 In section .text, align 2, keep-with-next
    428          osStatus osTimerDelete (osTimerId timer_id)
    429          {
   \                     osTimerDelete: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    430          osStatus result = osOK;
   \   00000002   0x2000             MOVS     R0,#+0
    431          
    432          #if (configUSE_TIMERS == 1)
    433          
    434             if (inHandlerMode()) {
    435               return osErrorISR;
    436            }
    437            else { 
    438              if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
    439                result = osErrorOS;
    440              }
    441            } 
    442              
    443          #else 
    444            result = osErrorOS;
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x0010             MOVS     R0,R2
    445          #endif 
    446           
    447            return result;
   \   00000008   0x4770             BX       LR               ;; return
    448          }
    449          
    450          /***************************  Signal Management ********************************/
    451          /**
    452          * @brief  Set the specified Signal Flags of an active thread.
    453          * @param  thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    454          * @param  signals       specifies the signal flags of the thread that should be set.
    455          * @retval  osOK if successful, osErrorOS if failed .
    456          * @note   MUST REMAIN UNCHANGED: \b osSignalSet shall be consistent in every CMSIS-RTOS.
    457          */

   \                                 In section .text, align 2, keep-with-next
    458          int32_t osSignalSet (osThreadId thread_id, int32_t signal)
    459          {
   \                     osSignalSet: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    460          #if( configUSE_TASK_NOTIFICATIONS == 1 )	
    461            BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    462            
    463            if (inHandlerMode())
   \   0000000C   0x.... 0x....      BL       inHandlerMode
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD014             BEQ.N    ??osSignalSet_0
    464            {
    465              if(xTaskNotifyFromISR( thread_id, (uint32_t)signal, eSetBits, &xHigherPriorityTaskWoken ) != pdPASS )
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       xTaskGenericNotifyFromISR
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD001             BEQ.N    ??osSignalSet_1
    466                return osErrorOS;
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xE013             B.N      ??osSignalSet_2
    467          
    468              portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
   \                     ??osSignalSet_1: (+1)
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00F             BEQ.N    ??osSignalSet_3
   \   00000032   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   \   0000003C   0xE009             B.N      ??osSignalSet_3
    469            }  
    470            else if(xTaskNotify( thread_id, (uint32_t)signal, eSetBits) != pdPASS )
   \                     ??osSignalSet_0: (+1)
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       xTaskGenericNotify
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD001             BEQ.N    ??osSignalSet_3
    471            {
    472              return osErrorOS;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xE000             B.N      ??osSignalSet_2
    473            }
    474            
    475            return osOK;
   \                     ??osSignalSet_3: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??osSignalSet_2: (+1)
   \   00000054   0xBD3E             POP      {R1-R5,PC}       ;; return
    476          #else
    477            (void) thread_id;
    478            (void) signal;
    479          
    480            return osErrorOS; /* Task Notification not supported */ 	
    481          #endif
    482          }
    483          
    484          /**
    485          * @brief  Clear the specified Signal Flags of an active thread.
    486          * @param  thread_id  thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    487          * @param  signals    specifies the signal flags of the thread that shall be cleared.
    488          * @retval  previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
    489          * @note   MUST REMAIN UNCHANGED: \b osSignalClear shall be consistent in every CMSIS-RTOS.
    490          */
    491          int32_t osSignalClear (osThreadId thread_id, int32_t signal);
    492          
    493          /**
    494          * @brief  Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
    495          * @param  signals   wait until all specified signal flags set or 0 for any single signal flag.
    496          * @param  millisec  timeout value or 0 in case of no time-out.
    497          * @retval  event flag information or error code.
    498          * @note   MUST REMAIN UNCHANGED: \b osSignalWait shall be consistent in every CMSIS-RTOS.
    499          */

   \                                 In section .text, align 2, keep-with-next
    500          osEvent osSignalWait (int32_t signals, uint32_t millisec)
    501          {
   \                     osSignalWait: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
    502            osEvent ret;
    503          
    504          #if( configUSE_TASK_NOTIFICATIONS == 1 )
    505          	
    506            TickType_t ticks;
    507          
    508            ret.value.signals = 0;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    509            ticks = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0004             MOVS     R4,R0
    510            if (millisec == osWaitForever) {
   \   00000010   0xF115 0x0F01      CMN      R5,#+1
   \   00000014   0xD103             BNE.N    ??osSignalWait_0
    511              ticks = portMAX_DELAY;
   \   00000016   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xE009             B.N      ??osSignalWait_1
    512            }
    513            else if (millisec != 0) {
   \                     ??osSignalWait_0: (+1)
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD007             BEQ.N    ??osSignalWait_1
    514              ticks = millisec / portTICK_PERIOD_MS;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000028   0x0004             MOVS     R4,R0
    515              if (ticks == 0) {
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD101             BNE.N    ??osSignalWait_1
    516                ticks = 1;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x0004             MOVS     R4,R0
    517              }
    518            }  
    519            
    520            if (inHandlerMode())
   \                     ??osSignalWait_1: (+1)
   \   00000032   0x.... 0x....      BL       inHandlerMode
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ.N    ??osSignalWait_2
    521            {
    522              ret.status = osErrorISR;  /*Not allowed in ISR*/
   \   0000003A   0x2082             MOVS     R0,#+130
   \   0000003C   0x9000             STR      R0,[SP, #+0]
   \   0000003E   0xE017             B.N      ??osSignalWait_3
    523            }
    524            else
    525            {
    526              if(xTaskNotifyWait( 0,(uint32_t) signals, (uint32_t *)&ret.value.signals, ticks) != pdTRUE)
   \                     ??osSignalWait_2: (+1)
   \   00000040   0x0023             MOVS     R3,R4
   \   00000042   0xAA01             ADD      R2,SP,#+4
   \   00000044   0x0039             MOVS     R1,R7
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      BL       xTaskNotifyWait
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD007             BEQ.N    ??osSignalWait_4
    527              {
    528                if(ticks == 0)  ret.status = osOK;
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD102             BNE.N    ??osSignalWait_5
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0xE00A             B.N      ??osSignalWait_3
    529                else  ret.status = osEventTimeout;
   \                     ??osSignalWait_5: (+1)
   \   0000005A   0x2040             MOVS     R0,#+64
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xE007             B.N      ??osSignalWait_3
    530              }
    531              else if(ret.value.signals < 0)
   \                     ??osSignalWait_4: (+1)
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD502             BPL.N    ??osSignalWait_6
    532              {
    533                ret.status =  osErrorValue;     
   \   00000066   0x2086             MOVS     R0,#+134
   \   00000068   0x9000             STR      R0,[SP, #+0]
   \   0000006A   0xE001             B.N      ??osSignalWait_3
    534              }
    535              else  ret.status =  osEventSignal;
   \                     ??osSignalWait_6: (+1)
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0x9000             STR      R0,[SP, #+0]
    536            }
    537          #else
    538            (void) signals;
    539            (void) millisec;
    540          	
    541            ret.status =  osErrorOS;	/* Task Notification not supported */
    542          #endif
    543            
    544            return ret;
   \                     ??osSignalWait_3: (+1)
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000076   0xE886 0x000E      STM      R6,{R1-R3}
   \   0000007A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    545          }
    546          
    547          /****************************  Mutex Management ********************************/
    548          /**
    549          * @brief  Create and Initialize a Mutex object
    550          * @param  mutex_def     mutex definition referenced with \ref osMutex.
    551          * @retval  mutex ID for reference by other functions or NULL in case of error.
    552          * @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
    553          */

   \                                 In section .text, align 2, keep-with-next
    554          osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
    555          {
   \                     osMutexCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    556          #if ( configUSE_MUTEXES == 1)
    557            return xSemaphoreCreateMutex(); 
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    558          #else
    559          	return NULL;
    560          #endif
    561          }
    562          
    563          /**
    564          * @brief Wait until a Mutex becomes available
    565          * @param mutex_id      mutex ID obtained by \ref osMutexCreate.
    566          * @param millisec      timeout value or 0 in case of no time-out.
    567          * @retval  status code that indicates the execution status of the function.
    568          * @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
    569          */

   \                                 In section .text, align 2, keep-with-next
    570          osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
    571          {
   \                     osMutexWait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    572            TickType_t ticks;
    573            portBASE_TYPE taskWoken = pdFALSE;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    574            
    575            
    576            if (mutex_id == NULL) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??osMutexWait_0
    577              return osErrorParameter;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0xE033             B.N      ??osMutexWait_1
    578            }
    579            
    580            ticks = 0;
   \                     ??osMutexWait_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
    581            if (millisec == osWaitForever) {
   \   00000018   0xF115 0x0F01      CMN      R5,#+1
   \   0000001C   0xD103             BNE.N    ??osMutexWait_2
    582              ticks = portMAX_DELAY;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0xE009             B.N      ??osMutexWait_3
    583            }
    584            else if (millisec != 0) {
   \                     ??osMutexWait_2: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??osMutexWait_3
    585              ticks = millisec / portTICK_PERIOD_MS;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000030   0x0006             MOVS     R6,R0
    586              if (ticks == 0) {
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD101             BNE.N    ??osMutexWait_3
    587                ticks = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0006             MOVS     R6,R0
    588              }
    589            }
    590            
    591            if (inHandlerMode()) {
   \                     ??osMutexWait_3: (+1)
   \   0000003A   0x.... 0x....      BL       inHandlerMode
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD011             BEQ.N    ??osMutexWait_4
    592              if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
   \   00000042   0x466A             MOV      R2,SP
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       xQueueReceiveFromISR
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD001             BEQ.N    ??osMutexWait_5
    593                return osErrorOS;
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xE013             B.N      ??osMutexWait_1
    594              }
    595          	portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMutexWait_5: (+1)
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00F             BEQ.N    ??osMutexWait_6
   \   0000005A   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   00000062   0x6008             STR      R0,[R1, #+0]
   \   00000064   0xE009             B.N      ??osMutexWait_6
    596            } 
    597            else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
   \                     ??osMutexWait_4: (+1)
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x0032             MOVS     R2,R6
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       xQueueGenericReceive
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD001             BEQ.N    ??osMutexWait_6
    598              return osErrorOS;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0xE000             B.N      ??osMutexWait_1
    599            }
    600            
    601            return osOK;
   \                     ??osMutexWait_6: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??osMutexWait_1: (+1)
   \   0000007C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    602          }
    603          
    604          /**
    605          * @brief Release a Mutex that was obtained by \ref osMutexWait
    606          * @param mutex_id      mutex ID obtained by \ref osMutexCreate.
    607          * @retval  status code that indicates the execution status of the function.
    608          * @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
    609          */

   \                                 In section .text, align 2, keep-with-next
    610          osStatus osMutexRelease (osMutexId mutex_id)
    611          {
   \                     osMutexRelease: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    612            osStatus result = osOK;
   \   00000004   0x2500             MOVS     R5,#+0
    613            portBASE_TYPE taskWoken = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    614            
    615            if (inHandlerMode()) {
   \   0000000A   0x.... 0x....      BL       inHandlerMode
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD010             BEQ.N    ??osMutexRelease_0
    616              if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       xQueueGiveFromISR
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD001             BEQ.N    ??osMutexRelease_1
    617                return osErrorOS;
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0xE013             B.N      ??osMutexRelease_2
    618              }
    619              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMutexRelease_1: (+1)
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00F             BEQ.N    ??osMutexRelease_3
   \   00000028   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE009             B.N      ??osMutexRelease_3
    620            }
    621            else if (xSemaphoreGive(mutex_id) != pdTRUE) 
   \                     ??osMutexRelease_0: (+1)
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       xQueueGenericSend
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD001             BEQ.N    ??osMutexRelease_3
    622            {
    623              result = osErrorOS;
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0x0005             MOVS     R5,R0
    624            }
    625            return result;
   \                     ??osMutexRelease_3: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \                     ??osMutexRelease_2: (+1)
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    626          }
    627          
    628          /**
    629          * @brief Delete a Mutex
    630          * @param mutex_id  mutex ID obtained by \ref osMutexCreate.
    631          * @retval  status code that indicates the execution status of the function.
    632          * @note   MUST REMAIN UNCHANGED: \b osMutexDelete shall be consistent in every CMSIS-RTOS.
    633          */

   \                                 In section .text, align 2, keep-with-next
    634          osStatus osMutexDelete (osMutexId mutex_id)
    635          {
   \                     osMutexDelete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    636            if (inHandlerMode()) {
   \   00000004   0x.... 0x....      BL       inHandlerMode
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??osMutexDelete_0
    637              return osErrorISR;
   \   0000000C   0x2082             MOVS     R0,#+130
   \   0000000E   0xE003             B.N      ??osMutexDelete_1
    638            }
    639          
    640            vQueueDelete(mutex_id);
   \                     ??osMutexDelete_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       vQueueDelete
    641          
    642            return osOK;
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??osMutexDelete_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    643          }
    644          
    645          /********************  Semaphore Management Functions **************************/
    646          
    647          #if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))
    648          
    649          /**
    650          * @brief Create and Initialize a Semaphore object used for managing resources
    651          * @param semaphore_def semaphore definition referenced with \ref osSemaphore.
    652          * @param count         number of available resources.
    653          * @retval  semaphore ID for reference by other functions or NULL in case of error.
    654          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
    655          */

   \                                 In section .text, align 2, keep-with-next
    656          osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
    657          {
   \                     osSemaphoreCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
    658            (void) semaphore_def;
    659            osSemaphoreId sema;
    660            
    661            if (count == 1) {
   \   00000006   0x2E01             CMP      R6,#+1
   \   00000008   0xD10F             BNE.N    ??osSemaphoreCreate_0
    662              vSemaphoreCreateBinary(sema);
   \   0000000A   0x2203             MOVS     R2,#+3
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       xQueueGenericCreate
   \   00000014   0x0004             MOVS     R4,R0
   \   00000016   0x2C00             CMP      R4,#+0
   \   00000018   0xD005             BEQ.N    ??osSemaphoreCreate_1
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       xQueueGenericSend
    663              return sema;
   \                     ??osSemaphoreCreate_1: (+1)
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xE003             B.N      ??osSemaphoreCreate_2
    664            }
    665          
    666          #if (configUSE_COUNTING_SEMAPHORES == 1 )	
    667            return xSemaphoreCreateCounting(count, 0);
   \                     ??osSemaphoreCreate_0: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       xQueueCreateCountingSemaphore
   \                     ??osSemaphoreCreate_2: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return
    668          #else
    669            return NULL;
    670          #endif
    671          }
    672          
    673          /**
    674          * @brief Wait until a Semaphore token becomes available
    675          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    676          * @param  millisec      timeout value or 0 in case of no time-out.
    677          * @retval  number of available tokens, or -1 in case of incorrect parameters.
    678          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
    679          */

   \                                 In section .text, align 2, keep-with-next
    680          int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
    681          {
   \                     osSemaphoreWait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    682            TickType_t ticks;
    683            portBASE_TYPE taskWoken = pdFALSE;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9000             STR      R0,[SP, #+0]
    684            
    685            
    686            if (semaphore_id == NULL) {
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD101             BNE.N    ??osSemaphoreWait_0
    687              return osErrorParameter;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0xE033             B.N      ??osSemaphoreWait_1
    688            }
    689            
    690            ticks = 0;
   \                     ??osSemaphoreWait_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0006             MOVS     R6,R0
    691            if (millisec == osWaitForever) {
   \   00000018   0xF115 0x0F01      CMN      R5,#+1
   \   0000001C   0xD103             BNE.N    ??osSemaphoreWait_2
    692              ticks = portMAX_DELAY;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0x0006             MOVS     R6,R0
   \   00000024   0xE009             B.N      ??osSemaphoreWait_3
    693            }
    694            else if (millisec != 0) {
   \                     ??osSemaphoreWait_2: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD007             BEQ.N    ??osSemaphoreWait_3
    695              ticks = millisec / portTICK_PERIOD_MS;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   00000030   0x0006             MOVS     R6,R0
    696              if (ticks == 0) {
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD101             BNE.N    ??osSemaphoreWait_3
    697                ticks = 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0x0006             MOVS     R6,R0
    698              }
    699            }
    700            
    701            if (inHandlerMode()) {
   \                     ??osSemaphoreWait_3: (+1)
   \   0000003A   0x.... 0x....      BL       inHandlerMode
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD011             BEQ.N    ??osSemaphoreWait_4
    702              if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
   \   00000042   0x466A             MOV      R2,SP
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      BL       xQueueReceiveFromISR
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD001             BEQ.N    ??osSemaphoreWait_5
    703                return osErrorOS;
   \   00000050   0x20FF             MOVS     R0,#+255
   \   00000052   0xE013             B.N      ??osSemaphoreWait_1
    704              }
    705          	portEND_SWITCHING_ISR(taskWoken);
   \                     ??osSemaphoreWait_5: (+1)
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00F             BEQ.N    ??osSemaphoreWait_6
   \   0000005A   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   00000062   0x6008             STR      R0,[R1, #+0]
   \   00000064   0xE009             B.N      ??osSemaphoreWait_6
    706            }  
    707            else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
   \                     ??osSemaphoreWait_4: (+1)
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x0032             MOVS     R2,R6
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       xQueueGenericReceive
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD001             BEQ.N    ??osSemaphoreWait_6
    708              return osErrorOS;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0xE000             B.N      ??osSemaphoreWait_1
    709            }
    710            
    711            return osOK;
   \                     ??osSemaphoreWait_6: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??osSemaphoreWait_1: (+1)
   \   0000007C   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    712          }
    713          
    714          /**
    715          * @brief Release a Semaphore token
    716          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    717          * @retval  status code that indicates the execution status of the function.
    718          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
    719          */

   \                                 In section .text, align 2, keep-with-next
    720          osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
    721          {
   \                     osSemaphoreRelease: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    722            osStatus result = osOK;
   \   00000004   0x2500             MOVS     R5,#+0
    723            portBASE_TYPE taskWoken = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    724            
    725            
    726            if (inHandlerMode()) {
   \   0000000A   0x.... 0x....      BL       inHandlerMode
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD010             BEQ.N    ??osSemaphoreRelease_0
    727              if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       xQueueGiveFromISR
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD001             BEQ.N    ??osSemaphoreRelease_1
    728                return osErrorOS;
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0xE013             B.N      ??osSemaphoreRelease_2
    729              }
    730              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osSemaphoreRelease_1: (+1)
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00F             BEQ.N    ??osSemaphoreRelease_3
   \   00000028   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0xE009             B.N      ??osSemaphoreRelease_3
    731            }
    732            else {
    733              if (xSemaphoreGive(semaphore_id) != pdTRUE) {
   \                     ??osSemaphoreRelease_0: (+1)
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       xQueueGenericSend
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD001             BEQ.N    ??osSemaphoreRelease_3
    734                result = osErrorOS;
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0x0005             MOVS     R5,R0
    735              }
    736            }
    737            
    738            return result;
   \                     ??osSemaphoreRelease_3: (+1)
   \   00000048   0x0028             MOVS     R0,R5
   \                     ??osSemaphoreRelease_2: (+1)
   \   0000004A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    739          }
    740          
    741          /**
    742          * @brief Delete a Semaphore
    743          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    744          * @retval  status code that indicates the execution status of the function.
    745          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
    746          */

   \                                 In section .text, align 2, keep-with-next
    747          osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
    748          {
   \                     osSemaphoreDelete: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    749            if (inHandlerMode()) {
   \   00000004   0x.... 0x....      BL       inHandlerMode
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??osSemaphoreDelete_0
    750              return osErrorISR;
   \   0000000C   0x2082             MOVS     R0,#+130
   \   0000000E   0xE003             B.N      ??osSemaphoreDelete_1
    751            }
    752          
    753            vSemaphoreDelete(semaphore_id);
   \                     ??osSemaphoreDelete_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       vQueueDelete
    754          
    755            return osOK; 
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??osSemaphoreDelete_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    756          }
    757          
    758          #endif    /* Use Semaphores */
    759          
    760          /*******************   Memory Pool Management Functions  ***********************/
    761          
    762          #if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0)) 
    763          
    764          //TODO
    765          //This is a primitive and inefficient wrapper around the existing FreeRTOS memory management.
    766          //A better implementation will have to modify heap_x.c!
    767          
    768          
    769          typedef struct os_pool_cb {
    770            void *pool;
    771            uint8_t *markers;
    772            uint32_t pool_sz;
    773            uint32_t item_sz;
    774            uint32_t currentIndex;
    775          } os_pool_cb_t;
    776          
    777          
    778          /**
    779          * @brief Create and Initialize a memory pool
    780          * @param  pool_def      memory pool definition referenced with \ref osPool.
    781          * @retval  memory pool ID for reference by other functions or NULL in case of error.
    782          * @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
    783          */

   \                                 In section .text, align 2, keep-with-next
    784          osPoolId osPoolCreate (const osPoolDef_t *pool_def)
    785          {
   \                     osPoolCreate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
    786            osPoolId thePool;
    787            int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
   \   00000004   0x6868             LDR      R0,[R5, #+4]
   \   00000006   0x1CC0             ADDS     R0,R0,#+3
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x0086             LSLS     R6,R0,#+2
    788            uint32_t i;
    789            
    790            /* First have to allocate memory for the pool control block. */
    791            thePool = pvPortMalloc(sizeof(os_pool_cb_t));
   \   0000000C   0x2014             MOVS     R0,#+20
   \   0000000E   0x.... 0x....      BL       pvPortMalloc
   \   00000012   0x0004             MOVS     R4,R0
    792            if (thePool) {
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD02B             BEQ.N    ??osPoolCreate_0
    793              thePool->pool_sz = pool_def->pool_sz;
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x60A0             STR      R0,[R4, #+8]
    794              thePool->item_sz = itemSize;
   \   0000001C   0x60E6             STR      R6,[R4, #+12]
    795              thePool->currentIndex = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6120             STR      R0,[R4, #+16]
    796              
    797              /* Memory for markers */
    798              thePool->markers = pvPortMalloc(pool_def->pool_sz);
   \   00000022   0x6828             LDR      R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       pvPortMalloc
   \   00000028   0x6060             STR      R0,[R4, #+4]
    799              if (thePool->markers) {
   \   0000002A   0x6860             LDR      R0,[R4, #+4]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD01A             BEQ.N    ??osPoolCreate_1
    800                /* Now allocate the pool itself. */
    801                thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
   \   00000030   0x6828             LDR      R0,[R5, #+0]
   \   00000032   0x4370             MULS     R0,R6,R0
   \   00000034   0x.... 0x....      BL       pvPortMalloc
   \   00000038   0x6020             STR      R0,[R4, #+0]
    802                
    803                if (thePool->pool) {
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD009             BEQ.N    ??osPoolCreate_2
    804                  for (i = 0; i < pool_def->pool_sz; i++) {
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0007             MOVS     R7,R0
   \                     ??osPoolCreate_3: (+1)
   \   00000044   0x6828             LDR      R0,[R5, #+0]
   \   00000046   0x4287             CMP      R7,R0
   \   00000048   0xD212             BCS.N    ??osPoolCreate_0
    805                    thePool->markers[i] = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6861             LDR      R1,[R4, #+4]
   \   0000004E   0x55C8             STRB     R0,[R1, R7]
    806                  }
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \   00000052   0xE7F7             B.N      ??osPoolCreate_3
    807                }
    808                else {
    809                  vPortFree(thePool->markers);
   \                     ??osPoolCreate_2: (+1)
   \   00000054   0x6860             LDR      R0,[R4, #+4]
   \   00000056   0x.... 0x....      BL       vPortFree
    810                  vPortFree(thePool);
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       vPortFree
    811                  thePool = NULL;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0004             MOVS     R4,R0
   \   00000064   0xE004             B.N      ??osPoolCreate_0
    812                }
    813              }
    814              else {
    815                vPortFree(thePool);
   \                     ??osPoolCreate_1: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       vPortFree
    816                thePool = NULL;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x0004             MOVS     R4,R0
    817              }
    818            }
    819            
    820            return thePool;
   \                     ??osPoolCreate_0: (+1)
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    821          }
    822          
    823          /**
    824          * @brief Allocate a memory block from a memory pool
    825          * @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
    826          * @retval  address of the allocated memory block or NULL in case of no memory available.
    827          * @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
    828          */

   \                                 In section .text, align 2, keep-with-next
    829          void *osPoolAlloc (osPoolId pool_id)
    830          {
   \                     osPoolAlloc: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    831            int dummy = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    832            void *p = NULL;
   \   00000008   0x2600             MOVS     R6,#+0
    833            uint32_t i;
    834            uint32_t index;
    835            
    836            if (inHandlerMode()) {
   \   0000000A   0x.... 0x....      BL       inHandlerMode
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??osPoolAlloc_0
    837              dummy = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000012   0x.... 0x....      BL       ulPortSetInterruptMask
   \   00000016   0x0005             MOVS     R5,R0
   \   00000018   0xE001             B.N      ??osPoolAlloc_1
    838            }
    839            else {
    840              vPortEnterCritical();
   \                     ??osPoolAlloc_0: (+1)
   \   0000001A   0x.... 0x....      BL       vPortEnterCritical
    841            }
    842            
    843            for (i = 0; i < pool_id->pool_sz; i++) {
   \                     ??osPoolAlloc_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0007             MOVS     R7,R0
   \                     ??osPoolAlloc_2: (+1)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x4287             CMP      R7,R0
   \   00000026   0xD21A             BCS.N    ??osPoolAlloc_3
    844              index = pool_id->currentIndex + i;
   \   00000028   0x6920             LDR      R0,[R4, #+16]
   \   0000002A   0x1838             ADDS     R0,R7,R0
   \   0000002C   0x4680             MOV      R8,R0
    845              if (index >= pool_id->pool_sz) {
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x4580             CMP      R8,R0
   \   00000032   0xD301             BCC.N    ??osPoolAlloc_4
    846                index = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4680             MOV      R8,R0
    847              }
    848              
    849              if (pool_id->markers[index] == 0) {
   \                     ??osPoolAlloc_4: (+1)
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0xF810 0x0008      LDRB     R0,[R0, R8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10B             BNE.N    ??osPoolAlloc_5
    850                pool_id->markers[index] = 1;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x6861             LDR      R1,[R4, #+4]
   \   00000046   0xF801 0x0008      STRB     R0,[R1, R8]
    851                p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x68E0             LDR      R0,[R4, #+12]
   \   0000004E   0xFB00 0x1108      MLA      R1,R0,R8,R1
   \   00000052   0x000E             MOVS     R6,R1
    852                pool_id->currentIndex = index;
   \   00000054   0xF8C4 0x8010      STR      R8,[R4, #+16]
    853                break;
   \   00000058   0xE001             B.N      ??osPoolAlloc_3
    854              }
    855            }
   \                     ??osPoolAlloc_5: (+1)
   \   0000005A   0x1C7F             ADDS     R7,R7,#+1
   \   0000005C   0xE7E1             B.N      ??osPoolAlloc_2
    856            
    857            if (inHandlerMode()) {
   \                     ??osPoolAlloc_3: (+1)
   \   0000005E   0x.... 0x....      BL       inHandlerMode
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD003             BEQ.N    ??osPoolAlloc_6
    858              portCLEAR_INTERRUPT_MASK_FROM_ISR(dummy);
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0x.... 0x....      BL       vPortClearInterruptMask
   \   0000006C   0xE001             B.N      ??osPoolAlloc_7
    859            }
    860            else {
    861              vPortExitCritical();
   \                     ??osPoolAlloc_6: (+1)
   \   0000006E   0x.... 0x....      BL       vPortExitCritical
    862            }
    863            
    864            return p;
   \                     ??osPoolAlloc_7: (+1)
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    865          }
    866          
    867          /**
    868          * @brief Allocate a memory block from a memory pool and set memory block to zero
    869          * @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
    870          * @retval  address of the allocated memory block or NULL in case of no memory available.
    871          * @note   MUST REMAIN UNCHANGED: \b osPoolCAlloc shall be consistent in every CMSIS-RTOS.
    872          */

   \                                 In section .text, align 2, keep-with-next
    873          void *osPoolCAlloc (osPoolId pool_id)
    874          {
   \                     osPoolCAlloc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
    875            void *p = osPoolAlloc(pool_id);
   \   00000004   0x0028             MOVS     R0,R5
   \   00000006   0x.... 0x....      BL       osPoolAlloc
   \   0000000A   0x0004             MOVS     R4,R0
    876            
    877            if (p != NULL)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD006             BEQ.N    ??osPoolCAlloc_0
    878            {
    879              memset(p, 0, sizeof(pool_id->pool_sz));
   \   00000010   0x2604             MOVS     R6,#+4
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0x003A             MOVS     R2,R7
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       __aeabi_memset
    880            }
    881            
    882            return p;
   \                     ??osPoolCAlloc_0: (+1)
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    883          }
    884          
    885          /**
    886          * @brief Return an allocated memory block back to a specific memory pool
    887          * @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
    888          * @param  block         address of the allocated memory block that is returned to the memory pool.
    889          * @retval  status code that indicates the execution status of the function.
    890          * @note   MUST REMAIN UNCHANGED: \b osPoolFree shall be consistent in every CMSIS-RTOS.
    891          */

   \                                 In section .text, align 2, keep-with-next
    892          osStatus osPoolFree (osPoolId pool_id, void *block)
    893          {
   \                     osPoolFree: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    894            uint32_t index;
    895            
    896            if (pool_id == NULL) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??osPoolFree_0
    897              return osErrorParameter;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0xE020             B.N      ??osPoolFree_1
    898            }
    899            
    900            if (block == NULL) {
   \                     ??osPoolFree_0: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??osPoolFree_2
    901              return osErrorParameter;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0xE01C             B.N      ??osPoolFree_1
    902            }
    903            
    904            if (block < pool_id->pool) {
   \                     ??osPoolFree_2: (+1)
   \   00000014   0x6810             LDR      R0,[R2, #+0]
   \   00000016   0x4281             CMP      R1,R0
   \   00000018   0xD201             BCS.N    ??osPoolFree_3
    905              return osErrorParameter;
   \   0000001A   0x2080             MOVS     R0,#+128
   \   0000001C   0xE017             B.N      ??osPoolFree_1
    906            }
    907            
    908            index = (uint32_t)block - (uint32_t)(pool_id->pool);
   \                     ??osPoolFree_3: (+1)
   \   0000001E   0x6810             LDR      R0,[R2, #+0]
   \   00000020   0x1A08             SUBS     R0,R1,R0
   \   00000022   0x0003             MOVS     R3,R0
    909            if (index % pool_id->item_sz) {
   \   00000024   0x68D0             LDR      R0,[R2, #+12]
   \   00000026   0xFBB3 0xF4F0      UDIV     R4,R3,R0
   \   0000002A   0xFB00 0x3014      MLS      R0,R0,R4,R3
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD001             BEQ.N    ??osPoolFree_4
    910              return osErrorParameter;
   \   00000032   0x2080             MOVS     R0,#+128
   \   00000034   0xE00B             B.N      ??osPoolFree_1
    911            }
    912            index = index / pool_id->item_sz;
   \                     ??osPoolFree_4: (+1)
   \   00000036   0x68D0             LDR      R0,[R2, #+12]
   \   00000038   0xFBB3 0xF3F0      UDIV     R3,R3,R0
    913            if (index >= pool_id->pool_sz) {
   \   0000003C   0x6890             LDR      R0,[R2, #+8]
   \   0000003E   0x4283             CMP      R3,R0
   \   00000040   0xD301             BCC.N    ??osPoolFree_5
    914              return osErrorParameter;
   \   00000042   0x2080             MOVS     R0,#+128
   \   00000044   0xE003             B.N      ??osPoolFree_1
    915            }
    916            
    917            pool_id->markers[index] = 0;
   \                     ??osPoolFree_5: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6854             LDR      R4,[R2, #+4]
   \   0000004A   0x54E0             STRB     R0,[R4, R3]
    918            
    919            return osOK;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??osPoolFree_1: (+1)
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    920          }
    921          
    922          
    923          #endif   /* Use Memory Pool Management */
    924          
    925          /*******************   Message Queue Management Functions  *********************/
    926          
    927          #if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0)) /* Use Message Queues */
    928          
    929          /**
    930          * @brief Create and Initialize a Message Queue
    931          * @param queue_def     queue definition referenced with \ref osMessageQ.
    932          * @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
    933          * @retval  message queue ID for reference by other functions or NULL in case of error.
    934          * @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
    935          */

   \                                 In section .text, align 2, keep-with-next
    936          osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
    937          {
   \                     osMessageCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    938            (void) thread_id;
    939            
    940            return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x6841             LDR      R1,[R0, #+4]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x.... 0x....      BL       xQueueGenericCreate
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    941          }
    942          
    943          /**
    944          * @brief Put a Message to a Queue.
    945          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
    946          * @param  info      message information.
    947          * @param  millisec  timeout value or 0 in case of no time-out.
    948          * @retval status code that indicates the execution status of the function.
    949          * @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
    950          */

   \                                 In section .text, align 2, keep-with-next
    951          osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
    952          {
   \                     osMessagePut: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x0016             MOVS     R6,R2
    953            portBASE_TYPE taskWoken = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9000             STR      R0,[SP, #+0]
    954            TickType_t ticks;
    955            
    956            ticks = millisec / portTICK_PERIOD_MS;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000010   0x0004             MOVS     R4,R0
    957            if (ticks == 0) {
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD101             BNE.N    ??osMessagePut_0
    958              ticks = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x0004             MOVS     R4,R0
    959            }
    960            
    961            if (inHandlerMode()) {
   \                     ??osMessagePut_0: (+1)
   \   0000001A   0x.... 0x....      BL       inHandlerMode
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD012             BEQ.N    ??osMessagePut_1
    962              if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x466A             MOV      R2,SP
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       xQueueGenericSendFromISR
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD001             BEQ.N    ??osMessagePut_2
    963                return osErrorOS;
   \   00000032   0x20FF             MOVS     R0,#+255
   \   00000034   0xE013             B.N      ??osMessagePut_3
    964              }
    965              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMessagePut_2: (+1)
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD00F             BEQ.N    ??osMessagePut_4
   \   0000003C   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable10  ;; 0xe000ed04
   \   00000044   0x6008             STR      R0,[R1, #+0]
   \   00000046   0xE009             B.N      ??osMessagePut_4
    966            }
    967            else {
    968              if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
   \                     ??osMessagePut_1: (+1)
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0x0022             MOVS     R2,R4
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x0028             MOVS     R0,R5
   \   00000050   0x.... 0x....      BL       xQueueGenericSend
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xD001             BEQ.N    ??osMessagePut_4
    969                return osErrorOS;
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0xE000             B.N      ??osMessagePut_3
    970              }
    971            }
    972            
    973            return osOK;
   \                     ??osMessagePut_4: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \                     ??osMessagePut_3: (+1)
   \   0000005E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    974          }
    975          
    976          /**
    977          * @brief Get a Message or Wait for a Message from a Queue.
    978          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
    979          * @param  millisec  timeout value or 0 in case of no time-out.
    980          * @retval event information that includes status code.
    981          * @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
    982          */

   \                                 In section .text, align 2, keep-with-next
    983          osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
    984          {
   \                     osMessageGet: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    985            portBASE_TYPE taskWoken;
    986            TickType_t ticks;
    987            osEvent event;
    988            
    989            event.def.message_id = queue_id;
   \   0000000A   0x9502             STR      R5,[SP, #+8]
    990            event.value.v = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9001             STR      R0,[SP, #+4]
    991            
    992            if (queue_id == NULL) {
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD107             BNE.N    ??osMessageGet_0
    993              event.status = osErrorParameter;
   \   00000014   0x2080             MOVS     R0,#+128
   \   00000016   0x9000             STR      R0,[SP, #+0]
    994              return event;
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0xE890 0x000E      LDM      R0,{R1-R3}
   \   0000001E   0xE887 0x000E      STM      R7,{R1-R3}
   \   00000022   0xE042             B.N      ??osMessageGet_1
    995            }
    996            
    997            taskWoken = pdFALSE;
   \                     ??osMessageGet_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x9003             STR      R0,[SP, #+12]
    998            
    999            ticks = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x0004             MOVS     R4,R0
   1000            if (millisec == osWaitForever) {
   \   0000002C   0xF116 0x0F01      CMN      R6,#+1
   \   00000030   0xD103             BNE.N    ??osMessageGet_2
   1001              ticks = portMAX_DELAY;
   \   00000032   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000036   0x0004             MOVS     R4,R0
   \   00000038   0xE009             B.N      ??osMessageGet_3
   1002            }
   1003            else if (millisec != 0) {
   \                     ??osMessageGet_2: (+1)
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD007             BEQ.N    ??osMessageGet_3
   1004              ticks = millisec / portTICK_PERIOD_MS;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000044   0x0004             MOVS     R4,R0
   1005              if (ticks == 0) {
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD101             BNE.N    ??osMessageGet_3
   1006                ticks = 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x0004             MOVS     R4,R0
   1007              }
   1008            }
   1009            
   1010            if (inHandlerMode()) {
   \                     ??osMessageGet_3: (+1)
   \   0000004E   0x.... 0x....      BL       inHandlerMode
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD013             BEQ.N    ??osMessageGet_4
   1011              if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
   \   00000056   0xAA03             ADD      R2,SP,#+12
   \   00000058   0xA901             ADD      R1,SP,#+4
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       xQueueReceiveFromISR
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD102             BNE.N    ??osMessageGet_5
   1012                /* We have mail */
   1013                event.status = osEventMessage;
   \   00000064   0x2010             MOVS     R0,#+16
   \   00000066   0x9000             STR      R0,[SP, #+0]
   \   00000068   0xE001             B.N      ??osMessageGet_6
   1014              }
   1015              else {
   1016                event.status = osOK;
   \                     ??osMessageGet_5: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   1017              }
   1018              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMessageGet_6: (+1)
   \   0000006E   0x9803             LDR      R0,[SP, #+12]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD015             BEQ.N    ??osMessageGet_7
   \   00000074   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000078   0x....             LDR.N    R1,??DataTable10  ;; 0xe000ed04
   \   0000007A   0x6008             STR      R0,[R1, #+0]
   \   0000007C   0xE010             B.N      ??osMessageGet_7
   1019            }
   1020            else {
   1021              if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
   \                     ??osMessageGet_4: (+1)
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0x0022             MOVS     R2,R4
   \   00000082   0xA901             ADD      R1,SP,#+4
   \   00000084   0x0028             MOVS     R0,R5
   \   00000086   0x.... 0x....      BL       xQueueGenericReceive
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD102             BNE.N    ??osMessageGet_8
   1022                /* We have mail */
   1023                event.status = osEventMessage;
   \   0000008E   0x2010             MOVS     R0,#+16
   \   00000090   0x9000             STR      R0,[SP, #+0]
   \   00000092   0xE005             B.N      ??osMessageGet_7
   1024              }
   1025              else {
   1026                event.status = (ticks == 0) ? osOK : osEventTimeout;
   \                     ??osMessageGet_8: (+1)
   \   00000094   0x2C00             CMP      R4,#+0
   \   00000096   0xD101             BNE.N    ??osMessageGet_9
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE000             B.N      ??osMessageGet_10
   \                     ??osMessageGet_9: (+1)
   \   0000009C   0x2040             MOVS     R0,#+64
   \                     ??osMessageGet_10: (+1)
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   1027              }
   1028            }
   1029            
   1030            return event;
   \                     ??osMessageGet_7: (+1)
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0xE890 0x000E      LDM      R0,{R1-R3}
   \   000000A6   0xE887 0x000E      STM      R7,{R1-R3}
   \                     ??osMessageGet_1: (+1)
   \   000000AA   0xB005             ADD      SP,SP,#+20
   \   000000AC   0xBDF0             POP      {R4-R7,PC}       ;; return
   1031          }
   1032          
   1033          #endif     /* Use Message Queues */
   1034          
   1035          /********************   Mail Queue Management Functions  ***********************/
   1036          #if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))  /* Use Mail Queues */
   1037          
   1038          
   1039          typedef struct os_mailQ_cb {
   1040            const osMailQDef_t *queue_def;
   1041            QueueHandle_t handle;
   1042            osPoolId pool;
   1043          } os_mailQ_cb_t;
   1044          
   1045          /**
   1046          * @brief Create and Initialize mail queue
   1047          * @param  queue_def     reference to the mail queue definition obtain with \ref osMailQ
   1048          * @param   thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
   1049          * @retval mail queue ID for reference by other functions or NULL in case of error.
   1050          * @note   MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS.
   1051          */

   \                                 In section .text, align 2, keep-with-next
   1052          osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
   1053          {
   \                     osMailCreate: (+1)
   \   00000000   0xB53E             PUSH     {R1-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1054            (void) thread_id;
   1055            
   1056            osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0xE880 0x000E      STM      R0,{R1-R3}
   \   00000012   0x6820             LDR      R0,[R4, #+0]
   \   00000014   0x9000             STR      R0,[SP, #+0]
   \   00000016   0x6860             LDR      R0,[R4, #+4]
   \   00000018   0x9001             STR      R0,[SP, #+4]
   1057            
   1058            
   1059            /* Create a mail queue control block */
   1060            *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
   \   0000001A   0x200C             MOVS     R0,#+12
   \   0000001C   0x.... 0x....      BL       pvPortMalloc
   \   00000020   0x68A1             LDR      R1,[R4, #+8]
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1061            if (*(queue_def->cb) == NULL) {
   \   00000024   0x68A0             LDR      R0,[R4, #+8]
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE.N    ??osMailCreate_0
   1062              return NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xE028             B.N      ??osMailCreate_1
   1063            }
   1064            (*(queue_def->cb))->queue_def = queue_def;
   \                     ??osMailCreate_0: (+1)
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x6004             STR      R4,[R0, #+0]
   1065            
   1066            /* Create a queue in FreeRTOS */
   1067            (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x2104             MOVS     R1,#+4
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x.... 0x....      BL       xQueueGenericCreate
   \   00000040   0x68A1             LDR      R1,[R4, #+8]
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x6048             STR      R0,[R1, #+4]
   1068            if ((*(queue_def->cb))->handle == NULL) {
   \   00000046   0x68A0             LDR      R0,[R4, #+8]
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6840             LDR      R0,[R0, #+4]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD105             BNE.N    ??osMailCreate_2
   1069              vPortFree(*(queue_def->cb));
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       vPortFree
   1070              return NULL;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE012             B.N      ??osMailCreate_1
   1071            }
   1072            
   1073            /* Create a mail pool */
   1074            (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
   \                     ??osMailCreate_2: (+1)
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x.... 0x....      BL       osPoolCreate
   \   00000062   0x68A1             LDR      R1,[R4, #+8]
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6088             STR      R0,[R1, #+8]
   1075            if ((*(queue_def->cb))->pool == NULL) {
   \   00000068   0x68A0             LDR      R0,[R4, #+8]
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD105             BNE.N    ??osMailCreate_3
   1076              //TODO: Delete queue. How to do it in FreeRTOS?
   1077              vPortFree(*(queue_def->cb));
   \   00000072   0x68A0             LDR      R0,[R4, #+8]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x.... 0x....      BL       vPortFree
   1078              return NULL;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE001             B.N      ??osMailCreate_1
   1079            }
   1080            
   1081            return *(queue_def->cb);
   \                     ??osMailCreate_3: (+1)
   \   0000007E   0x68A0             LDR      R0,[R4, #+8]
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \                     ??osMailCreate_1: (+1)
   \   00000082   0xBD3E             POP      {R1-R5,PC}       ;; return
   1082          }

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0H
   \              0x00000000   
   \              0x00000000   
   1083          
   1084          /**
   1085          * @brief Allocate a memory block from a mail
   1086          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1087          * @param  millisec      timeout value or 0 in case of no time-out.
   1088          * @retval pointer to memory block that can be filled with mail or NULL in case error.
   1089          * @note   MUST REMAIN UNCHANGED: \b osMailAlloc shall be consistent in every CMSIS-RTOS.
   1090          */

   \                                 In section .text, align 2, keep-with-next
   1091          void *osMailAlloc (osMailQId queue_id, uint32_t millisec)
   1092          {
   \                     osMailAlloc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1093            (void) millisec;
   1094            void *p;
   1095            
   1096            
   1097            if (queue_id == NULL) {
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE.N    ??osMailAlloc_0
   1098              return NULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE004             B.N      ??osMailAlloc_1
   1099            }
   1100            
   1101            p = osPoolAlloc(queue_id->pool);
   \                     ??osMailAlloc_0: (+1)
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0x.... 0x....      BL       osPoolAlloc
   \   00000014   0x0006             MOVS     R6,R0
   1102            
   1103            return p;
   \   00000016   0x0030             MOVS     R0,R6
   \                     ??osMailAlloc_1: (+1)
   \   00000018   0xBD70             POP      {R4-R6,PC}       ;; return
   1104          }
   1105          
   1106          /**
   1107          * @brief Allocate a memory block from a mail and set memory block to zero
   1108          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1109          * @param  millisec      timeout value or 0 in case of no time-out.
   1110          * @retval pointer to memory block that can be filled with mail or NULL in case error.
   1111          * @note   MUST REMAIN UNCHANGED: \b osMailCAlloc shall be consistent in every CMSIS-RTOS.
   1112          */

   \                                 In section .text, align 2, keep-with-next
   1113          void *osMailCAlloc (osMailQId queue_id, uint32_t millisec)
   1114          {
   \                     osMailCAlloc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1115            uint32_t i;
   1116            void *p = osMailAlloc(queue_id, millisec);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       osMailAlloc
   1117            
   1118            if (p) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD007             BEQ.N    ??osMailCAlloc_0
   1119              for (i = 0; i < sizeof(queue_id->queue_def->item_sz); i++) {
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x000E             MOVS     R6,R1
   \                     ??osMailCAlloc_1: (+1)
   \   00000016   0x2E04             CMP      R6,#+4
   \   00000018   0xD203             BCS.N    ??osMailCAlloc_0
   1120                ((uint8_t *)p)[i] = 0;
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x5581             STRB     R1,[R0, R6]
   1121              }
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \   00000020   0xE7F9             B.N      ??osMailCAlloc_1
   1122            }
   1123            
   1124            return p;
   \                     ??osMailCAlloc_0: (+1)
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
   1125          }
   1126          
   1127          /**
   1128          * @brief Put a mail to a queue
   1129          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1130          * @param  mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
   1131          * @retval status code that indicates the execution status of the function.
   1132          * @note   MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS.
   1133          */

   \                                 In section .text, align 2, keep-with-next
   1134          osStatus osMailPut (osMailQId queue_id, void *mail)
   1135          {
   \                     osMailPut: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1136            portBASE_TYPE taskWoken;
   1137            
   1138            
   1139            if (queue_id == NULL) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE.N    ??osMailPut_0
   1140              return osErrorParameter;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0xE022             B.N      ??osMailPut_1
   1141            }
   1142            
   1143            taskWoken = pdFALSE;
   \                     ??osMailPut_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   1144            
   1145            if (inHandlerMode()) {
   \   00000010   0x.... 0x....      BL       inHandlerMode
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD011             BEQ.N    ??osMailPut_2
   1146              if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x466A             MOV      R2,SP
   \   0000001C   0xA901             ADD      R1,SP,#+4
   \   0000001E   0x6860             LDR      R0,[R4, #+4]
   \   00000020   0x.... 0x....      BL       xQueueGenericSendFromISR
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD001             BEQ.N    ??osMailPut_3
   1147                return osErrorOS;
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xE012             B.N      ??osMailPut_1
   1148              }
   1149              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMailPut_3: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00E             BEQ.N    ??osMailPut_4
   \   00000032   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000036   0x....             LDR.N    R1,??DataTable10  ;; 0xe000ed04
   \   00000038   0x6008             STR      R0,[R1, #+0]
   \   0000003A   0xE009             B.N      ??osMailPut_4
   1150            }
   1151            else {
   1152              if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
   \                     ??osMailPut_2: (+1)
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0xA901             ADD      R1,SP,#+4
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0x.... 0x....      BL       xQueueGenericSend
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD001             BEQ.N    ??osMailPut_4
   1153                return osErrorOS;
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0xE000             B.N      ??osMailPut_1
   1154              }
   1155            }
   1156            
   1157            return osOK;
   \                     ??osMailPut_4: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??osMailPut_1: (+1)
   \   00000052   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1158          }
   1159          
   1160          /**
   1161          * @brief Get a mail from a queue
   1162          * @param  queue_id   mail queue ID obtained with \ref osMailCreate.
   1163          * @param millisec    timeout value or 0 in case of no time-out
   1164          * @retval event that contains mail information or error code.
   1165          * @note   MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS.
   1166          */

   \                                 In section .text, align 2, keep-with-next
   1167          osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
   1168          {
   \                     osMailGet: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1169            portBASE_TYPE taskWoken;
   1170            TickType_t ticks;
   1171            osEvent event;
   1172            
   1173            event.def.mail_id = queue_id;
   \   0000000A   0x9503             STR      R5,[SP, #+12]
   1174            
   1175            if (queue_id == NULL) {
   \   0000000C   0x2D00             CMP      R5,#+0
   \   0000000E   0xD107             BNE.N    ??osMailGet_0
   1176              event.status = osErrorParameter;
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x9001             STR      R0,[SP, #+4]
   1177              return event;
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0xE890 0x000E      LDM      R0,{R1-R3}
   \   0000001A   0xE887 0x000E      STM      R7,{R1-R3}
   \   0000001E   0xE042             B.N      ??osMailGet_1
   1178            }
   1179            
   1180            taskWoken = pdFALSE;
   \                     ??osMailGet_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9000             STR      R0,[SP, #+0]
   1181            
   1182            ticks = 0;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x0004             MOVS     R4,R0
   1183            if (millisec == osWaitForever) {
   \   00000028   0xF116 0x0F01      CMN      R6,#+1
   \   0000002C   0xD103             BNE.N    ??osMailGet_2
   1184              ticks = portMAX_DELAY;
   \   0000002E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xE009             B.N      ??osMailGet_3
   1185            }
   1186            else if (millisec != 0) {
   \                     ??osMailGet_2: (+1)
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD007             BEQ.N    ??osMailGet_3
   1187              ticks = millisec / portTICK_PERIOD_MS;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000040   0x0004             MOVS     R4,R0
   1188              if (ticks == 0) {
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD101             BNE.N    ??osMailGet_3
   1189                ticks = 1;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x0004             MOVS     R4,R0
   1190              }
   1191            }
   1192            
   1193            if (inHandlerMode()) {
   \                     ??osMailGet_3: (+1)
   \   0000004A   0x.... 0x....      BL       inHandlerMode
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD013             BEQ.N    ??osMailGet_4
   1194              if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
   \   00000052   0x466A             MOV      R2,SP
   \   00000054   0xA902             ADD      R1,SP,#+8
   \   00000056   0x6868             LDR      R0,[R5, #+4]
   \   00000058   0x.... 0x....      BL       xQueueReceiveFromISR
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD102             BNE.N    ??osMailGet_5
   1195                /* We have mail */
   1196                event.status = osEventMail;
   \   00000060   0x2020             MOVS     R0,#+32
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0xE001             B.N      ??osMailGet_6
   1197              }
   1198              else {
   1199                event.status = osOK;
   \                     ??osMailGet_5: (+1)
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9001             STR      R0,[SP, #+4]
   1200              }
   1201              portEND_SWITCHING_ISR(taskWoken);
   \                     ??osMailGet_6: (+1)
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD015             BEQ.N    ??osMailGet_7
   \   00000070   0xF05F 0x5080      MOVS     R0,#+268435456
   \   00000074   0x....             LDR.N    R1,??DataTable10  ;; 0xe000ed04
   \   00000076   0x6008             STR      R0,[R1, #+0]
   \   00000078   0xE010             B.N      ??osMailGet_7
   1202            }
   1203            else {
   1204              if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
   \                     ??osMailGet_4: (+1)
   \   0000007A   0x2300             MOVS     R3,#+0
   \   0000007C   0x0022             MOVS     R2,R4
   \   0000007E   0xA902             ADD      R1,SP,#+8
   \   00000080   0x6868             LDR      R0,[R5, #+4]
   \   00000082   0x.... 0x....      BL       xQueueGenericReceive
   \   00000086   0x2801             CMP      R0,#+1
   \   00000088   0xD102             BNE.N    ??osMailGet_8
   1205                /* We have mail */
   1206                event.status = osEventMail;
   \   0000008A   0x2020             MOVS     R0,#+32
   \   0000008C   0x9001             STR      R0,[SP, #+4]
   \   0000008E   0xE005             B.N      ??osMailGet_7
   1207              }
   1208              else {
   1209                event.status = (ticks == 0) ? osOK : osEventTimeout;
   \                     ??osMailGet_8: (+1)
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD101             BNE.N    ??osMailGet_9
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE000             B.N      ??osMailGet_10
   \                     ??osMailGet_9: (+1)
   \   00000098   0x2040             MOVS     R0,#+64
   \                     ??osMailGet_10: (+1)
   \   0000009A   0x9001             STR      R0,[SP, #+4]
   1210              }
   1211            }
   1212            
   1213            return event;
   \                     ??osMailGet_7: (+1)
   \   0000009C   0xA801             ADD      R0,SP,#+4
   \   0000009E   0xE890 0x000E      LDM      R0,{R1-R3}
   \   000000A2   0xE887 0x000E      STM      R7,{R1-R3}
   \                     ??osMailGet_1: (+1)
   \   000000A6   0xB005             ADD      SP,SP,#+20
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1214          }
   1215          
   1216          /**
   1217          * @brief Free a memory block from a mail
   1218          * @param  queue_id mail queue ID obtained with \ref osMailCreate.
   1219          * @param  mail     pointer to the memory block that was obtained with \ref osMailGet.
   1220          * @retval status code that indicates the execution status of the function.
   1221          * @note   MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS.
   1222          */

   \                                 In section .text, align 2, keep-with-next
   1223          osStatus osMailFree (osMailQId queue_id, void *mail)
   1224          {
   \                     osMailFree: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0002             MOVS     R2,R0
   1225            if (queue_id == NULL) {
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD101             BNE.N    ??osMailFree_0
   1226              return osErrorParameter;
   \   00000008   0x2080             MOVS     R0,#+128
   \   0000000A   0xE002             B.N      ??osMailFree_1
   1227            }
   1228            
   1229            return osPoolFree(queue_id->pool, mail);
   \                     ??osMailFree_0: (+1)
   \   0000000C   0x6890             LDR      R0,[R2, #+8]
   \   0000000E   0x.... 0x....      BL       osPoolFree
   \                     ??osMailFree_1: (+1)
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
   1230          }
   1231          #endif  /* Use Mail Queues */
   1232          
   1233          /*************************** Additional specific APIs to Free RTOS ************/
   1234          /**
   1235          * @brief  Handles the tick increment
   1236          * @param  none.
   1237          * @retval none.
   1238          */

   \                                 In section .text, align 2, keep-with-next
   1239          void osSystickHandler(void)
   1240          {
   \                     osSystickHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1241          
   1242          #if (INCLUDE_xTaskGetSchedulerState  == 1 )
   1243            if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
   \   00000002   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD001             BEQ.N    ??osSystickHandler_0
   1244            {
   1245          #endif  /* INCLUDE_xTaskGetSchedulerState */  
   1246              xPortSysTickHandler();
   \   0000000A   0x.... 0x....      BL       xPortSysTickHandler
   1247          #if (INCLUDE_xTaskGetSchedulerState  == 1 )
   1248            }
   1249          #endif  /* INCLUDE_xTaskGetSchedulerState */  
   1250          }
   \                     ??osSystickHandler_0: (+1)
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
   1251          
   1252          #if ( INCLUDE_eTaskGetState == 1 )
   1253          /**
   1254          * @brief  Obtain the state of any thread.
   1255          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1256          * @retval  the stae of the thread, states are encoded by the osThreadState enumerated type.
   1257          */

   \                                 In section .text, align 2, keep-with-next
   1258          osThreadState osThreadGetState(osThreadId thread_id)
   1259          {
   \                     osThreadGetState: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1260            eTaskState ThreadState;
   1261            osThreadState result;
   1262            
   1263            ThreadState = eTaskGetState(thread_id);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       eTaskGetState
   \   0000000A   0x0005             MOVS     R5,R0
   1264            
   1265            switch (ThreadState)
   \   0000000C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD006             BEQ.N    ??osThreadGetState_0
   \   00000012   0x2D02             CMP      R5,#+2
   \   00000014   0xD00A             BEQ.N    ??osThreadGetState_1
   \   00000016   0xD306             BCC.N    ??osThreadGetState_2
   \   00000018   0x2D04             CMP      R5,#+4
   \   0000001A   0xD00D             BEQ.N    ??osThreadGetState_3
   \   0000001C   0xD309             BCC.N    ??osThreadGetState_4
   \   0000001E   0xE00E             B.N      ??osThreadGetState_5
   1266            {
   1267            case eRunning :
   1268              result = osThreadRunning;
   \                     ??osThreadGetState_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x0006             MOVS     R6,R0
   1269              break;
   \   00000024   0xE00E             B.N      ??osThreadGetState_6
   1270            case eReady :
   1271              result = osThreadReady;
   \                     ??osThreadGetState_2: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x0006             MOVS     R6,R0
   1272              break;
   \   0000002A   0xE00B             B.N      ??osThreadGetState_6
   1273            case eBlocked :
   1274              result = osThreadBlocked;
   \                     ??osThreadGetState_1: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x0006             MOVS     R6,R0
   1275              break;
   \   00000030   0xE008             B.N      ??osThreadGetState_6
   1276            case eSuspended :
   1277              result = osThreadSuspended;
   \                     ??osThreadGetState_4: (+1)
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x0006             MOVS     R6,R0
   1278              break;
   \   00000036   0xE005             B.N      ??osThreadGetState_6
   1279            case eDeleted :
   1280              result = osThreadDeleted;
   \                     ??osThreadGetState_3: (+1)
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x0006             MOVS     R6,R0
   1281              break;
   \   0000003C   0xE002             B.N      ??osThreadGetState_6
   1282            default:
   1283              result = osThreadError;
   \                     ??osThreadGetState_5: (+1)
   \   0000003E   0xF07F 0x4000      MVNS     R0,#-2147483648
   \   00000042   0x0006             MOVS     R6,R0
   1284            } 
   1285            
   1286            return result;
   \                     ??osThreadGetState_6: (+1)
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
   1287          }
   1288          #endif /* INCLUDE_eTaskGetState */
   1289          
   1290          #if (INCLUDE_eTaskGetState == 1)
   1291          /**
   1292          * @brief Check if a thread is already suspended or not.
   1293          * @param thread_id thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1294          * @retval status code that indicates the execution status of the function.
   1295          */

   \                                 In section .text, align 2, keep-with-next
   1296          osStatus osThreadIsSuspended(osThreadId thread_id)
   1297          {
   \                     osThreadIsSuspended: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1298            if (eTaskGetState(thread_id) == eSuspended)
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       eTaskGetState
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD101             BNE.N    ??osThreadIsSuspended_0
   1299              return osOK;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE000             B.N      ??osThreadIsSuspended_1
   1300            else
   1301              return osErrorOS;
   \                     ??osThreadIsSuspended_0: (+1)
   \   00000012   0x20FF             MOVS     R0,#+255
   \                     ??osThreadIsSuspended_1: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1302          }
   1303          #endif /* INCLUDE_eTaskGetState */
   1304          /**
   1305          * @brief  Suspend execution of a thread.
   1306          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1307          * @retval  status code that indicates the execution status of the function.
   1308          */

   \                                 In section .text, align 2, keep-with-next
   1309          osStatus osThreadSuspend (osThreadId thread_id)
   1310          {
   \                     osThreadSuspend: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1311          #if (INCLUDE_vTaskSuspend == 1)
   1312              vTaskSuspend(thread_id);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       vTaskSuspend
   1313            
   1314            return osOK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
   1315          #else
   1316            return osErrorResource;
   1317          #endif
   1318          }
   1319          
   1320          /**
   1321          * @brief  Resume execution of a suspended thread.
   1322          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1323          * @retval  status code that indicates the execution status of the function.
   1324          */

   \                                 In section .text, align 2, keep-with-next
   1325          osStatus osThreadResume (osThreadId thread_id)
   1326          {
   \                     osThreadResume: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1327          #if (INCLUDE_vTaskSuspend == 1)  
   1328            if(inHandlerMode())
   \   00000004   0x.... 0x....      BL       inHandlerMode
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD009             BEQ.N    ??osThreadResume_0
   1329            {
   1330              if (xTaskResumeFromISR(thread_id) == pdTRUE)
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       xTaskResumeFromISR
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD107             BNE.N    ??osThreadResume_1
   1331              {
   1332                portYIELD_FROM_ISR(pdTRUE);
   \   00000016   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000001A   0x....             LDR.N    R1,??DataTable10  ;; 0xe000ed04
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE002             B.N      ??osThreadResume_1
   1333              }
   1334            }
   1335            else
   1336            {
   1337              vTaskResume(thread_id);
   \                     ??osThreadResume_0: (+1)
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0x.... 0x....      BL       vTaskResume
   1338            }
   1339            return osOK;
   \                     ??osThreadResume_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
   1340          #else
   1341            return osErrorResource;
   1342          #endif
   1343          }
   1344          
   1345          /**
   1346          * @brief  Suspend execution of a all active threads.
   1347          * @retval  status code that indicates the execution status of the function.
   1348          */

   \                                 In section .text, align 2, keep-with-next
   1349          osStatus osThreadSuspendAll (void)
   1350          {
   \                     osThreadSuspendAll: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1351            vTaskSuspendAll();
   \   00000002   0x.... 0x....      BL       vTaskSuspendAll
   1352            
   1353            return osOK;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
   1354          }
   1355          
   1356          /**
   1357          * @brief  Resume execution of a all suspended threads.
   1358          * @retval  status code that indicates the execution status of the function.
   1359          */

   \                                 In section .text, align 2, keep-with-next
   1360          osStatus osThreadResumeAll (void)
   1361          {
   \                     osThreadResumeAll: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1362            if (xTaskResumeAll() == pdTRUE)
   \   00000002   0x.... 0x....      BL       xTaskResumeAll
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD101             BNE.N    ??osThreadResumeAll_0
   1363              return osOK;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE000             B.N      ??osThreadResumeAll_1
   1364            else
   1365              return osErrorOS;
   \                     ??osThreadResumeAll_0: (+1)
   \   0000000E   0x20FF             MOVS     R0,#+255
   \                     ??osThreadResumeAll_1: (+1)
   \   00000010   0xBD02             POP      {R1,PC}          ;; return
   1366            
   1367          }
   1368          
   1369          /**
   1370          * @brief  Delay a task until a specified time
   1371          * @param   PreviousWakeTime   Pointer to a variable that holds the time at which the 
   1372          *          task was last unblocked. PreviousWakeTime must be initialised with the current time
   1373          *          prior to its first use (PreviousWakeTime = osKernelSysTick() )
   1374          * @param   millisec    time delay value
   1375          * @retval  status code that indicates the execution status of the function.
   1376          */

   \                                 In section .text, align 2, keep-with-next
   1377          osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)
   1378          {
   \                     osDelayUntil: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
   1379          #if INCLUDE_vTaskDelayUntil
   1380            TickType_t ticks = (millisec / portTICK_PERIOD_MS);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xFBB6 0xF4F0      UDIV     R4,R6,R0
   1381            vTaskDelayUntil((TickType_t *) PreviousWakeTime, ticks ? ticks : 1);
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??osDelayUntil_0
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xE000             B.N      ??osDelayUntil_1
   \                     ??osDelayUntil_0: (+1)
   \   00000014   0x2101             MOVS     R1,#+1
   \                     ??osDelayUntil_1: (+1)
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       vTaskDelayUntil
   1382            
   1383            return osOK;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   1384          #else
   1385            (void) millisec;
   1386            (void) PreviousWakeTime;
   1387            
   1388            return osErrorResource;
   1389          #endif
   1390          }
   1391          
   1392          /**
   1393          * @brief   Lists all the current threads, along with their current state 
   1394          *          and stack usage high water mark.
   1395          * @param   buffer   A buffer into which the above mentioned details
   1396          *          will be written
   1397          * @retval  status code that indicates the execution status of the function.
   1398          */

   \                                 In section .text, align 2, keep-with-next
   1399          osStatus osThreadList (uint8_t *buffer)
   1400          {
   \                     osThreadList: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1401          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   1402            vTaskList((char *)buffer);
   1403          #endif
   1404            return osOK;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x4770             BX       LR               ;; return
   1405          }
   1406          
   1407          /**
   1408          * @brief  Receive an item from a queue without removing the item from the queue.
   1409          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1410          * @param  millisec  timeout value or 0 in case of no time-out.
   1411          * @retval event information that includes status code.
   1412          */

   \                                 In section .text, align 2, keep-with-next
   1413          osEvent osMessagePeek (osMessageQId queue_id, uint32_t millisec)
   1414          {
   \                     osMessagePeek: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1415            TickType_t ticks;
   1416            osEvent event;
   1417            
   1418            event.def.message_id = queue_id;
   \   00000008   0x9502             STR      R5,[SP, #+8]
   1419            
   1420            if (queue_id == NULL) {
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD107             BNE.N    ??osMessagePeek_0
   1421              event.status = osErrorParameter;
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x9000             STR      R0,[SP, #+0]
   1422              return event;
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000018   0xE887 0x000E      STM      R7,{R1-R3}
   \   0000001C   0xE028             B.N      ??osMessagePeek_1
   1423            }
   1424            
   1425            ticks = 0;
   \                     ??osMessagePeek_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0004             MOVS     R4,R0
   1426            if (millisec == osWaitForever) {
   \   00000022   0xF116 0x0F01      CMN      R6,#+1
   \   00000026   0xD103             BNE.N    ??osMessagePeek_2
   1427              ticks = portMAX_DELAY;
   \   00000028   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000002C   0x0004             MOVS     R4,R0
   \   0000002E   0xE009             B.N      ??osMessagePeek_3
   1428            }
   1429            else if (millisec != 0) {
   \                     ??osMessagePeek_2: (+1)
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD007             BEQ.N    ??osMessagePeek_3
   1430              ticks = millisec / portTICK_PERIOD_MS;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   0000003A   0x0004             MOVS     R4,R0
   1431              if (ticks == 0) {
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD101             BNE.N    ??osMessagePeek_3
   1432                ticks = 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x0004             MOVS     R4,R0
   1433              }
   1434            }
   1435            
   1436            if (xQueuePeek(queue_id, &event.value.v, ticks) == pdTRUE) 
   \                     ??osMessagePeek_3: (+1)
   \   00000044   0x2301             MOVS     R3,#+1
   \   00000046   0x0022             MOVS     R2,R4
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       xQueueGenericReceive
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD102             BNE.N    ??osMessagePeek_4
   1437            {
   1438              /* We have mail */
   1439              event.status = osEventMessage;
   \   00000054   0x2010             MOVS     R0,#+16
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0xE005             B.N      ??osMessagePeek_5
   1440            }
   1441            else 
   1442            {
   1443              event.status = (ticks == 0) ? osOK : osEventTimeout;
   \                     ??osMessagePeek_4: (+1)
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD101             BNE.N    ??osMessagePeek_6
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE000             B.N      ??osMessagePeek_7
   \                     ??osMessagePeek_6: (+1)
   \   00000062   0x2040             MOVS     R0,#+64
   \                     ??osMessagePeek_7: (+1)
   \   00000064   0x9000             STR      R0,[SP, #+0]
   1444            }
   1445            
   1446            return event;
   \                     ??osMessagePeek_5: (+1)
   \   00000066   0x4668             MOV      R0,SP
   \   00000068   0xE890 0x000E      LDM      R0,{R1-R3}
   \   0000006C   0xE887 0x000E      STM      R7,{R1-R3}
   \                     ??osMessagePeek_1: (+1)
   \   00000070   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   1447          }
   1448          
   1449          /**
   1450          * @brief  Create and Initialize a Recursive Mutex
   1451          * @param  mutex_def     mutex definition referenced with \ref osMutex.
   1452          * @retval  mutex ID for reference by other functions or NULL in case of error..
   1453          */

   \                                 In section .text, align 2, keep-with-next
   1454          osMutexId osRecursiveMutexCreate (const osMutexDef_t *mutex_def)
   1455          {
   \                     osRecursiveMutexCreate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1456            (void) mutex_def;
   1457          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1458            return xSemaphoreCreateRecursiveMutex();
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       xQueueCreateMutex
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
   1459          #else
   1460            return NULL;
   1461          #endif	
   1462          }
   1463          
   1464          /**
   1465          * @brief  Release a Recursive Mutex
   1466          * @param   mutex_id      mutex ID obtained by \ref osRecursiveMutexCreate.
   1467          * @retval  status code that indicates the execution status of the function.
   1468          */

   \                                 In section .text, align 2, keep-with-next
   1469          osStatus osRecursiveMutexRelease (osMutexId mutex_id)
   1470          {
   \                     osRecursiveMutexRelease: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1471          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1472            osStatus result = osOK;
   \   00000004   0x2500             MOVS     R5,#+0
   1473           
   1474            if (xSemaphoreGiveRecursive(mutex_id) != pdTRUE) 
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       xQueueGiveMutexRecursive
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD001             BEQ.N    ??osRecursiveMutexRelease_0
   1475            {
   1476              result = osErrorOS;
   \   00000010   0x20FF             MOVS     R0,#+255
   \   00000012   0x0005             MOVS     R5,R0
   1477            }
   1478            return result;
   \                     ??osRecursiveMutexRelease_0: (+1)
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1479          #else
   1480          	return osErrorResource;
   1481          #endif
   1482          }
   1483          
   1484          /**
   1485          * @brief  Release a Recursive Mutex
   1486          * @param   mutex_id    mutex ID obtained by \ref osRecursiveMutexCreate.
   1487          * @param millisec      timeout value or 0 in case of no time-out.
   1488          * @retval  status code that indicates the execution status of the function.
   1489          */

   \                                 In section .text, align 2, keep-with-next
   1490          osStatus osRecursiveMutexWait (osMutexId mutex_id, uint32_t millisec)
   1491          {
   \                     osRecursiveMutexWait: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000D             MOVS     R5,R1
   1492          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1493            TickType_t ticks;
   1494            
   1495            if (mutex_id == NULL)
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD101             BNE.N    ??osRecursiveMutexWait_0
   1496            {
   1497              return osErrorParameter;
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0xE01B             B.N      ??osRecursiveMutexWait_1
   1498            }
   1499            
   1500            ticks = 0;
   \                     ??osRecursiveMutexWait_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x0004             MOVS     R4,R0
   1501            if (millisec == osWaitForever) 
   \   00000012   0xF115 0x0F01      CMN      R5,#+1
   \   00000016   0xD103             BNE.N    ??osRecursiveMutexWait_2
   1502            {
   1503              ticks = portMAX_DELAY;
   \   00000018   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000001C   0x0004             MOVS     R4,R0
   \   0000001E   0xE009             B.N      ??osRecursiveMutexWait_3
   1504            }
   1505            else if (millisec != 0) 
   \                     ??osRecursiveMutexWait_2: (+1)
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD007             BEQ.N    ??osRecursiveMutexWait_3
   1506            {
   1507              ticks = millisec / portTICK_PERIOD_MS;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xFBB5 0xF0F0      UDIV     R0,R5,R0
   \   0000002A   0x0004             MOVS     R4,R0
   1508              if (ticks == 0) 
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD101             BNE.N    ??osRecursiveMutexWait_3
   1509              {
   1510                ticks = 1;
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x0004             MOVS     R4,R0
   1511              }
   1512            }
   1513            
   1514            if (xSemaphoreTakeRecursive(mutex_id, ticks) != pdTRUE) 
   \                     ??osRecursiveMutexWait_3: (+1)
   \   00000034   0x0021             MOVS     R1,R4
   \   00000036   0x0030             MOVS     R0,R6
   \   00000038   0x.... 0x....      BL       xQueueTakeMutexRecursive
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD001             BEQ.N    ??osRecursiveMutexWait_4
   1515            {
   1516              return osErrorOS;
   \   00000040   0x20FF             MOVS     R0,#+255
   \   00000042   0xE000             B.N      ??osRecursiveMutexWait_1
   1517            }
   1518            return osOK;
   \                     ??osRecursiveMutexWait_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??osRecursiveMutexWait_1: (+1)
   \   00000046   0xBD70             POP      {R4-R6,PC}       ;; return
   1519          #else
   1520          	return osErrorResource;
   1521          #endif
   1522          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   inHandlerMode
       0   makeCmsisPriority
       0   makeFreeRtosPriority
      16   osDelay
        16   -> vTaskDelay
      16   osDelayUntil
        16   -> vTaskDelayUntil
       8   osKernelRunning
         8   -> xTaskGetSchedulerState
       8   osKernelStart
         8   -> vTaskStartScheduler
       8   osKernelSysTick
         8   -> inHandlerMode
         8   -> xTaskGetTickCount
         8   -> xTaskGetTickCountFromISR
      16   osMailAlloc
        16   -> osPoolAlloc
      16   osMailCAlloc
        16   -> osMailAlloc
      24   osMailCreate
        24   -> osPoolCreate
        24   -> pvPortMalloc
        24   -> vPortFree
        24   -> xQueueGenericCreate
       8   osMailFree
         8   -> osPoolFree
      40   osMailGet
        40   -> inHandlerMode
        40   -> xQueueGenericReceive
        40   -> xQueueReceiveFromISR
      16   osMailPut
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGenericSendFromISR
       8   osMessageCreate
         8   -> xQueueGenericCreate
      40   osMessageGet
        40   -> inHandlerMode
        40   -> xQueueGenericReceive
        40   -> xQueueReceiveFromISR
      32   osMessagePeek
        32   -> xQueueGenericReceive
      24   osMessagePut
        24   -> inHandlerMode
        24   -> xQueueGenericSend
        24   -> xQueueGenericSendFromISR
       8   osMutexCreate
         8   -> xQueueCreateMutex
       8   osMutexDelete
         8   -> inHandlerMode
         8   -> vQueueDelete
      16   osMutexRelease
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osMutexWait
        24   -> inHandlerMode
        24   -> xQueueGenericReceive
        24   -> xQueueReceiveFromISR
      24   osPoolAlloc
        24   -> inHandlerMode
        24   -> ulPortSetInterruptMask
        24   -> vPortClearInterruptMask
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      24   osPoolCAlloc
        24   -> __aeabi_memset
        24   -> osPoolAlloc
      24   osPoolCreate
        24   -> pvPortMalloc
        24   -> vPortFree
       4   osPoolFree
       8   osRecursiveMutexCreate
         8   -> xQueueCreateMutex
      16   osRecursiveMutexRelease
        16   -> xQueueGiveMutexRecursive
      16   osRecursiveMutexWait
        16   -> xQueueTakeMutexRecursive
      16   osSemaphoreCreate
        16   -> xQueueCreateCountingSemaphore
        16   -> xQueueGenericCreate
        16   -> xQueueGenericSend
       8   osSemaphoreDelete
         8   -> inHandlerMode
         8   -> vQueueDelete
      16   osSemaphoreRelease
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osSemaphoreWait
        24   -> inHandlerMode
        24   -> xQueueGenericReceive
        24   -> xQueueReceiveFromISR
      24   osSignalSet
        24   -> inHandlerMode
        24   -> xTaskGenericNotify
        24   -> xTaskGenericNotifyFromISR
      32   osSignalWait
        32   -> inHandlerMode
        32   -> xTaskNotifyWait
       8   osSystickHandler
         8   -> xPortSysTickHandler
         8   -> xTaskGetSchedulerState
      32   osThreadCreate
        32   -> makeFreeRtosPriority
        32   -> xTaskGenericCreate
       8   osThreadGetId
         8   -> xTaskGetCurrentTaskHandle
       8   osThreadGetPriority
         8   -> inHandlerMode
         8   -> makeCmsisPriority
         8   -> uxTaskPriorityGet
         8   -> uxTaskPriorityGetFromISR
      16   osThreadGetState
        16   -> eTaskGetState
       8   osThreadIsSuspended
         8   -> eTaskGetState
       0   osThreadList
       8   osThreadResume
         8   -> inHandlerMode
         8   -> vTaskResume
         8   -> xTaskResumeFromISR
       8   osThreadResumeAll
         8   -> xTaskResumeAll
      16   osThreadSetPriority
        16   -> makeFreeRtosPriority
        16   -> vTaskPrioritySet
       8   osThreadSuspend
         8   -> vTaskSuspend
       8   osThreadSuspendAll
         8   -> vTaskSuspendAll
       8   osThreadTerminate
         8   -> vTaskDelete
       8   osThreadYield
         8   -> vPortYield
       0   osTimerCreate
       0   osTimerDelete
       0   osTimerStart
       0   osTimerStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
      12  ?_0
      18  inHandlerMode
      18  makeCmsisPriority
      18  makeFreeRtosPriority
      28  osDelay
      32  osDelayUntil
      18  osKernelRunning
      10  osKernelStart
      22  osKernelSysTick
      26  osMailAlloc
      36  osMailCAlloc
     132  osMailCreate
      20  osMailFree
     170  osMailGet
      84  osMailPut
      16  osMessageCreate
     174  osMessageGet
     114  osMessagePeek
      96  osMessagePut
      12  osMutexCreate
      26  osMutexDelete
      76  osMutexRelease
     126  osMutexWait
     120  osPoolAlloc
      34  osPoolCAlloc
     116  osPoolCreate
      82  osPoolFree
      12  osRecursiveMutexCreate
      24  osRecursiveMutexRelease
      72  osRecursiveMutexWait
      52  osSemaphoreCreate
      26  osSemaphoreDelete
      76  osSemaphoreRelease
     126  osSemaphoreWait
      86  osSignalSet
     124  osSignalWait
      16  osSystickHandler
      58  osThreadCreate
       8  osThreadGetId
      36  osThreadGetPriority
      72  osThreadGetState
      22  osThreadIsSuspended
       6  osThreadList
      42  osThreadResume
      18  osThreadResumeAll
      26  osThreadSetPriority
      14  osThreadSuspend
      10  osThreadSuspendAll
      14  osThreadTerminate
      10  osThreadYield
       6  osTimerCreate
      10  osTimerDelete
      10  osTimerStart
      10  osTimerStop

 
    12 bytes in section .rodata
 2 614 bytes in section .text
 
 2 614 bytes of CODE  memory
    12 bytes of CONST memory

Errors: none
Warnings: none
