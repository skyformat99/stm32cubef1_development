###############################################################################
#
# IAR ANSI C/C++ Compiler V8.11.1.13263/W32 for ARM       14/Apr/2017  11:26:47
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.c
#    Command line =  
#        -f C:\Users\wkxbo\AppData\Local\Temp\EWD042.tmp
#        (D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.c
#        -D USE_HAL_DRIVER -D STM32F103xB -D USE_STM3210C_wkxboot -lC
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List
#        -lA
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List
#        -o
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.0\arm\INC\c\DLib_Config_Full.h"
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\Inc\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Drivers\BSP\STM3210C_EVAL\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\portable\IAR\ARM_CM3\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\
#        -I
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\..\..\..\..\..\..\Middlewares\Third_Party\FreeRTOS\Source\include\
#        -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\src\flashloader\NXP\FlashQN9080\chip_qn908x\cmsis\" -On
#        --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Include\")
#    Locale       =  C
#    List file    =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\List\stm32f1xx_hal_rcc.lst
#    Object file  =  
#        D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\app\freertos\FreeRTOS_multi_task\EWARM\debug\Obj\stm32f1xx_hal_rcc.o
#
###############################################################################

D:\development\stm32\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_rcc.c
      4            * @author  MCD Application Team
      5            * @version V1.0.4
      6            * @date    29-April-2016
      7            * @brief   RCC HAL module driver.
      8            *          This file provides firmware functions to manage the following 
      9            *          functionalities of the Reset and Clock Control (RCC) peripheral:
     10            *           + Initialization and de-initialization functions
     11            *           + Peripheral Control functions
     12            *       
     13            @verbatim                
     14            ==============================================================================
     15                                ##### RCC specific features #####
     16            ==============================================================================
     17              [..]  
     18                After reset the device is running from Internal High Speed oscillator
     19                (HSI 8MHz) with Flash 0 wait state, Flash prefetch buffer is enabled, 
     20                and all peripherals are off except internal SRAM, Flash and JTAG.
     21                (+) There is no prescaler on High speed (AHB) and Low speed (APB) buses;
     22                    all peripherals mapped on these buses are running at HSI speed.
     23                (+) The clock for all peripherals is switched off, except the SRAM and FLASH.
     24                (+) All GPIOs are in input floating state, except the JTAG pins which
     25                    are assigned to be used for debug purpose.
     26              [..] Once the device started from reset, the user application has to:
     27                (+) Configure the clock source to be used to drive the System clock
     28                    (if the application needs higher frequency/performance)
     29                (+) Configure the System clock frequency and Flash settings  
     30                (+) Configure the AHB and APB buses prescalers
     31                (+) Enable the clock for the peripheral(s) to be used
     32                (+) Configure the clock source(s) for peripherals whose clocks are not
     33                    derived from the System clock (I2S, RTC, ADC, USB OTG FS) 
     34          
     35                                ##### RCC Limitations #####
     36            ==============================================================================
     37              [..]  
     38                A delay between an RCC peripheral clock enable and the effective peripheral 
     39                enabling should be taken into account in order to manage the peripheral read/write 
     40                from/to registers.
     41                (+) This delay depends on the peripheral mapping.
     42                  (++) AHB & APB peripherals, 1 dummy read is necessary
     43          
     44              [..]  
     45                Workarounds:
     46                (#) For AHB & APB peripherals, a dummy read to the peripheral register has been
     47                    inserted in each __HAL_RCC_PPP_CLK_ENABLE() macro.
     48          
     49            @endverbatim
     50            ******************************************************************************
     51            * @attention
     52            *
     53            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     54            *
     55            * Redistribution and use in source and binary forms, with or without modification,
     56            * are permitted provided that the following conditions are met:
     57            *   1. Redistributions of source code must retain the above copyright notice,
     58            *      this list of conditions and the following disclaimer.
     59            *   2. Redistributions in binary form must reproduce the above copyright notice,
     60            *      this list of conditions and the following disclaimer in the documentation
     61            *      and/or other materials provided with the distribution.
     62            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     63            *      may be used to endorse or promote products derived from this software
     64            *      without specific prior written permission.
     65            *
     66            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     67            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     68            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     69            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     70            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     71            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     72            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     73            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     74            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     75            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     76            *
     77            ******************************************************************************  
     78          */
     79            
     80          /* Includes ------------------------------------------------------------------*/
     81          #include "stm32f1xx_hal.h"
     82          
     83          /** @addtogroup STM32F1xx_HAL_Driver
     84            * @{
     85            */
     86          
     87          /** @defgroup RCC RCC
     88          * @brief RCC HAL module driver
     89            * @{
     90            */
     91          
     92          #ifdef HAL_RCC_MODULE_ENABLED
     93          
     94          /* Private typedef -----------------------------------------------------------*/
     95          /* Private define ------------------------------------------------------------*/
     96          /** @defgroup RCC_Private_Constants RCC Private Constants
     97           * @{
     98           */
     99          /* Bits position in  in the CFGR register */
    100          #define RCC_CFGR_HPRE_BITNUMBER           POSITION_VAL(RCC_CFGR_HPRE)
    101          #define RCC_CFGR_PPRE1_BITNUMBER          POSITION_VAL(RCC_CFGR_PPRE1)
    102          #define RCC_CFGR_PPRE2_BITNUMBER          POSITION_VAL(RCC_CFGR_PPRE2)
    103          /**
    104            * @}
    105            */
    106          /* Private macro -------------------------------------------------------------*/
    107          /** @defgroup RCC_Private_Macros RCC Private Macros
    108            * @{
    109            */
    110          
    111          #define MCO1_CLK_ENABLE()     __HAL_RCC_GPIOA_CLK_ENABLE()
    112          #define MCO1_GPIO_PORT        GPIOA
    113          #define MCO1_PIN              GPIO_PIN_8
    114          
    115          /**
    116            * @}
    117            */
    118          
    119          /* Private variables ---------------------------------------------------------*/
    120          /** @defgroup RCC_Private_Variables RCC Private Variables
    121            * @{
    122            */
    123          /**
    124            * @}
    125            */
    126          
    127          /* Private function prototypes -----------------------------------------------*/
    128          /* Exported functions ---------------------------------------------------------*/
    129          
    130          /** @defgroup RCC_Exported_Functions RCC Exported Functions
    131            * @{
    132            */
    133          
    134          /** @defgroup RCC_Exported_Functions_Group1 Initialization and de-initialization functions 
    135            *  @brief    Initialization and Configuration functions 
    136            *
    137            @verbatim    
    138            ===============================================================================
    139                     ##### Initialization and de-initialization functions #####
    140            ===============================================================================
    141              [..]
    142                This section provides functions allowing to configure the internal/external oscillators
    143                (HSE, HSI, LSE, LSI, PLL, CSS and MCO) and the System buses clocks (SYSCLK, AHB, APB1
    144                and APB2).
    145          
    146              [..] Internal/external clock and PLL configuration
    147                (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly or through
    148                    the PLL as System clock source.
    149                (#) LSI (low-speed internal), ~40 KHz low consumption RC used as IWDG and/or RTC
    150                    clock source.
    151          
    152                (#) HSE (high-speed external), 4 to 24 MHz (STM32F100xx) or 4 to 16 MHz (STM32F101x/STM32F102x/STM32F103x) or 3 to 25 MHz (STM32F105x/STM32F107x)  crystal oscillator used directly or
    153                    through the PLL as System clock source. Can be used also as RTC clock source.
    154          
    155                (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.   
    156          
    157                (#) PLL (clocked by HSI or HSE), featuring different output clocks:
    158                  (++) The first output is used to generate the high speed system clock (up to 72 MHz for STM32F10xxx or up to 24 MHz for STM32F100xx)
    159                  (++) The second output is used to generate the clock for the USB OTG FS (48 MHz)
    160          
    161                (#) CSS (Clock security system), once enable using the macro __HAL_RCC_CSS_ENABLE()
    162                    and if a HSE clock failure occurs(HSE used directly or through PLL as System 
    163                    clock source), the System clocks automatically switched to HSI and an interrupt
    164                    is generated if enabled. The interrupt is linked to the Cortex-M3 NMI 
    165                    (Non-Maskable Interrupt) exception vector.   
    166          
    167                (#) MCO1 (microcontroller clock output), used to output SYSCLK, HSI,  
    168                    HSE or PLL clock (divided by 2) on PA8 pin + PLL2CLK, PLL3CLK/2, PLL3CLK and XTI for STM32F105x/STM32F107x
    169          
    170              [..] System, AHB and APB buses clocks configuration
    171                (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
    172                    HSE and PLL.
    173                    The AHB clock (HCLK) is derived from System clock through configurable
    174                    prescaler and used to clock the CPU, memory and peripherals mapped
    175                    on AHB bus (DMA, GPIO...). APB1 (PCLK1) and APB2 (PCLK2) clocks are derived
    176                    from AHB clock through configurable prescalers and used to clock
    177                    the peripherals mapped on these buses. You can use
    178                    "@ref HAL_RCC_GetSysClockFreq()" function to retrieve the frequencies of these clocks.
    179          
    180                -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
    181                    (+@) RTC: RTC clock can be derived either from the LSI, LSE or HSE clock
    182                        divided by 128. 
    183                    (+@) USB OTG FS and RTC: USB OTG FS require a frequency equal to 48 MHz
    184                        to work correctly. This clock is derived of the main PLL through PLL Multiplier.
    185                    (+@) I2S interface on STM32F105x/STM32F107x can be derived from PLL3CLK
    186                    (+@) IWDG clock which is always the LSI clock.
    187          
    188                (#) For STM32F10xxx, the maximum frequency of the SYSCLK and HCLK/PCLK2 is 72 MHz, PCLK1 36 MHz.
    189                    For STM32F100xx, the maximum frequency of the SYSCLK and HCLK/PCLK1/PCLK2 is 24 MHz.  
    190                    Depending on the SYSCLK frequency, the flash latency should be adapted accordingly.
    191            @endverbatim
    192            * @{
    193            */
    194            
    195          /*
    196            Additional consideration on the SYSCLK based on Latency settings:
    197                  +-----------------------------------------------+
    198                  | Latency       | SYSCLK clock frequency (MHz)  |
    199                  |---------------|-------------------------------|
    200                  |0WS(1CPU cycle)|       0 < SYSCLK <= 24        |
    201                  |---------------|-------------------------------|
    202                  |1WS(2CPU cycle)|      24 < SYSCLK <= 48        |
    203                  |---------------|-------------------------------|
    204                  |2WS(3CPU cycle)|      48 < SYSCLK <= 72        |
    205                  +-----------------------------------------------+
    206            */
    207          
    208          /**
    209            * @brief  Resets the RCC clock configuration to the default reset state.
    210            * @note   The default reset state of the clock configuration is given below:
    211            *            - HSI ON and used as system clock source
    212            *            - HSE and PLL OFF
    213            *            - AHB, APB1 and APB2 prescaler set to 1.
    214            *            - CSS and MCO1 OFF
    215            *            - All interrupts disabled
    216            * @note   This function does not modify the configuration of the
    217            *            - Peripheral clocks
    218            *            - LSI, LSE and RTC clocks
    219            * @retval None
    220            */

   \                                 In section .text, align 2, keep-with-next
    221          void HAL_RCC_DeInit(void)
    222          {
    223            /* Switch SYSCLK to HSI */
    224            CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW);
   \                     HAL_RCC_DeInit: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0880             LSRS     R0,R0,#+2
   \   00000008   0x0080             LSLS     R0,R0,#+2
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40021004
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    225          
    226            /* Reset HSEON, CSSON, & PLLON bits */
    227            CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12_2  ;; 0xfef6ffff
   \   0000001A   0x4001             ANDS     R1,R0,R1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000020   0x6001             STR      R1,[R0, #+0]
    228            
    229            /* Reset HSEBYP bit */
    230            CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   00000030   0x6008             STR      R0,[R1, #+0]
    231            
    232            /* Reset CFGR register */
    233            CLEAR_REG(RCC->CFGR);
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable12  ;; 0x40021004
   \   00000038   0x6008             STR      R0,[R1, #+0]
    234            
    235            /* Set HSITRIM bits to the reset value */
    236            MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, ((uint32_t)0x10 << POSITION_VAL(RCC_CR_HSITRIM)));
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0xF031 0x01F8      BICS     R1,R1,#0xF8
   \   00000044   0x2210             MOVS     R2,#+16
   \   00000046   0xF05F 0x50F8      MOVS     R0,#+520093696
   \   0000004A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000004E   0x4082             LSLS     R2,R2,R0
   \   00000050   0x4311             ORRS     R1,R2,R1
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000056   0x6001             STR      R1,[R0, #+0]
    237            
    238          #if (defined(STM32F105xC) || defined(STM32F107xC) || defined (STM32F100xB) || defined (STM32F100xE))
    239            /* Reset CFGR2 register */
    240            CLEAR_REG(RCC->CFGR2);
    241          
    242          #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
    243            /* Disable all interrupts */
    244            CLEAR_REG(RCC->CIR);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable12_3  ;; 0x40021008
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    245          
    246            /* Update the SystemCoreClock global variable */
    247            SystemCoreClock = HSI_VALUE;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x7a1200
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000068   0x6008             STR      R0,[R1, #+0]
    248          }
   \   0000006A   0x4770             BX       LR               ;; return
    249          
    250          /**
    251            * @brief  Initializes the RCC Oscillators according to the specified parameters in the
    252            *         RCC_OscInitTypeDef.
    253            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
    254            *         contains the configuration information for the RCC Oscillators.
    255            * @note   The PLL is not disabled when used as system clock.
    256            * @note   The PLL is not disabled when USB OTG FS clock is enabled (specific to devices with USB FS)
    257            * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
    258            *         supported by this macro. User should request a transition to LSE Off
    259            *         first and then LSE On or LSE Bypass.
    260            * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
    261            *         supported by this macro. User should request a transition to HSE Off
    262            *         first and then HSE On or HSE Bypass.
    263            * @retval HAL status
    264            */

   \                                 In section .text, align 2, keep-with-next
    265          HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
    266          {
   \                     HAL_RCC_OscConfig: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    267             uint32_t tickstart = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    268            
    269            /* Check the parameters */
    270            assert_param(RCC_OscInitStruct != NULL);
    271            assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
    272            
    273            /*------------------------------- HSE Configuration ------------------------*/ 
    274            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xF140 0x80D4      BPL.W    ??HAL_RCC_OscConfig_0
    275            {
    276              /* Check the parameters */
    277              assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    278                  
    279              /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    280              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
    281                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_1
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD12A             BNE.N    ??HAL_RCC_OscConfig_2
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x03C0             LSLS     R0,R0,#+15
   \   00000032   0xD525             BPL.N    ??HAL_RCC_OscConfig_2
    282              {
    283                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
   \                     ??HAL_RCC_OscConfig_1: (+1)
   \   00000034   0xF44F 0x4080      MOV      R0,#+16384
   \   00000038   0xFAB0 0xF080      CLZ      R0,R0
   \   0000003C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x0940             LSRS     R0,R0,#+5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD103             BNE.N    ??HAL_RCC_OscConfig_3
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xE006             B.N      ??HAL_RCC_OscConfig_4
   \                     ??HAL_RCC_OscConfig_3: (+1)
   \   00000052   0xF44F 0x4080      MOV      R0,#+16384
   \   00000056   0xFAB0 0xF080      CLZ      R0,R0
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_4: (+1)
   \   00000060   0xF44F 0x4180      MOV      R1,#+16384
   \   00000064   0xFAB1 0xF181      CLZ      R1,R1
   \   00000068   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000006C   0x40C8             LSRS     R0,R0,R1
   \   0000006E   0x07C0             LSLS     R0,R0,#+31
   \   00000070   0xF140 0x80A1      BPL.W    ??HAL_RCC_OscConfig_0
   \   00000074   0x6860             LDR      R0,[R4, #+4]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xF040 0x809D      BNE.W    ??HAL_RCC_OscConfig_0
    284                {
    285                  return HAL_ERROR;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xE339             B.N      ??HAL_RCC_OscConfig_5
    286                }
    287              }
    288              else
    289              {
    290                /* Set the new HSE configuration ---------------------------------------*/
    291                __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
   \                     ??HAL_RCC_OscConfig_2: (+1)
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \   00000082   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000086   0xD108             BNE.N    ??HAL_RCC_OscConfig_6
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   00000096   0x6008             STR      R0,[R1, #+0]
   \   00000098   0xE038             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_6: (+1)
   \   0000009A   0x6860             LDR      R0,[R4, #+4]
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD110             BNE.N    ??HAL_RCC_OscConfig_8
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0xE024             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_8: (+1)
   \   000000C2   0x6860             LDR      R0,[R4, #+4]
   \   000000C4   0xF5B0 0x2FA0      CMP      R0,#+327680
   \   000000C8   0xD110             BNE.N    ??HAL_RCC_OscConfig_9
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   000000D4   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000000D8   0x6008             STR      R0,[R1, #+0]
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000000E8   0x6008             STR      R0,[R1, #+0]
   \   000000EA   0xE00F             B.N      ??HAL_RCC_OscConfig_7
   \                     ??HAL_RCC_OscConfig_9: (+1)
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000F0   0x6800             LDR      R0,[R0, #+0]
   \   000000F2   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000000FA   0x6008             STR      R0,[R1, #+0]
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0xF430 0x2080      BICS     R0,R0,#0x40000
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   0000010A   0x6008             STR      R0,[R1, #+0]
    292                
    293          
    294                 /* Check the HSE State */
    295                if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
   \                     ??HAL_RCC_OscConfig_7: (+1)
   \   0000010C   0x6860             LDR      R0,[R4, #+4]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD028             BEQ.N    ??HAL_RCC_OscConfig_10
    296                {
    297                  /* Get Start Tick */
    298                  tickstart = HAL_GetTick();
   \   00000112   0x.... 0x....      BL       HAL_GetTick
   \   00000116   0x0005             MOVS     R5,R0
    299                  
    300                  /* Wait till HSE is ready */
    301                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_11: (+1)
   \   00000118   0xF44F 0x4080      MOV      R0,#+16384
   \   0000011C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000120   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x0940             LSRS     R0,R0,#+5
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x2801             CMP      R0,#+1
   \   0000012C   0xD103             BNE.N    ??HAL_RCC_OscConfig_12
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0xE006             B.N      ??HAL_RCC_OscConfig_13
   \                     ??HAL_RCC_OscConfig_12: (+1)
   \   00000136   0xF44F 0x4080      MOV      R0,#+16384
   \   0000013A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_13: (+1)
   \   00000144   0xF44F 0x4180      MOV      R1,#+16384
   \   00000148   0xFAB1 0xF181      CLZ      R1,R1
   \   0000014C   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000150   0x40C8             LSRS     R0,R0,R1
   \   00000152   0x07C0             LSLS     R0,R0,#+31
   \   00000154   0xD42F             BMI.N    ??HAL_RCC_OscConfig_0
    302                  {
    303                    if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   00000156   0x.... 0x....      BL       HAL_GetTick
   \   0000015A   0x1B40             SUBS     R0,R0,R5
   \   0000015C   0x2865             CMP      R0,#+101
   \   0000015E   0xD3DB             BCC.N    ??HAL_RCC_OscConfig_11
    304                    {
    305                      return HAL_TIMEOUT;
   \   00000160   0x2003             MOVS     R0,#+3
   \   00000162   0xE2C7             B.N      ??HAL_RCC_OscConfig_5
    306                    }
    307                  }
    308                }
    309                else
    310                {
    311                  /* Get Start Tick */
    312                  tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_10: (+1)
   \   00000164   0x.... 0x....      BL       HAL_GetTick
   \   00000168   0x0005             MOVS     R5,R0
    313                  
    314                  /* Wait till HSE is disabled */
    315                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_14: (+1)
   \   0000016A   0xF44F 0x4080      MOV      R0,#+16384
   \   0000016E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000172   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000176   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000178   0x0940             LSRS     R0,R0,#+5
   \   0000017A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017C   0x2801             CMP      R0,#+1
   \   0000017E   0xD103             BNE.N    ??HAL_RCC_OscConfig_15
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0xE006             B.N      ??HAL_RCC_OscConfig_16
   \                     ??HAL_RCC_OscConfig_15: (+1)
   \   00000188   0xF44F 0x4080      MOV      R0,#+16384
   \   0000018C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_16: (+1)
   \   00000196   0xF44F 0x4180      MOV      R1,#+16384
   \   0000019A   0xFAB1 0xF181      CLZ      R1,R1
   \   0000019E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000001A2   0x40C8             LSRS     R0,R0,R1
   \   000001A4   0x07C0             LSLS     R0,R0,#+31
   \   000001A6   0xD506             BPL.N    ??HAL_RCC_OscConfig_0
    316                  {
    317                     if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
   \   000001A8   0x.... 0x....      BL       HAL_GetTick
   \   000001AC   0x1B40             SUBS     R0,R0,R5
   \   000001AE   0x2865             CMP      R0,#+101
   \   000001B0   0xD3DB             BCC.N    ??HAL_RCC_OscConfig_14
    318                    {
    319                      return HAL_TIMEOUT;
   \   000001B2   0x2003             MOVS     R0,#+3
   \   000001B4   0xE29E             B.N      ??HAL_RCC_OscConfig_5
    320                    }
    321                  }
    322                }
    323              }
    324            }
    325            /*----------------------------- HSI Configuration --------------------------*/ 
    326            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
   \                     ??HAL_RCC_OscConfig_0: (+1)
   \   000001B6   0x7820             LDRB     R0,[R4, #+0]
   \   000001B8   0x0780             LSLS     R0,R0,#+30
   \   000001BA   0xF140 0x80C1      BPL.W    ??HAL_RCC_OscConfig_17
    327            {
    328              /* Check the parameters */
    329              assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    330              assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    331              
    332              /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    333              if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
    334                 || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   000001C2   0x6800             LDR      R0,[R0, #+0]
   \   000001C4   0xF010 0x0F0C      TST      R0,#0xC
   \   000001C8   0xD00B             BEQ.N    ??HAL_RCC_OscConfig_18
   \   000001CA   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   000001CE   0x6800             LDR      R0,[R0, #+0]
   \   000001D0   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   000001D4   0x2808             CMP      R0,#+8
   \   000001D6   0xD139             BNE.N    ??HAL_RCC_OscConfig_19
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   000001DC   0x6800             LDR      R0,[R0, #+0]
   \   000001DE   0x03C0             LSLS     R0,R0,#+15
   \   000001E0   0xD434             BMI.N    ??HAL_RCC_OscConfig_19
    335              {
    336                /* When HSI is used as system clock it will not disabled */
    337                if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
   \                     ??HAL_RCC_OscConfig_18: (+1)
   \   000001E2   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000001E6   0xFAB0 0xF080      CLZ      R0,R0
   \   000001EA   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x0940             LSRS     R0,R0,#+5
   \   000001F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F4   0x2801             CMP      R0,#+1
   \   000001F6   0xD103             BNE.N    ??HAL_RCC_OscConfig_20
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000001FC   0x6800             LDR      R0,[R0, #+0]
   \   000001FE   0xE006             B.N      ??HAL_RCC_OscConfig_21
   \                     ??HAL_RCC_OscConfig_20: (+1)
   \   00000200   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000204   0xFAB0 0xF080      CLZ      R0,R0
   \   00000208   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000020C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_21: (+1)
   \   0000020E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000212   0xFAB1 0xF181      CLZ      R1,R1
   \   00000216   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000021A   0x40C8             LSRS     R0,R0,R1
   \   0000021C   0x07C0             LSLS     R0,R0,#+31
   \   0000021E   0xD504             BPL.N    ??HAL_RCC_OscConfig_22
   \   00000220   0x6920             LDR      R0,[R4, #+16]
   \   00000222   0x2801             CMP      R0,#+1
   \   00000224   0xD001             BEQ.N    ??HAL_RCC_OscConfig_22
    338                {
    339                  return HAL_ERROR;
   \   00000226   0x2001             MOVS     R0,#+1
   \   00000228   0xE264             B.N      ??HAL_RCC_OscConfig_5
    340                }
    341                /* Otherwise, just the calibration is allowed */
    342                else
    343                {
    344                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    345                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_22: (+1)
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0xF05F 0x51F8      MOVS     R1,#+520093696
   \   00000234   0xFAB1 0xF181      CLZ      R1,R1
   \   00000238   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   0000023C   0x6962             LDR      R2,[R4, #+20]
   \   0000023E   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000242   0x4308             ORRS     R0,R1,R0
   \   00000244   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   00000248   0x6008             STR      R0,[R1, #+0]
   \   0000024A   0xE079             B.N      ??HAL_RCC_OscConfig_17
    346                }
    347              }
    348              else
    349              {
    350                /* Check the HSI State */
    351                if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
   \                     ??HAL_RCC_OscConfig_19: (+1)
   \   0000024C   0x6920             LDR      R0,[R4, #+16]
   \   0000024E   0x2800             CMP      R0,#+0
   \   00000250   0xD043             BEQ.N    ??HAL_RCC_OscConfig_23
    352                {
    353                 /* Enable the Internal High Speed oscillator (HSI). */
    354                  __HAL_RCC_HSI_ENABLE();
   \   00000252   0x2001             MOVS     R0,#+1
   \   00000254   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000258   0xFAB1 0xF181      CLZ      R1,R1
   \   0000025C   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x42420000
   \   00000260   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000264   0x6010             STR      R0,[R2, #+0]
    355                  
    356                  /* Get Start Tick */
    357                  tickstart = HAL_GetTick();
   \   00000266   0x.... 0x....      BL       HAL_GetTick
   \   0000026A   0x0005             MOVS     R5,R0
    358                  
    359                  /* Wait till HSI is ready */
    360                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_24: (+1)
   \   0000026C   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000270   0xFAB0 0xF080      CLZ      R0,R0
   \   00000274   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000278   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000027A   0x0940             LSRS     R0,R0,#+5
   \   0000027C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000027E   0x2801             CMP      R0,#+1
   \   00000280   0xD103             BNE.N    ??HAL_RCC_OscConfig_25
   \   00000282   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000286   0x6800             LDR      R0,[R0, #+0]
   \   00000288   0xE006             B.N      ??HAL_RCC_OscConfig_26
   \                     ??HAL_RCC_OscConfig_25: (+1)
   \   0000028A   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000028E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000292   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000296   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_26: (+1)
   \   00000298   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000029C   0xFAB1 0xF181      CLZ      R1,R1
   \   000002A0   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000002A4   0x40C8             LSRS     R0,R0,R1
   \   000002A6   0x07C0             LSLS     R0,R0,#+31
   \   000002A8   0xD406             BMI.N    ??HAL_RCC_OscConfig_27
    361                  {
    362                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   000002AA   0x.... 0x....      BL       HAL_GetTick
   \   000002AE   0x1B40             SUBS     R0,R0,R5
   \   000002B0   0x2803             CMP      R0,#+3
   \   000002B2   0xD3DB             BCC.N    ??HAL_RCC_OscConfig_24
    363                    {
    364                      return HAL_TIMEOUT;
   \   000002B4   0x2003             MOVS     R0,#+3
   \   000002B6   0xE21D             B.N      ??HAL_RCC_OscConfig_5
    365                    }
    366                  }
    367                          
    368                  /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
    369                  __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
   \                     ??HAL_RCC_OscConfig_27: (+1)
   \   000002B8   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000002BC   0x6800             LDR      R0,[R0, #+0]
   \   000002BE   0xF05F 0x51F8      MOVS     R1,#+520093696
   \   000002C2   0xFAB1 0xF181      CLZ      R1,R1
   \   000002C6   0xF030 0x00F8      BICS     R0,R0,#0xF8
   \   000002CA   0x6962             LDR      R2,[R4, #+20]
   \   000002CC   0xFA12 0xF101      LSLS     R1,R2,R1
   \   000002D0   0x4308             ORRS     R0,R1,R0
   \   000002D2   0x.... 0x....      LDR.W    R1,??DataTable12_1  ;; 0x40021000
   \   000002D6   0x6008             STR      R0,[R1, #+0]
   \   000002D8   0xE032             B.N      ??HAL_RCC_OscConfig_17
    370                }
    371                else
    372                {
    373                  /* Disable the Internal High Speed oscillator (HSI). */
    374                  __HAL_RCC_HSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_23: (+1)
   \   000002DA   0x2000             MOVS     R0,#+0
   \   000002DC   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   000002E0   0xFAB1 0xF181      CLZ      R1,R1
   \   000002E4   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x42420000
   \   000002E8   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   000002EC   0x6010             STR      R0,[R2, #+0]
    375                  
    376                  /* Get Start Tick */
    377                  tickstart = HAL_GetTick();
   \   000002EE   0x.... 0x....      BL       HAL_GetTick
   \   000002F2   0x0005             MOVS     R5,R0
    378                  
    379                  /* Wait till HSI is disabled */
    380                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_28: (+1)
   \   000002F4   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000002F8   0xFAB0 0xF080      CLZ      R0,R0
   \   000002FC   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000300   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000302   0x0940             LSRS     R0,R0,#+5
   \   00000304   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000306   0x2801             CMP      R0,#+1
   \   00000308   0xD103             BNE.N    ??HAL_RCC_OscConfig_29
   \   0000030A   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000030E   0x6800             LDR      R0,[R0, #+0]
   \   00000310   0xE006             B.N      ??HAL_RCC_OscConfig_30
   \                     ??HAL_RCC_OscConfig_29: (+1)
   \   00000312   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000316   0xFAB0 0xF080      CLZ      R0,R0
   \   0000031A   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000031E   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_30: (+1)
   \   00000320   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000324   0xFAB1 0xF181      CLZ      R1,R1
   \   00000328   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000032C   0x40C8             LSRS     R0,R0,R1
   \   0000032E   0x07C0             LSLS     R0,R0,#+31
   \   00000330   0xD506             BPL.N    ??HAL_RCC_OscConfig_17
    381                  {
    382                    if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
   \   00000332   0x.... 0x....      BL       HAL_GetTick
   \   00000336   0x1B40             SUBS     R0,R0,R5
   \   00000338   0x2803             CMP      R0,#+3
   \   0000033A   0xD3DB             BCC.N    ??HAL_RCC_OscConfig_28
    383                    {
    384                      return HAL_TIMEOUT;
   \   0000033C   0x2003             MOVS     R0,#+3
   \   0000033E   0xE1D9             B.N      ??HAL_RCC_OscConfig_5
    385                    }
    386                  }
    387                }
    388              }
    389            }
    390            /*------------------------------ LSI Configuration -------------------------*/ 
    391            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
   \                     ??HAL_RCC_OscConfig_17: (+1)
   \   00000340   0x7820             LDRB     R0,[R4, #+0]
   \   00000342   0x0700             LSLS     R0,R0,#+28
   \   00000344   0xD556             BPL.N    ??HAL_RCC_OscConfig_31
    392            {
    393              /* Check the parameters */
    394              assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
    395              
    396              /* Check the LSI State */
    397              if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
   \   00000346   0x69A0             LDR      R0,[R4, #+24]
   \   00000348   0x2800             CMP      R0,#+0
   \   0000034A   0xD02B             BEQ.N    ??HAL_RCC_OscConfig_32
    398              {
    399                /* Enable the Internal Low Speed oscillator (LSI). */
    400                __HAL_RCC_LSI_ENABLE();
   \   0000034C   0x2001             MOVS     R0,#+1
   \   0000034E   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   00000352   0xFAB1 0xF181      CLZ      R1,R1
   \   00000356   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x42420480
   \   0000035A   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   0000035E   0x6010             STR      R0,[R2, #+0]
    401                
    402                /* Get Start Tick */
    403                tickstart = HAL_GetTick();
   \   00000360   0x.... 0x....      BL       HAL_GetTick
   \   00000364   0x0005             MOVS     R5,R0
    404                
    405                /* Wait till LSI is ready */  
    406                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
   \                     ??HAL_RCC_OscConfig_33: (+1)
   \   00000366   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000036A   0xFAB0 0xF080      CLZ      R0,R0
   \   0000036E   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000372   0xFAB0 0xF080      CLZ      R0,R0
   \   00000376   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000037A   0x6800             LDR      R0,[R0, #+0]
   \   0000037C   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000380   0xFAB1 0xF181      CLZ      R1,R1
   \   00000384   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000388   0x40C8             LSRS     R0,R0,R1
   \   0000038A   0x07C0             LSLS     R0,R0,#+31
   \   0000038C   0xD406             BMI.N    ??HAL_RCC_OscConfig_34
    407                {
    408                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   0000038E   0x.... 0x....      BL       HAL_GetTick
   \   00000392   0x1B40             SUBS     R0,R0,R5
   \   00000394   0x2803             CMP      R0,#+3
   \   00000396   0xD3E6             BCC.N    ??HAL_RCC_OscConfig_33
    409                  {
    410                    return HAL_TIMEOUT;
   \   00000398   0x2003             MOVS     R0,#+3
   \   0000039A   0xE1AB             B.N      ??HAL_RCC_OscConfig_5
    411                  }
    412                }
    413                /*  To have a fully stabilized clock in the specified range, a software delay of 1ms 
    414                    should be added.*/
    415                HAL_Delay(1);
   \                     ??HAL_RCC_OscConfig_34: (+1)
   \   0000039C   0x2001             MOVS     R0,#+1
   \   0000039E   0x.... 0x....      BL       HAL_Delay
   \   000003A2   0xE027             B.N      ??HAL_RCC_OscConfig_31
    416              }
    417              else
    418              {
    419                /* Disable the Internal Low Speed oscillator (LSI). */
    420                __HAL_RCC_LSI_DISABLE();
   \                     ??HAL_RCC_OscConfig_32: (+1)
   \   000003A4   0x2000             MOVS     R0,#+0
   \   000003A6   0xF05F 0x4100      MOVS     R1,#-2147483648
   \   000003AA   0xFAB1 0xF181      CLZ      R1,R1
   \   000003AE   0x.... 0x....      LDR.W    R2,??DataTable12_8  ;; 0x42420480
   \   000003B2   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   000003B6   0x6010             STR      R0,[R2, #+0]
    421                
    422                /* Get Start Tick */
    423                tickstart = HAL_GetTick();
   \   000003B8   0x.... 0x....      BL       HAL_GetTick
   \   000003BC   0x0005             MOVS     R5,R0
    424                
    425                /* Wait till LSI is disabled */  
    426                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
   \                     ??HAL_RCC_OscConfig_35: (+1)
   \   000003BE   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000003C2   0xFAB0 0xF080      CLZ      R0,R0
   \   000003C6   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000003CA   0xFAB0 0xF080      CLZ      R0,R0
   \   000003CE   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   000003D2   0x6800             LDR      R0,[R0, #+0]
   \   000003D4   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   000003D8   0xFAB1 0xF181      CLZ      R1,R1
   \   000003DC   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000003E0   0x40C8             LSRS     R0,R0,R1
   \   000003E2   0x07C0             LSLS     R0,R0,#+31
   \   000003E4   0xD506             BPL.N    ??HAL_RCC_OscConfig_31
    427                {
    428                  if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
   \   000003E6   0x.... 0x....      BL       HAL_GetTick
   \   000003EA   0x1B40             SUBS     R0,R0,R5
   \   000003EC   0x2803             CMP      R0,#+3
   \   000003EE   0xD3E6             BCC.N    ??HAL_RCC_OscConfig_35
    429                  {
    430                    return HAL_TIMEOUT;
   \   000003F0   0x2003             MOVS     R0,#+3
   \   000003F2   0xE17F             B.N      ??HAL_RCC_OscConfig_5
    431                  }
    432                }
    433              }
    434            }
    435            /*------------------------------ LSE Configuration -------------------------*/ 
    436            if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
   \                     ??HAL_RCC_OscConfig_31: (+1)
   \   000003F4   0x7820             LDRB     R0,[R4, #+0]
   \   000003F6   0x0740             LSLS     R0,R0,#+29
   \   000003F8   0xF140 0x80C3      BPL.W    ??HAL_RCC_OscConfig_36
    437            {
    438              /* Check the parameters */
    439              assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    440          
    441              /* Enable Power Clock*/
    442                __HAL_RCC_PWR_CLK_ENABLE();
   \   000003FC   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x4002101c
   \   00000400   0x6800             LDR      R0,[R0, #+0]
   \   00000402   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   00000406   0x.... 0x....      LDR.W    R1,??DataTable12_9  ;; 0x4002101c
   \   0000040A   0x6008             STR      R0,[R1, #+0]
   \   0000040C   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x4002101c
   \   00000410   0x6800             LDR      R0,[R0, #+0]
   \   00000412   0xF010 0x5080      ANDS     R0,R0,#0x10000000
   \   00000416   0x9000             STR      R0,[SP, #+0]
   \   00000418   0x9800             LDR      R0,[SP, #+0]
    443              
    444                /* Enable write access to Backup domain */
    445                SET_BIT(PWR->CR, PWR_CR_DBP);
   \   0000041A   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40007000
   \   0000041E   0x6800             LDR      R0,[R0, #+0]
   \   00000420   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000424   0x.... 0x....      LDR.W    R1,??DataTable12_10  ;; 0x40007000
   \   00000428   0x6008             STR      R0,[R1, #+0]
    446                
    447                /* Wait for Backup domain Write protection disable */
    448                tickstart = HAL_GetTick();
   \   0000042A   0x.... 0x....      BL       HAL_GetTick
   \   0000042E   0x0005             MOVS     R5,R0
    449          
    450              while((PWR->CR & PWR_CR_DBP) == RESET)
   \                     ??HAL_RCC_OscConfig_37: (+1)
   \   00000430   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40007000
   \   00000434   0x6800             LDR      R0,[R0, #+0]
   \   00000436   0x05C0             LSLS     R0,R0,#+23
   \   00000438   0xD406             BMI.N    ??HAL_RCC_OscConfig_38
    451                {
    452                  if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
   \   0000043A   0x.... 0x....      BL       HAL_GetTick
   \   0000043E   0x1B40             SUBS     R0,R0,R5
   \   00000440   0x2865             CMP      R0,#+101
   \   00000442   0xD3F5             BCC.N    ??HAL_RCC_OscConfig_37
    453                  {
    454                    return HAL_TIMEOUT;
   \   00000444   0x2003             MOVS     R0,#+3
   \   00000446   0xE155             B.N      ??HAL_RCC_OscConfig_5
    455                  }
    456                }
    457          
    458              /* Set the new LSE configuration -----------------------------------------*/
    459              __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
   \                     ??HAL_RCC_OscConfig_38: (+1)
   \   00000448   0x68E0             LDR      R0,[R4, #+12]
   \   0000044A   0x2801             CMP      R0,#+1
   \   0000044C   0xD108             BNE.N    ??HAL_RCC_OscConfig_39
   \   0000044E   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   00000452   0x6800             LDR      R0,[R0, #+0]
   \   00000454   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000458   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   0000045C   0x6008             STR      R0,[R1, #+0]
   \   0000045E   0xE037             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_39: (+1)
   \   00000460   0x68E0             LDR      R0,[R4, #+12]
   \   00000462   0x2800             CMP      R0,#+0
   \   00000464   0xD110             BNE.N    ??HAL_RCC_OscConfig_41
   \   00000466   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   0000046A   0x6800             LDR      R0,[R0, #+0]
   \   0000046C   0x0840             LSRS     R0,R0,#+1
   \   0000046E   0x0040             LSLS     R0,R0,#+1
   \   00000470   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   00000474   0x6008             STR      R0,[R1, #+0]
   \   00000476   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   0000047A   0x6800             LDR      R0,[R0, #+0]
   \   0000047C   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000480   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   00000484   0x6008             STR      R0,[R1, #+0]
   \   00000486   0xE023             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_41: (+1)
   \   00000488   0x68E0             LDR      R0,[R4, #+12]
   \   0000048A   0x2805             CMP      R0,#+5
   \   0000048C   0xD110             BNE.N    ??HAL_RCC_OscConfig_42
   \   0000048E   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   00000492   0x6800             LDR      R0,[R0, #+0]
   \   00000494   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000498   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   0000049C   0x6008             STR      R0,[R1, #+0]
   \   0000049E   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   000004A2   0x6800             LDR      R0,[R0, #+0]
   \   000004A4   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000004A8   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   000004AC   0x6008             STR      R0,[R1, #+0]
   \   000004AE   0xE00F             B.N      ??HAL_RCC_OscConfig_40
   \                     ??HAL_RCC_OscConfig_42: (+1)
   \   000004B0   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   000004B4   0x6800             LDR      R0,[R0, #+0]
   \   000004B6   0x0840             LSRS     R0,R0,#+1
   \   000004B8   0x0040             LSLS     R0,R0,#+1
   \   000004BA   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   000004BE   0x6008             STR      R0,[R1, #+0]
   \   000004C0   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   000004C4   0x6800             LDR      R0,[R0, #+0]
   \   000004C6   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000004CA   0x.... 0x....      LDR.W    R1,??DataTable12_11  ;; 0x40021020
   \   000004CE   0x6008             STR      R0,[R1, #+0]
    460              /* Check the LSE State */
    461              if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
   \                     ??HAL_RCC_OscConfig_40: (+1)
   \   000004D0   0x68E0             LDR      R0,[R4, #+12]
   \   000004D2   0x2800             CMP      R0,#+0
   \   000004D4   0xD02A             BEQ.N    ??HAL_RCC_OscConfig_43
    462              {
    463                /* Get Start Tick */
    464                tickstart = HAL_GetTick();
   \   000004D6   0x.... 0x....      BL       HAL_GetTick
   \   000004DA   0x0005             MOVS     R5,R0
    465                
    466                /* Wait till LSE is ready */  
    467                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
   \                     ??HAL_RCC_OscConfig_44: (+1)
   \   000004DC   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000004E0   0xFAB0 0xF080      CLZ      R0,R0
   \   000004E4   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000004E8   0xFAB0 0xF080      CLZ      R0,R0
   \   000004EC   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   000004F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F2   0x0940             LSRS     R0,R0,#+5
   \   000004F4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F6   0x2802             CMP      R0,#+2
   \   000004F8   0xD103             BNE.N    ??HAL_RCC_OscConfig_45
   \   000004FA   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   000004FE   0x6800             LDR      R0,[R0, #+0]
   \   00000500   0xE002             B.N      ??HAL_RCC_OscConfig_46
   \                     ??HAL_RCC_OscConfig_45: (+1)
   \   00000502   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000506   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_46: (+1)
   \   00000508   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000050C   0xFAB1 0xF181      CLZ      R1,R1
   \   00000510   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000514   0x40C8             LSRS     R0,R0,R1
   \   00000516   0x07C0             LSLS     R0,R0,#+31
   \   00000518   0xD433             BMI.N    ??HAL_RCC_OscConfig_36
    468                {
    469                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   0000051A   0x.... 0x....      BL       HAL_GetTick
   \   0000051E   0x1B40             SUBS     R0,R0,R5
   \   00000520   0xF241 0x3189      MOVW     R1,#+5001
   \   00000524   0x4288             CMP      R0,R1
   \   00000526   0xD3D9             BCC.N    ??HAL_RCC_OscConfig_44
    470                  {
    471                    return HAL_TIMEOUT;
   \   00000528   0x2003             MOVS     R0,#+3
   \   0000052A   0xE0E3             B.N      ??HAL_RCC_OscConfig_5
    472                  }
    473                }
    474              }
    475              else
    476              {
    477                /* Get Start Tick */
    478                tickstart = HAL_GetTick();
   \                     ??HAL_RCC_OscConfig_43: (+1)
   \   0000052C   0x.... 0x....      BL       HAL_GetTick
   \   00000530   0x0005             MOVS     R5,R0
    479                
    480                /* Wait till LSE is disabled */  
    481                while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
   \                     ??HAL_RCC_OscConfig_47: (+1)
   \   00000532   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000536   0xFAB0 0xF080      CLZ      R0,R0
   \   0000053A   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000053E   0xFAB0 0xF080      CLZ      R0,R0
   \   00000542   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000546   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000548   0x0940             LSRS     R0,R0,#+5
   \   0000054A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000054C   0x2802             CMP      R0,#+2
   \   0000054E   0xD103             BNE.N    ??HAL_RCC_OscConfig_48
   \   00000550   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40021020
   \   00000554   0x6800             LDR      R0,[R0, #+0]
   \   00000556   0xE002             B.N      ??HAL_RCC_OscConfig_49
   \                     ??HAL_RCC_OscConfig_48: (+1)
   \   00000558   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000055C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_49: (+1)
   \   0000055E   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000562   0xFAB1 0xF181      CLZ      R1,R1
   \   00000566   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000056A   0x40C8             LSRS     R0,R0,R1
   \   0000056C   0x07C0             LSLS     R0,R0,#+31
   \   0000056E   0xD508             BPL.N    ??HAL_RCC_OscConfig_36
    482                {
    483                  if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
   \   00000570   0x.... 0x....      BL       HAL_GetTick
   \   00000574   0x1B40             SUBS     R0,R0,R5
   \   00000576   0xF241 0x3189      MOVW     R1,#+5001
   \   0000057A   0x4288             CMP      R0,R1
   \   0000057C   0xD3D9             BCC.N    ??HAL_RCC_OscConfig_47
    484                  {
    485                    return HAL_TIMEOUT;
   \   0000057E   0x2003             MOVS     R0,#+3
   \   00000580   0xE0B8             B.N      ??HAL_RCC_OscConfig_5
    486                  }
    487                }
    488              }
    489            }
    490          
    491          #if defined(RCC_CR_PLL2ON)
    492            /*-------------------------------- PLL2 Configuration -----------------------*/
    493            /* Check the parameters */
    494            assert_param(IS_RCC_PLL2(RCC_OscInitStruct->PLL2.PLL2State));
    495            if ((RCC_OscInitStruct->PLL2.PLL2State) != RCC_PLL2_NONE)
    496            {
    497              /* This bit can not be cleared if the PLL2 clock is used indirectly as system 
    498                clock (i.e. it is used as PLL clock entry that is used as system clock). */
    499              if((__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE) && \
    500                  (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && \
    501                  ((READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC)) == RCC_CFGR2_PREDIV1SRC_PLL2))
    502              {
    503                return HAL_ERROR;
    504              }
    505              else
    506              {
    507                if((RCC_OscInitStruct->PLL2.PLL2State) == RCC_PLL2_ON)
    508                {
    509                  /* Check the parameters */
    510                  assert_param(IS_RCC_PLL2_MUL(RCC_OscInitStruct->PLL2.PLL2MUL));
    511                  assert_param(IS_RCC_HSE_PREDIV2(RCC_OscInitStruct->PLL2.HSEPrediv2Value));
    512          
    513                  /* Prediv2 can be written only when the PLLI2S is disabled. */
    514                  /* Return an error only if new value is different from the programmed value */
    515                  if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL3ON) && \
    516                    (__HAL_RCC_HSE_GET_PREDIV2() != RCC_OscInitStruct->PLL2.HSEPrediv2Value))
    517                  {
    518                    return HAL_ERROR;
    519                  }
    520                  
    521                  /* Disable the main PLL2. */
    522                  __HAL_RCC_PLL2_DISABLE();
    523                  
    524                  /* Get Start Tick */
    525                  tickstart = HAL_GetTick();
    526                  
    527                  /* Wait till PLL2 is disabled */
    528                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != RESET)
    529                  {
    530                    if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    531                    {
    532                      return HAL_TIMEOUT;
    533                    }
    534                  }
    535                  
    536                  /* Configure the HSE prediv2 factor --------------------------------*/
    537                  __HAL_RCC_HSE_PREDIV2_CONFIG(RCC_OscInitStruct->PLL2.HSEPrediv2Value);
    538          
    539                  /* Configure the main PLL2 multiplication factors. */
    540                  __HAL_RCC_PLL2_CONFIG(RCC_OscInitStruct->PLL2.PLL2MUL);
    541                  
    542                  /* Enable the main PLL2. */
    543                  __HAL_RCC_PLL2_ENABLE();
    544                  
    545                  /* Get Start Tick */
    546                  tickstart = HAL_GetTick();
    547                  
    548                  /* Wait till PLL2 is ready */
    549                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  == RESET)
    550                  {
    551                    if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    552                    {
    553                      return HAL_TIMEOUT;
    554                    }
    555                  }
    556                }
    557                else
    558                {
    559                 /* Set PREDIV1 source to HSE */
    560                  CLEAR_BIT(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC);
    561          
    562                  /* Disable the main PLL2. */
    563                  __HAL_RCC_PLL2_DISABLE();
    564           
    565                  /* Get Start Tick */
    566                  tickstart = HAL_GetTick();
    567                  
    568                  /* Wait till PLL2 is disabled */  
    569                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY)  != RESET)
    570                  {
    571                    if((HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
    572                    {
    573                      return HAL_TIMEOUT;
    574                    }
    575                  }
    576                }
    577              }
    578            }
    579          
    580          #endif /* RCC_CR_PLL2ON */
    581            /*-------------------------------- PLL Configuration -----------------------*/
    582            /* Check the parameters */
    583            assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
    584            if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
   \                     ??HAL_RCC_OscConfig_36: (+1)
   \   00000582   0x69E0             LDR      R0,[R4, #+28]
   \   00000584   0x2800             CMP      R0,#+0
   \   00000586   0xF000 0x80B4      BEQ.W    ??HAL_RCC_OscConfig_50
    585            {
    586              /* Check if the PLL is used as system clock or not */
    587              if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \   0000058A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000058E   0x6800             LDR      R0,[R0, #+0]
   \   00000590   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000594   0x2808             CMP      R0,#+8
   \   00000596   0xF000 0x80AA      BEQ.W    ??HAL_RCC_OscConfig_51
    588              { 
    589                if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
   \   0000059A   0x69E0             LDR      R0,[R4, #+28]
   \   0000059C   0x2802             CMP      R0,#+2
   \   0000059E   0xD177             BNE.N    ??HAL_RCC_OscConfig_52
    590                {
    591                  /* Check the parameters */
    592                  assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
    593                  assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
    594            
    595                  /* Disable the main PLL. */
    596                  __HAL_RCC_PLL_DISABLE();
   \   000005A0   0x2000             MOVS     R0,#+0
   \   000005A2   0x2180             MOVS     R1,#+128
   \   000005A4   0xFAB1 0xF181      CLZ      R1,R1
   \   000005A8   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x42420000
   \   000005AC   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   000005B0   0x6010             STR      R0,[R2, #+0]
    597                  
    598                  /* Get Start Tick */
    599                  tickstart = HAL_GetTick();
   \   000005B2   0x.... 0x....      BL       HAL_GetTick
   \   000005B6   0x0005             MOVS     R5,R0
    600                  
    601                  /* Wait till PLL is disabled */
    602                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_53: (+1)
   \   000005B8   0x2040             MOVS     R0,#+64
   \   000005BA   0xFAB0 0xF080      CLZ      R0,R0
   \   000005BE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000005C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005C4   0x0940             LSRS     R0,R0,#+5
   \   000005C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000005C8   0x2801             CMP      R0,#+1
   \   000005CA   0xD103             BNE.N    ??HAL_RCC_OscConfig_54
   \   000005CC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000005D0   0x6800             LDR      R0,[R0, #+0]
   \   000005D2   0xE005             B.N      ??HAL_RCC_OscConfig_55
   \                     ??HAL_RCC_OscConfig_54: (+1)
   \   000005D4   0x2040             MOVS     R0,#+64
   \   000005D6   0xFAB0 0xF080      CLZ      R0,R0
   \   000005DA   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   000005DE   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_55: (+1)
   \   000005E0   0x2140             MOVS     R1,#+64
   \   000005E2   0xFAB1 0xF181      CLZ      R1,R1
   \   000005E6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000005EA   0x40C8             LSRS     R0,R0,R1
   \   000005EC   0x07C0             LSLS     R0,R0,#+31
   \   000005EE   0xD506             BPL.N    ??HAL_RCC_OscConfig_56
    603                  {
    604                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000005F0   0x.... 0x....      BL       HAL_GetTick
   \   000005F4   0x1B40             SUBS     R0,R0,R5
   \   000005F6   0x2803             CMP      R0,#+3
   \   000005F8   0xD3DE             BCC.N    ??HAL_RCC_OscConfig_53
    605                    {
    606                      return HAL_TIMEOUT;
   \   000005FA   0x2003             MOVS     R0,#+3
   \   000005FC   0xE07A             B.N      ??HAL_RCC_OscConfig_5
    607                    }
    608                  }
    609          
    610                  /* Configure the HSE prediv factor --------------------------------*/
    611                  /* It can be written only when the PLL is disabled. Not used in PLL source is different than HSE */
    612                  if(RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
   \                     ??HAL_RCC_OscConfig_56: (+1)
   \   000005FE   0x6A20             LDR      R0,[R4, #+32]
   \   00000600   0xF5B0 0x3F80      CMP      R0,#+65536
   \   00000604   0xD109             BNE.N    ??HAL_RCC_OscConfig_57
    613                  {
    614                    /* Check the parameter */
    615                    assert_param(IS_RCC_HSE_PREDIV(RCC_OscInitStruct->HSEPredivValue));
    616          #if defined(RCC_CFGR2_PREDIV1SRC)
    617                    assert_param(IS_RCC_PREDIV1_SOURCE(RCC_OscInitStruct->Prediv1Source));
    618                    
    619                    /* Set PREDIV1 source */
    620                    SET_BIT(RCC->CFGR2, RCC_OscInitStruct->Prediv1Source);
    621          #endif /* RCC_CFGR2_PREDIV1SRC */
    622          
    623                    /* Set PREDIV1 Value */
    624                    __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
   \   00000606   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000060A   0x6801             LDR      R1,[R0, #+0]
   \   0000060C   0xF431 0x3100      BICS     R1,R1,#0x20000
   \   00000610   0x68A0             LDR      R0,[R4, #+8]
   \   00000612   0x4301             ORRS     R1,R0,R1
   \   00000614   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000618   0x6001             STR      R1,[R0, #+0]
    625                  }
    626          
    627                  /* Configure the main PLL clock source and multiplication factors. */
    628                  __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
    629                                       RCC_OscInitStruct->PLL.PLLMUL);
   \                     ??HAL_RCC_OscConfig_57: (+1)
   \   0000061A   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000061E   0x6801             LDR      R1,[R0, #+0]
   \   00000620   0xF431 0x1174      BICS     R1,R1,#0x3D0000
   \   00000624   0x6A20             LDR      R0,[R4, #+32]
   \   00000626   0x4301             ORRS     R1,R0,R1
   \   00000628   0x6A60             LDR      R0,[R4, #+36]
   \   0000062A   0x4301             ORRS     R1,R0,R1
   \   0000062C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000630   0x6001             STR      R1,[R0, #+0]
    630                  /* Enable the main PLL. */
    631                  __HAL_RCC_PLL_ENABLE();
   \   00000632   0x2001             MOVS     R0,#+1
   \   00000634   0x2180             MOVS     R1,#+128
   \   00000636   0xFAB1 0xF181      CLZ      R1,R1
   \   0000063A   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x42420000
   \   0000063E   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000642   0x6010             STR      R0,[R2, #+0]
    632                  
    633                  /* Get Start Tick */
    634                  tickstart = HAL_GetTick();
   \   00000644   0x.... 0x....      BL       HAL_GetTick
   \   00000648   0x0005             MOVS     R5,R0
    635                  
    636                  /* Wait till PLL is ready */
    637                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
   \                     ??HAL_RCC_OscConfig_58: (+1)
   \   0000064A   0x2040             MOVS     R0,#+64
   \   0000064C   0xFAB0 0xF080      CLZ      R0,R0
   \   00000650   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000654   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000656   0x0940             LSRS     R0,R0,#+5
   \   00000658   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000065A   0x2801             CMP      R0,#+1
   \   0000065C   0xD103             BNE.N    ??HAL_RCC_OscConfig_59
   \   0000065E   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000662   0x6800             LDR      R0,[R0, #+0]
   \   00000664   0xE005             B.N      ??HAL_RCC_OscConfig_60
   \                     ??HAL_RCC_OscConfig_59: (+1)
   \   00000666   0x2040             MOVS     R0,#+64
   \   00000668   0xFAB0 0xF080      CLZ      R0,R0
   \   0000066C   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000670   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_60: (+1)
   \   00000672   0x2140             MOVS     R1,#+64
   \   00000674   0xFAB1 0xF181      CLZ      R1,R1
   \   00000678   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000067C   0x40C8             LSRS     R0,R0,R1
   \   0000067E   0x07C0             LSLS     R0,R0,#+31
   \   00000680   0xD437             BMI.N    ??HAL_RCC_OscConfig_50
    638                  {
    639                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   00000682   0x.... 0x....      BL       HAL_GetTick
   \   00000686   0x1B40             SUBS     R0,R0,R5
   \   00000688   0x2803             CMP      R0,#+3
   \   0000068A   0xD3DE             BCC.N    ??HAL_RCC_OscConfig_58
    640                    {
    641                      return HAL_TIMEOUT;
   \   0000068C   0x2003             MOVS     R0,#+3
   \   0000068E   0xE031             B.N      ??HAL_RCC_OscConfig_5
    642                    }
    643                  }
    644                }
    645                else
    646                {
    647                  /* Disable the main PLL. */
    648                  __HAL_RCC_PLL_DISABLE();
   \                     ??HAL_RCC_OscConfig_52: (+1)
   \   00000690   0x2000             MOVS     R0,#+0
   \   00000692   0x2180             MOVS     R1,#+128
   \   00000694   0xFAB1 0xF181      CLZ      R1,R1
   \   00000698   0x.... 0x....      LDR.W    R2,??DataTable12_7  ;; 0x42420000
   \   0000069C   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   000006A0   0x6010             STR      R0,[R2, #+0]
    649           
    650                  /* Get Start Tick */
    651                  tickstart = HAL_GetTick();
   \   000006A2   0x.... 0x....      BL       HAL_GetTick
   \   000006A6   0x0005             MOVS     R5,R0
    652                  
    653                  /* Wait till PLL is disabled */  
    654                  while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
   \                     ??HAL_RCC_OscConfig_61: (+1)
   \   000006A8   0x2040             MOVS     R0,#+64
   \   000006AA   0xFAB0 0xF080      CLZ      R0,R0
   \   000006AE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000006B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006B4   0x0940             LSRS     R0,R0,#+5
   \   000006B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000006B8   0x2801             CMP      R0,#+1
   \   000006BA   0xD103             BNE.N    ??HAL_RCC_OscConfig_62
   \   000006BC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000006C0   0x6800             LDR      R0,[R0, #+0]
   \   000006C2   0xE005             B.N      ??HAL_RCC_OscConfig_63
   \                     ??HAL_RCC_OscConfig_62: (+1)
   \   000006C4   0x2040             MOVS     R0,#+64
   \   000006C6   0xFAB0 0xF080      CLZ      R0,R0
   \   000006CA   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   000006CE   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_OscConfig_63: (+1)
   \   000006D0   0x2140             MOVS     R1,#+64
   \   000006D2   0xFAB1 0xF181      CLZ      R1,R1
   \   000006D6   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000006DA   0x40C8             LSRS     R0,R0,R1
   \   000006DC   0x07C0             LSLS     R0,R0,#+31
   \   000006DE   0xD508             BPL.N    ??HAL_RCC_OscConfig_50
    655                  {
    656                    if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
   \   000006E0   0x.... 0x....      BL       HAL_GetTick
   \   000006E4   0x1B40             SUBS     R0,R0,R5
   \   000006E6   0x2803             CMP      R0,#+3
   \   000006E8   0xD3DE             BCC.N    ??HAL_RCC_OscConfig_61
    657                    {
    658                      return HAL_TIMEOUT;
   \   000006EA   0x2003             MOVS     R0,#+3
   \   000006EC   0xE002             B.N      ??HAL_RCC_OscConfig_5
    659                    }
    660                  }
    661                }
    662              }
    663              else
    664              {
    665                return HAL_ERROR;
   \                     ??HAL_RCC_OscConfig_51: (+1)
   \   000006EE   0x2001             MOVS     R0,#+1
   \   000006F0   0xE000             B.N      ??HAL_RCC_OscConfig_5
    666              }
    667            }
    668            
    669            return HAL_OK;
   \                     ??HAL_RCC_OscConfig_50: (+1)
   \   000006F2   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_OscConfig_5: (+1)
   \   000006F4   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    670          }
    671          
    672          /**
    673            * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified 
    674            *         parameters in the RCC_ClkInitStruct.
    675            * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
    676            *         contains the configuration information for the RCC peripheral.
    677            * @param  FLatency FLASH Latency                   
    678            *          The value of this parameter depend on device used within the same series
    679            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
    680            *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
    681            *
    682            * @note   The HSI is used (enabled by hardware) as system clock source after
    683            *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
    684            *         of failure of the HSE used directly or indirectly as system clock
    685            *         (if the Clock Security System CSS is enabled).
    686            *           
    687            * @note   A switch from one clock source to another occurs only if the target
    688            *         clock source is ready (clock stable after start-up delay or PLL locked). 
    689            *         If a clock source which is not yet ready is selected, the switch will
    690            *         occur when the clock source will be ready. 
    691            *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
    692            *         currently used as system clock source.
    693            * @retval HAL status
    694            */

   \                                 In section .text, align 2, keep-with-next
    695          HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
    696          {
   \                     HAL_RCC_ClockConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    697            uint32_t tickstart = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    698            
    699            /* Check the parameters */
    700            assert_param(RCC_ClkInitStruct != NULL);
    701            assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
    702            assert_param(IS_FLASH_LATENCY(FLatency));
    703          
    704            /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    705            must be correctly programmed according to the frequency of the CPU clock 
    706              (HCLK) of the device. */
    707          
    708          #if defined(FLASH_ACR_LATENCY)
    709            /* Increasing the number of wait states because of higher CPU frequency */
    710            if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40022000
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000012   0x42A8             CMP      R0,R5
   \   00000014   0xD211             BCS.N    ??HAL_RCC_ClockConfig_0
    711            {    
    712              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    713              __HAL_FLASH_SET_LATENCY(FLatency);
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40022000
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x08C0             LSRS     R0,R0,#+3
   \   0000001E   0x00C0             LSLS     R0,R0,#+3
   \   00000020   0x4328             ORRS     R0,R5,R0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable12_12  ;; 0x40022000
   \   00000026   0x6008             STR      R0,[R1, #+0]
    714              
    715              /* Check that the new number of wait states is taken into account to access the Flash
    716              memory by reading the FLASH_ACR register */
    717              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40022000
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000032   0x42A8             CMP      R0,R5
   \   00000034   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_0
    718              {
    719                return HAL_ERROR;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE0F6             B.N      ??HAL_RCC_ClockConfig_1
    720              }
    721            }
    722          
    723          #endif /* FLASH_ACR_LATENCY */
    724            /*-------------------------- HCLK Configuration --------------------------*/
    725            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
   \                     ??HAL_RCC_ClockConfig_0: (+1)
   \   0000003A   0x7820             LDRB     R0,[R4, #+0]
   \   0000003C   0x0780             LSLS     R0,R0,#+30
   \   0000003E   0xD509             BPL.N    ??HAL_RCC_ClockConfig_2
    726            {
    727              assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    728              MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000044   0x6801             LDR      R1,[R0, #+0]
   \   00000046   0xF031 0x01F0      BICS     R1,R1,#0xF0
   \   0000004A   0x68A0             LDR      R0,[R4, #+8]
   \   0000004C   0x4301             ORRS     R1,R0,R1
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   00000052   0x6001             STR      R1,[R0, #+0]
    729            }
    730          
    731            /*------------------------- SYSCLK Configuration ---------------------------*/ 
    732            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
   \                     ??HAL_RCC_ClockConfig_2: (+1)
   \   00000054   0x7820             LDRB     R0,[R4, #+0]
   \   00000056   0x07C0             LSLS     R0,R0,#+31
   \   00000058   0xF140 0x80A6      BPL.W    ??HAL_RCC_ClockConfig_3
    733            {    
    734              assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    735              
    736              /* HSE is selected as System Clock Source */
    737              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   0000005C   0x6860             LDR      R0,[R4, #+4]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD120             BNE.N    ??HAL_RCC_ClockConfig_4
    738              {
    739                /* Check the HSE ready flag */  
    740                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
   \   00000062   0xF44F 0x4080      MOV      R0,#+16384
   \   00000066   0xFAB0 0xF080      CLZ      R0,R0
   \   0000006A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x0940             LSRS     R0,R0,#+5
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD103             BNE.N    ??HAL_RCC_ClockConfig_5
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xE006             B.N      ??HAL_RCC_ClockConfig_6
   \                     ??HAL_RCC_ClockConfig_5: (+1)
   \   00000080   0xF44F 0x4080      MOV      R0,#+16384
   \   00000084   0xFAB0 0xF080      CLZ      R0,R0
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_6: (+1)
   \   0000008E   0xF44F 0x4180      MOV      R1,#+16384
   \   00000092   0xFAB1 0xF181      CLZ      R1,R1
   \   00000096   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000009A   0x40C8             LSRS     R0,R0,R1
   \   0000009C   0x07C0             LSLS     R0,R0,#+31
   \   0000009E   0xD443             BMI.N    ??HAL_RCC_ClockConfig_7
    741                {
    742                  return HAL_ERROR;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE0C1             B.N      ??HAL_RCC_ClockConfig_1
    743                }
    744              }
    745              /* PLL is selected as System Clock Source */
    746              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_4: (+1)
   \   000000A4   0x6860             LDR      R0,[R4, #+4]
   \   000000A6   0x2802             CMP      R0,#+2
   \   000000A8   0xD11D             BNE.N    ??HAL_RCC_ClockConfig_8
    747              {
    748                /* Check the PLL ready flag */  
    749                if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
   \   000000AA   0x2040             MOVS     R0,#+64
   \   000000AC   0xFAB0 0xF080      CLZ      R0,R0
   \   000000B0   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x0940             LSRS     R0,R0,#+5
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xD103             BNE.N    ??HAL_RCC_ClockConfig_9
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0xE005             B.N      ??HAL_RCC_ClockConfig_10
   \                     ??HAL_RCC_ClockConfig_9: (+1)
   \   000000C6   0x2040             MOVS     R0,#+64
   \   000000C8   0xFAB0 0xF080      CLZ      R0,R0
   \   000000CC   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_10: (+1)
   \   000000D2   0x2140             MOVS     R1,#+64
   \   000000D4   0xFAB1 0xF181      CLZ      R1,R1
   \   000000D8   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   000000DC   0x40C8             LSRS     R0,R0,R1
   \   000000DE   0x07C0             LSLS     R0,R0,#+31
   \   000000E0   0xD422             BMI.N    ??HAL_RCC_ClockConfig_7
    750                {
    751                  return HAL_ERROR;
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0xE0A0             B.N      ??HAL_RCC_ClockConfig_1
    752                }
    753              }
    754              /* HSI is selected as System Clock Source */
    755              else
    756              {
    757                /* Check the HSI ready flag */  
    758                if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
   \                     ??HAL_RCC_ClockConfig_8: (+1)
   \   000000E6   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   000000EA   0xFAB0 0xF080      CLZ      R0,R0
   \   000000EE   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000F2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F4   0x0940             LSRS     R0,R0,#+5
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD103             BNE.N    ??HAL_RCC_ClockConfig_11
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x40021000
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0xE006             B.N      ??HAL_RCC_ClockConfig_12
   \                     ??HAL_RCC_ClockConfig_11: (+1)
   \   00000104   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   00000108   0xFAB0 0xF080      CLZ      R0,R0
   \   0000010C   0x.... 0x....      LDR.W    R0,??DataTable12_6  ;; 0x40021024
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \                     ??HAL_RCC_ClockConfig_12: (+1)
   \   00000112   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   00000116   0xFAB1 0xF181      CLZ      R1,R1
   \   0000011A   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   0000011E   0x40C8             LSRS     R0,R0,R1
   \   00000120   0x07C0             LSLS     R0,R0,#+31
   \   00000122   0xD401             BMI.N    ??HAL_RCC_ClockConfig_7
    759                {
    760                  return HAL_ERROR;
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0xE07F             B.N      ??HAL_RCC_ClockConfig_1
    761                }
    762              }
    763              __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
   \                     ??HAL_RCC_ClockConfig_7: (+1)
   \   00000128   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000012C   0x6801             LDR      R1,[R0, #+0]
   \   0000012E   0x0889             LSRS     R1,R1,#+2
   \   00000130   0x0089             LSLS     R1,R1,#+2
   \   00000132   0x6860             LDR      R0,[R4, #+4]
   \   00000134   0x4301             ORRS     R1,R0,R1
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000013A   0x6001             STR      R1,[R0, #+0]
    764          
    765              /* Get Start Tick */
    766              tickstart = HAL_GetTick();
   \   0000013C   0x.... 0x....      BL       HAL_GetTick
   \   00000140   0x0006             MOVS     R6,R0
    767              
    768              if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
   \   00000142   0x6860             LDR      R0,[R4, #+4]
   \   00000144   0x2801             CMP      R0,#+1
   \   00000146   0xD10F             BNE.N    ??HAL_RCC_ClockConfig_13
    769              {
    770                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
   \                     ??HAL_RCC_ClockConfig_14: (+1)
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x40021004
   \   0000014C   0x6800             LDR      R0,[R0, #+0]
   \   0000014E   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000152   0x2804             CMP      R0,#+4
   \   00000154   0xD028             BEQ.N    ??HAL_RCC_ClockConfig_3
    771                {
    772                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000156   0x.... 0x....      BL       HAL_GetTick
   \   0000015A   0x1B80             SUBS     R0,R0,R6
   \   0000015C   0xF241 0x3189      MOVW     R1,#+5001
   \   00000160   0x4288             CMP      R0,R1
   \   00000162   0xD3F1             BCC.N    ??HAL_RCC_ClockConfig_14
    773                  {
    774                    return HAL_TIMEOUT;
   \   00000164   0x2003             MOVS     R0,#+3
   \   00000166   0xE05F             B.N      ??HAL_RCC_ClockConfig_1
    775                  }
    776                }
    777              }
    778              else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_13: (+1)
   \   00000168   0x6860             LDR      R0,[R4, #+4]
   \   0000016A   0x2802             CMP      R0,#+2
   \   0000016C   0xD10E             BNE.N    ??HAL_RCC_ClockConfig_15
    779              {
    780                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
   \                     ??HAL_RCC_ClockConfig_16: (+1)
   \   0000016E   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   00000170   0x6800             LDR      R0,[R0, #+0]
   \   00000172   0xF010 0x000C      ANDS     R0,R0,#0xC
   \   00000176   0x2808             CMP      R0,#+8
   \   00000178   0xD016             BEQ.N    ??HAL_RCC_ClockConfig_3
    781                {
    782                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   0000017A   0x.... 0x....      BL       HAL_GetTick
   \   0000017E   0x1B80             SUBS     R0,R0,R6
   \   00000180   0xF241 0x3189      MOVW     R1,#+5001
   \   00000184   0x4288             CMP      R0,R1
   \   00000186   0xD3F2             BCC.N    ??HAL_RCC_ClockConfig_16
    783                  {
    784                    return HAL_TIMEOUT;
   \   00000188   0x2003             MOVS     R0,#+3
   \   0000018A   0xE04D             B.N      ??HAL_RCC_ClockConfig_1
    785                  }
    786                }
    787              }
    788              else
    789              {
    790                while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
   \                     ??HAL_RCC_ClockConfig_15: (+1)
   \   0000018C   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   0000018E   0x6800             LDR      R0,[R0, #+0]
   \   00000190   0xF010 0x0F0C      TST      R0,#0xC
   \   00000194   0xD008             BEQ.N    ??HAL_RCC_ClockConfig_3
    791                {
    792                  if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
   \   00000196   0x.... 0x....      BL       HAL_GetTick
   \   0000019A   0x1B80             SUBS     R0,R0,R6
   \   0000019C   0xF241 0x3189      MOVW     R1,#+5001
   \   000001A0   0x4288             CMP      R0,R1
   \   000001A2   0xD3F3             BCC.N    ??HAL_RCC_ClockConfig_15
    793                  {
    794                    return HAL_TIMEOUT;
   \   000001A4   0x2003             MOVS     R0,#+3
   \   000001A6   0xE03F             B.N      ??HAL_RCC_ClockConfig_1
    795                  }
    796                }
    797              }      
    798            }    
    799          #if defined(FLASH_ACR_LATENCY)
    800            /* Decreasing the number of wait states because of lower CPU frequency */
    801            if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
   \                     ??HAL_RCC_ClockConfig_3: (+1)
   \   000001A8   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40022000
   \   000001AA   0x6800             LDR      R0,[R0, #+0]
   \   000001AC   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000001B0   0x4285             CMP      R5,R0
   \   000001B2   0xD20E             BCS.N    ??HAL_RCC_ClockConfig_17
    802            {    
    803              /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    804              __HAL_FLASH_SET_LATENCY(FLatency);
   \   000001B4   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40022000
   \   000001B6   0x6800             LDR      R0,[R0, #+0]
   \   000001B8   0x08C0             LSRS     R0,R0,#+3
   \   000001BA   0x00C0             LSLS     R0,R0,#+3
   \   000001BC   0x4328             ORRS     R0,R5,R0
   \   000001BE   0x....             LDR.N    R1,??DataTable12_12  ;; 0x40022000
   \   000001C0   0x6008             STR      R0,[R1, #+0]
    805              
    806              /* Check that the new number of wait states is taken into account to access the Flash
    807              memory by reading the FLASH_ACR register */
    808              if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
   \   000001C2   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40022000
   \   000001C4   0x6800             LDR      R0,[R0, #+0]
   \   000001C6   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   000001CA   0x42A8             CMP      R0,R5
   \   000001CC   0xD001             BEQ.N    ??HAL_RCC_ClockConfig_17
    809              {
    810                return HAL_ERROR;
   \   000001CE   0x2001             MOVS     R0,#+1
   \   000001D0   0xE02A             B.N      ??HAL_RCC_ClockConfig_1
    811              }
    812            }    
    813          #endif /* FLASH_ACR_LATENCY */
    814          
    815            /*-------------------------- PCLK1 Configuration ---------------------------*/ 
    816            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
   \                     ??HAL_RCC_ClockConfig_17: (+1)
   \   000001D2   0x7820             LDRB     R0,[R4, #+0]
   \   000001D4   0x0740             LSLS     R0,R0,#+29
   \   000001D6   0xD507             BPL.N    ??HAL_RCC_ClockConfig_18
    817            {
    818              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    819              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
   \   000001D8   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   000001DA   0x6801             LDR      R1,[R0, #+0]
   \   000001DC   0xF431 0x61E0      BICS     R1,R1,#0x700
   \   000001E0   0x68E0             LDR      R0,[R4, #+12]
   \   000001E2   0x4301             ORRS     R1,R0,R1
   \   000001E4   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   000001E6   0x6001             STR      R1,[R0, #+0]
    820            }
    821            
    822            /*-------------------------- PCLK2 Configuration ---------------------------*/ 
    823            if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
   \                     ??HAL_RCC_ClockConfig_18: (+1)
   \   000001E8   0x7820             LDRB     R0,[R4, #+0]
   \   000001EA   0x0700             LSLS     R0,R0,#+28
   \   000001EC   0xD508             BPL.N    ??HAL_RCC_ClockConfig_19
    824            {
    825              assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    826              MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
   \   000001EE   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   000001F0   0x6800             LDR      R0,[R0, #+0]
   \   000001F2   0xF430 0x5060      BICS     R0,R0,#0x3800
   \   000001F6   0x6921             LDR      R1,[R4, #+16]
   \   000001F8   0xEA50 0x00C1      ORRS     R0,R0,R1, LSL #+3
   \   000001FC   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   000001FE   0x6008             STR      R0,[R1, #+0]
    827            }
    828           
    829            /* Update the SystemCoreClock global variable */
    830            SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
   \                     ??HAL_RCC_ClockConfig_19: (+1)
   \   00000200   0x.... 0x....      BL       HAL_RCC_GetSysClockFreq
   \   00000204   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   00000206   0x6809             LDR      R1,[R1, #+0]
   \   00000208   0x....             LDR.N    R2,??DataTable12_13
   \   0000020A   0xF011 0x01F0      ANDS     R1,R1,#0xF0
   \   0000020E   0xF05F 0x6370      MOVS     R3,#+251658240
   \   00000212   0xFAB3 0xF383      CLZ      R3,R3
   \   00000216   0x40D9             LSRS     R1,R1,R3
   \   00000218   0x5C51             LDRB     R1,[R2, R1]
   \   0000021A   0x40C8             LSRS     R0,R0,R1
   \   0000021C   0x....             LDR.N    R1,??DataTable12_5
   \   0000021E   0x6008             STR      R0,[R1, #+0]
    831          
    832            /* Configure the source of time base considering new system clocks settings*/
    833            HAL_InitTick (TICK_INT_PRIORITY);
   \   00000220   0x200F             MOVS     R0,#+15
   \   00000222   0x.... 0x....      BL       HAL_InitTick
    834            
    835            return HAL_OK;
   \   00000226   0x2000             MOVS     R0,#+0
   \                     ??HAL_RCC_ClockConfig_1: (+1)
   \   00000228   0xBD70             POP      {R4-R6,PC}       ;; return
    836          }
    837          
    838          /**
    839            * @}
    840            */
    841          
    842          /** @defgroup RCC_Exported_Functions_Group2 Peripheral Control functions
    843            *  @brief   RCC clocks control functions
    844            *
    845            @verbatim   
    846            ===============================================================================
    847                            ##### Peripheral Control functions #####
    848            ===============================================================================  
    849              [..]
    850              This subsection provides a set of functions allowing to control the RCC Clocks 
    851              frequencies.
    852          
    853            @endverbatim
    854            * @{
    855            */
    856          
    857          /**
    858            * @brief  Selects the clock source to output on MCO pin.
    859            * @note   MCO pin should be configured in alternate function mode.
    860            * @param  RCC_MCOx specifies the output direction for the clock source.
    861            *          This parameter can be one of the following values:
    862            *            @arg @ref RCC_MCO1 Clock source to output on MCO1 pin(PA8).
    863            * @param  RCC_MCOSource specifies the clock source to output.
    864            *          This parameter can be one of the following values:
    865            *            @arg @ref RCC_MCO1SOURCE_NOCLOCK     No clock selected as MCO clock
    866            *            @arg @ref RCC_MCO1SOURCE_SYSCLK      System clock selected as MCO clock
    867            *            @arg @ref RCC_MCO1SOURCE_HSI         HSI selected as MCO clock
    868            *            @arg @ref RCC_MCO1SOURCE_HSE         HSE selected as MCO clock
    869            @if STM32F105xC
    870            *            @arg @ref RCC_MCO1SOURCE_PLLCLK       PLL clock divided by 2 selected as MCO source
    871            *            @arg @ref RCC_MCO1SOURCE_PLL2CLK      PLL2 clock selected as MCO source
    872            *            @arg @ref RCC_MCO1SOURCE_PLL3CLK_DIV2 PLL3 clock divided by 2 selected as MCO source
    873            *            @arg @ref RCC_MCO1SOURCE_EXT_HSE      XT1 external 3-25 MHz oscillator clock selected as MCO source
    874            *            @arg @ref RCC_MCO1SOURCE_PLL3CLK      PLL3 clock selected as MCO source
    875            @endif
    876            @if STM32F107xC
    877            *            @arg @ref RCC_MCO1SOURCE_PLLCLK       PLL clock divided by 2 selected as MCO source
    878            *            @arg @ref RCC_MCO1SOURCE_PLL2CLK      PLL2 clock selected as MCO source
    879            *            @arg @ref RCC_MCO1SOURCE_PLL3CLK_DIV2 PLL3 clock divided by 2 selected as MCO source
    880            *            @arg @ref RCC_MCO1SOURCE_EXT_HSE XT1  external 3-25 MHz oscillator clock selected as MCO source
    881            *            @arg @ref RCC_MCO1SOURCE_PLL3CLK      PLL3 clock selected as MCO source
    882            @endif
    883            * @param  RCC_MCODiv specifies the MCO DIV.
    884            *          This parameter can be one of the following values:
    885            *            @arg @ref RCC_MCODIV_1 no division applied to MCO clock
    886            * @retval None
    887            */

   \                                 In section .text, align 2, keep-with-next
    888          void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
    889          {
   \                     HAL_RCC_MCOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    890            GPIO_InitTypeDef gpio = {0};
   \   0000000A   0xA801             ADD      R0,SP,#+4
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x.... 0x....      BL       __aeabi_memclr4
    891          
    892            /* Check the parameters */
    893            assert_param(IS_RCC_MCO(RCC_MCOx));
    894            assert_param(IS_RCC_MCODIV(RCC_MCODiv));
    895            assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));
    896            
    897            /* Configure the MCO1 pin in alternate function mode */
    898            gpio.Mode      = GPIO_MODE_AF_PP;
   \   00000012   0x2002             MOVS     R0,#+2
   \   00000014   0x9002             STR      R0,[SP, #+8]
    899            gpio.Speed     = GPIO_SPEED_FREQ_HIGH;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x9004             STR      R0,[SP, #+16]
    900            gpio.Pull      = GPIO_NOPULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
    901            gpio.Pin       = MCO1_PIN;
   \   0000001E   0xF44F 0x7080      MOV      R0,#+256
   \   00000022   0x9001             STR      R0,[SP, #+4]
    902          
    903            /* MCO1 Clock Enable */
    904            MCO1_CLK_ENABLE();
   \   00000024   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40021018
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000002C   0x....             LDR.N    R1,??DataTable12_14  ;; 0x40021018
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40021018
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF010 0x0004      ANDS     R0,R0,#0x4
   \   00000038   0x9000             STR      R0,[SP, #+0]
   \   0000003A   0x9800             LDR      R0,[SP, #+0]
    905            
    906            HAL_GPIO_Init(MCO1_GPIO_PORT, &gpio);
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40010800
   \   00000040   0x.... 0x....      BL       HAL_GPIO_Init
    907            
    908            /* Configure the MCO clock source */
    909            __HAL_RCC_MCO1_CONFIG(RCC_MCOSource, RCC_MCODiv);
   \   00000044   0x....             LDR.N    R0,??DataTable12  ;; 0x40021004
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0xF030 0x60E0      BICS     R0,R0,#0x7000000
   \   0000004C   0x4328             ORRS     R0,R5,R0
   \   0000004E   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   00000050   0x6008             STR      R0,[R1, #+0]
    910          }
   \   00000052   0xB006             ADD      SP,SP,#+24
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
    911          
    912          /**
    913            * @brief  Enables the Clock Security System.
    914            * @note   If a failure is detected on the HSE oscillator clock, this oscillator
    915            *         is automatically disabled and an interrupt is generated to inform the
    916            *         software about the failure (Clock Security System Interrupt, CSSI),
    917            *         allowing the MCU to perform rescue operations. The CSSI is linked to 
    918            *         the Cortex-M3 NMI (Non-Maskable Interrupt) exception vector.  
    919            * @retval None
    920            */

   \                                 In section .text, align 2, keep-with-next
    921          void HAL_RCC_EnableCSS(void)
    922          {
    923            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)ENABLE;
   \                     HAL_RCC_EnableCSS: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0xF44F 0x5180      MOV      R1,#+4096
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable12_7  ;; 0x42420000
   \   0000000C   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000010   0x6010             STR      R0,[R2, #+0]
    924          }
   \   00000012   0x4770             BX       LR               ;; return
    925          
    926          /**
    927            * @brief  Disables the Clock Security System.
    928            * @retval None
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          void HAL_RCC_DisableCSS(void)
    931          {
    932            *(__IO uint32_t *) RCC_CR_CSSON_BB = (uint32_t)DISABLE;
   \                     HAL_RCC_DisableCSS: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xF44F 0x5180      MOV      R1,#+4096
   \   00000006   0xFAB1 0xF181      CLZ      R1,R1
   \   0000000A   0x....             LDR.N    R2,??DataTable12_7  ;; 0x42420000
   \   0000000C   0xEB12 0x0281      ADDS     R2,R2,R1, LSL #+2
   \   00000010   0x6010             STR      R0,[R2, #+0]
    933          }
   \   00000012   0x4770             BX       LR               ;; return
    934          
    935          /**
    936            * @brief  Returns the SYSCLK frequency     
    937            * @note   The system frequency computed by this function is not the real 
    938            *         frequency in the chip. It is calculated based on the predefined 
    939            *         constant and the selected clock source:
    940            * @note     If SYSCLK source is HSI, function returns values based on HSI_VALUE(*)
    941            * @note     If SYSCLK source is HSE, function returns a value based on HSE_VALUE
    942            *           divided by PREDIV factor(**)
    943            * @note     If SYSCLK source is PLL, function returns a value based on HSE_VALUE
    944            *           divided by PREDIV factor(**) or HSI_VALUE(*) multiplied by the PLL factor.
    945            * @note     (*) HSI_VALUE is a constant defined in stm32f1xx_hal_conf.h file (default value
    946            *               8 MHz) but the real value may vary depending on the variations
    947            *               in voltage and temperature.
    948            * @note     (**) HSE_VALUE is a constant defined in stm32f1xx_hal_conf.h file (default value
    949            *                8 MHz), user has to ensure that HSE_VALUE is same as the real
    950            *                frequency of the crystal used. Otherwise, this function may
    951            *                have wrong result.
    952            *                  
    953            * @note   The result of this function could be not correct when using fractional
    954            *         value for HSE crystal.
    955            *           
    956            * @note   This function can be used by the user application to compute the 
    957            *         baud-rate for the communication peripherals or configure other parameters.
    958            *           
    959            * @note   Each time SYSCLK changes, this function must be called to update the
    960            *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
    961            *         
    962            * @retval SYSCLK frequency
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          uint32_t HAL_RCC_GetSysClockFreq(void)
    965          {
   \                     HAL_RCC_GetSysClockFreq: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    966          #if   defined(RCC_CFGR2_PREDIV1SRC)
    967            const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
    968            const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
    969          #else
    970            const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x....             LDR.N    R1,??DataTable12_16
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy4
    971          #if defined(RCC_CFGR2_PREDIV1)
    972            const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
    973          #else
    974            const uint8_t aPredivFactorTable[2] = { 1, 2};
   \   0000000E   0x....             LDR.N    R0,??DataTable12_17
   \   00000010   0x8800             LDRH     R0,[R0, #+0]
   \   00000012   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    975          #endif /*RCC_CFGR2_PREDIV1*/
    976          
    977          #endif
    978            uint32_t tmpreg = 0, prediv = 0, pllclk = 0, pllmul = 0;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2400             MOVS     R4,#+0
    979            uint32_t sysclockfreq = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
    980          #if defined(RCC_CFGR2_PREDIV1SRC)
    981            uint32_t prediv2 = 0, pll2mul = 0;
    982          #endif /*RCC_CFGR2_PREDIV1SRC*/
    983            
    984            tmpreg = RCC->CFGR;
   \   00000020   0x....             LDR.N    R5,??DataTable12  ;; 0x40021004
   \   00000022   0x682D             LDR      R5,[R5, #+0]
   \   00000024   0x0029             MOVS     R1,R5
    985            
    986            /* Get SYSCLK source -------------------------------------------------------*/
    987            switch (tmpreg & RCC_CFGR_SWS)
   \   00000026   0xF011 0x050C      ANDS     R5,R1,#0xC
   \   0000002A   0x2D04             CMP      R5,#+4
   \   0000002C   0xD002             BEQ.N    ??HAL_RCC_GetSysClockFreq_0
   \   0000002E   0x2D08             CMP      R5,#+8
   \   00000030   0xD003             BEQ.N    ??HAL_RCC_GetSysClockFreq_1
   \   00000032   0xE026             B.N      ??HAL_RCC_GetSysClockFreq_2
    988            {
    989              case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock */
    990              {
    991                sysclockfreq = HSE_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_0: (+1)
   \   00000034   0x....             LDR.N    R5,??DataTable12_4  ;; 0x7a1200
   \   00000036   0x0028             MOVS     R0,R5
    992                break;
   \   00000038   0xE025             B.N      ??HAL_RCC_GetSysClockFreq_3
    993              }
    994              case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    995              {
    996                pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
   \                     ??HAL_RCC_GetSysClockFreq_1: (+1)
   \   0000003A   0xAD01             ADD      R5,SP,#+4
   \   0000003C   0xF411 0x1670      ANDS     R6,R1,#0x3C0000
   \   00000040   0xF44F 0x5770      MOV      R7,#+15360
   \   00000044   0xFAB7 0xF787      CLZ      R7,R7
   \   00000048   0x40FE             LSRS     R6,R6,R7
   \   0000004A   0x5DAD             LDRB     R5,[R5, R6]
   \   0000004C   0x002C             MOVS     R4,R5
    997                if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
   \   0000004E   0x03CD             LSLS     R5,R1,#+15
   \   00000050   0xD511             BPL.N    ??HAL_RCC_GetSysClockFreq_4
    998                {
    999          #if defined(RCC_CFGR2_PREDIV1)
   1000                  prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
   1001          #else
   1002                  prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
   \   00000052   0x....             LDR.N    R5,??DataTable12  ;; 0x40021004
   \   00000054   0x682D             LDR      R5,[R5, #+0]
   \   00000056   0x466E             MOV      R6,SP
   \   00000058   0xF415 0x3500      ANDS     R5,R5,#0x20000
   \   0000005C   0xF44F 0x4780      MOV      R7,#+16384
   \   00000060   0xFAB7 0xF787      CLZ      R7,R7
   \   00000064   0x40FD             LSRS     R5,R5,R7
   \   00000066   0x5D75             LDRB     R5,[R6, R5]
   \   00000068   0x002A             MOVS     R2,R5
   1003          #endif /*RCC_CFGR2_PREDIV1*/
   1004          #if defined(RCC_CFGR2_PREDIV1SRC)
   1005          
   1006                  if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
   1007                  {
   1008                    /* PLL2 selected as Prediv1 source */
   1009                    /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
   1010                    prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
   1011                    pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
   1012                    pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv) * pllmul);
   1013                  }
   1014                  else
   1015                  {
   1016                    /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
   1017                    pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
   1018                  }
   1019                  
   1020                  /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
   1021                  /* In this case need to divide pllclk by 2 */
   1022                  if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
   1023                  {
   1024                      pllclk = pllclk / 2;
   1025                  }
   1026          #else
   1027                  /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
   1028                  pllclk = (uint32_t)((HSE_VALUE / prediv) * pllmul);
   \   0000006A   0x....             LDR.N    R5,??DataTable12_4  ;; 0x7a1200
   \   0000006C   0xFBB5 0xF5F2      UDIV     R5,R5,R2
   \   00000070   0x4365             MULS     R5,R4,R5
   \   00000072   0x002B             MOVS     R3,R5
   \   00000074   0xE003             B.N      ??HAL_RCC_GetSysClockFreq_5
   1029          #endif /*RCC_CFGR2_PREDIV1SRC*/
   1030                }
   1031                else
   1032                {
   1033                  /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
   1034                  pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
   \                     ??HAL_RCC_GetSysClockFreq_4: (+1)
   \   00000076   0x....             LDR.N    R5,??DataTable12_18  ;; 0x3d0900
   \   00000078   0xFB05 0xF504      MUL      R5,R5,R4
   \   0000007C   0x002B             MOVS     R3,R5
   1035                }
   1036                sysclockfreq = pllclk;
   \                     ??HAL_RCC_GetSysClockFreq_5: (+1)
   \   0000007E   0x0018             MOVS     R0,R3
   1037                break;
   \   00000080   0xE001             B.N      ??HAL_RCC_GetSysClockFreq_3
   1038              }
   1039              case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
   1040              default: /* HSI used as system clock */
   1041              {
   1042                sysclockfreq = HSI_VALUE;
   \                     ??HAL_RCC_GetSysClockFreq_2: (+1)
   \   00000082   0x....             LDR.N    R5,??DataTable12_4  ;; 0x7a1200
   \   00000084   0x0028             MOVS     R0,R5
   1043                break;
   1044              }
   1045            }
   1046            return sysclockfreq;
   \                     ??HAL_RCC_GetSysClockFreq_3: (+1)
   \   00000086   0xB005             ADD      SP,SP,#+20
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return
   1047          }
   1048          
   1049          /**
   1050            * @brief  Returns the HCLK frequency     
   1051            * @note   Each time HCLK changes, this function must be called to update the
   1052            *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
   1053            * 
   1054            * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
   1055            *         and updated within this function
   1056            * @retval HCLK frequency
   1057            */

   \                                 In section .text, align 2, keep-with-next
   1058          uint32_t HAL_RCC_GetHCLKFreq(void)
   1059          {
   1060            return SystemCoreClock;
   \                     HAL_RCC_GetHCLKFreq: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable12_5
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1061          }
   1062          
   1063          /**
   1064            * @brief  Returns the PCLK1 frequency     
   1065            * @note   Each time PCLK1 changes, this function must be called to update the
   1066            *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
   1067            * @retval PCLK1 frequency
   1068            */

   \                                 In section .text, align 2, keep-with-next
   1069          uint32_t HAL_RCC_GetPCLK1Freq(void)
   1070          {
   \                     HAL_RCC_GetPCLK1Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1071            /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
   1072            return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_BITNUMBER]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable12_19
   \   0000000C   0xF411 0x61E0      ANDS     R1,R1,#0x700
   \   00000010   0xF45F 0x0360      MOVS     R3,#+14680064
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1073          }    
   1074          
   1075          /**
   1076            * @brief  Returns the PCLK2 frequency     
   1077            * @note   Each time PCLK2 changes, this function must be called to update the
   1078            *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
   1079            * @retval PCLK2 frequency
   1080            */

   \                                 In section .text, align 2, keep-with-next
   1081          uint32_t HAL_RCC_GetPCLK2Freq(void)
   1082          {
   \                     HAL_RCC_GetPCLK2Freq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1083            /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
   1084            return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
   \   00000002   0x.... 0x....      BL       HAL_RCC_GetHCLKFreq
   \   00000006   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x....             LDR.N    R2,??DataTable12_19
   \   0000000C   0xF411 0x5160      ANDS     R1,R1,#0x3800
   \   00000010   0xF45F 0x13E0      MOVS     R3,#+1835008
   \   00000014   0xFAB3 0xF383      CLZ      R3,R3
   \   00000018   0x40D9             LSRS     R1,R1,R3
   \   0000001A   0x5C51             LDRB     R1,[R2, R1]
   \   0000001C   0x40C8             LSRS     R0,R0,R1
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1085          } 
   1086          
   1087          /**
   1088            * @brief  Configures the RCC_OscInitStruct according to the internal 
   1089            * RCC configuration registers.
   1090            * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that 
   1091            * will be configured.
   1092            * @retval None
   1093            */

   \                                 In section .text, align 2, keep-with-next
   1094          void HAL_RCC_GetOscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
   1095          {
   1096            /* Check the parameters */
   1097            assert_param(RCC_OscInitStruct != NULL);
   1098          
   1099            /* Set all possible values for the Oscillator type parameter ---------------*/
   1100            RCC_OscInitStruct->OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI  \
   1101                            | RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_LSI;
   \                     HAL_RCC_GetOscConfig: (+1)
   \   00000000   0x210F             MOVS     R1,#+15
   \   00000002   0x6001             STR      R1,[R0, #+0]
   1102          
   1103          #if defined(RCC_CFGR2_PREDIV1SRC)
   1104            /* Get the Prediv1 source --------------------------------------------------*/
   1105            RCC_OscInitStruct->Prediv1Source = READ_BIT(RCC->CFGR2,RCC_CFGR2_PREDIV1SRC);
   1106          #endif /* RCC_CFGR2_PREDIV1SRC */
   1107          
   1108            /* Get the HSE configuration -----------------------------------------------*/
   1109            if((RCC->CR &RCC_CR_HSEBYP) == RCC_CR_HSEBYP)
   \   00000004   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \   00000006   0x6809             LDR      R1,[R1, #+0]
   \   00000008   0x0349             LSLS     R1,R1,#+13
   \   0000000A   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_0
   1110            {
   1111              RCC_OscInitStruct->HSEState = RCC_HSE_BYPASS;
   \   0000000C   0xF45F 0x21A0      MOVS     R1,#+327680
   \   00000010   0x6041             STR      R1,[R0, #+4]
   \   00000012   0xE009             B.N      ??HAL_RCC_GetOscConfig_1
   1112            }
   1113            else if((RCC->CR &RCC_CR_HSEON) == RCC_CR_HSEON)
   \                     ??HAL_RCC_GetOscConfig_0: (+1)
   \   00000014   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x03C9             LSLS     R1,R1,#+15
   \   0000001A   0xD503             BPL.N    ??HAL_RCC_GetOscConfig_2
   1114            {
   1115              RCC_OscInitStruct->HSEState = RCC_HSE_ON;
   \   0000001C   0xF45F 0x3180      MOVS     R1,#+65536
   \   00000020   0x6041             STR      R1,[R0, #+4]
   \   00000022   0xE001             B.N      ??HAL_RCC_GetOscConfig_1
   1116            }
   1117            else
   1118            {
   1119              RCC_OscInitStruct->HSEState = RCC_HSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_2: (+1)
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6041             STR      R1,[R0, #+4]
   1120            }
   1121            RCC_OscInitStruct->HSEPredivValue = __HAL_RCC_HSE_GET_PREDIV();
   \                     ??HAL_RCC_GetOscConfig_1: (+1)
   \   00000028   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xF411 0x3100      ANDS     R1,R1,#0x20000
   \   00000030   0x6081             STR      R1,[R0, #+8]
   1122          
   1123            /* Get the HSI configuration -----------------------------------------------*/
   1124            if((RCC->CR &RCC_CR_HSION) == RCC_CR_HSION)
   \   00000032   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x07C9             LSLS     R1,R1,#+31
   \   00000038   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_3
   1125            {
   1126              RCC_OscInitStruct->HSIState = RCC_HSI_ON;
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x6101             STR      R1,[R0, #+16]
   \   0000003E   0xE001             B.N      ??HAL_RCC_GetOscConfig_4
   1127            }
   1128            else
   1129            {
   1130              RCC_OscInitStruct->HSIState = RCC_HSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_3: (+1)
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6101             STR      R1,[R0, #+16]
   1131            }
   1132            
   1133            RCC_OscInitStruct->HSICalibrationValue = (uint32_t)((RCC->CR & RCC_CR_HSITRIM) >> POSITION_VAL(RCC_CR_HSITRIM));
   \                     ??HAL_RCC_GetOscConfig_4: (+1)
   \   00000044   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0xF011 0x01F8      ANDS     R1,R1,#0xF8
   \   0000004C   0xF05F 0x52F8      MOVS     R2,#+520093696
   \   00000050   0xFAB2 0xF282      CLZ      R2,R2
   \   00000054   0x40D1             LSRS     R1,R1,R2
   \   00000056   0x6141             STR      R1,[R0, #+20]
   1134            
   1135            /* Get the LSE configuration -----------------------------------------------*/
   1136            if((RCC->BDCR &RCC_BDCR_LSEBYP) == RCC_BDCR_LSEBYP)
   \   00000058   0x....             LDR.N    R1,??DataTable12_11  ;; 0x40021020
   \   0000005A   0x6809             LDR      R1,[R1, #+0]
   \   0000005C   0x0749             LSLS     R1,R1,#+29
   \   0000005E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_5
   1137            {
   1138              RCC_OscInitStruct->LSEState = RCC_LSE_BYPASS;
   \   00000060   0x2105             MOVS     R1,#+5
   \   00000062   0x60C1             STR      R1,[R0, #+12]
   \   00000064   0xE008             B.N      ??HAL_RCC_GetOscConfig_6
   1139            }
   1140            else if((RCC->BDCR &RCC_BDCR_LSEON) == RCC_BDCR_LSEON)
   \                     ??HAL_RCC_GetOscConfig_5: (+1)
   \   00000066   0x....             LDR.N    R1,??DataTable12_11  ;; 0x40021020
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x07C9             LSLS     R1,R1,#+31
   \   0000006C   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_7
   1141            {
   1142              RCC_OscInitStruct->LSEState = RCC_LSE_ON;
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x60C1             STR      R1,[R0, #+12]
   \   00000072   0xE001             B.N      ??HAL_RCC_GetOscConfig_6
   1143            }
   1144            else
   1145            {
   1146              RCC_OscInitStruct->LSEState = RCC_LSE_OFF;
   \                     ??HAL_RCC_GetOscConfig_7: (+1)
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x60C1             STR      R1,[R0, #+12]
   1147            }
   1148            
   1149            /* Get the LSI configuration -----------------------------------------------*/
   1150            if((RCC->CSR &RCC_CSR_LSION) == RCC_CSR_LSION)
   \                     ??HAL_RCC_GetOscConfig_6: (+1)
   \   00000078   0x....             LDR.N    R1,??DataTable12_6  ;; 0x40021024
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x07C9             LSLS     R1,R1,#+31
   \   0000007E   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_8
   1151            {
   1152              RCC_OscInitStruct->LSIState = RCC_LSI_ON;
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x6181             STR      R1,[R0, #+24]
   \   00000084   0xE001             B.N      ??HAL_RCC_GetOscConfig_9
   1153            }
   1154            else
   1155            {
   1156              RCC_OscInitStruct->LSIState = RCC_LSI_OFF;
   \                     ??HAL_RCC_GetOscConfig_8: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6181             STR      R1,[R0, #+24]
   1157            }
   1158            
   1159          
   1160            /* Get the PLL configuration -----------------------------------------------*/
   1161            if((RCC->CR &RCC_CR_PLLON) == RCC_CR_PLLON)
   \                     ??HAL_RCC_GetOscConfig_9: (+1)
   \   0000008A   0x....             LDR.N    R1,??DataTable12_1  ;; 0x40021000
   \   0000008C   0x6809             LDR      R1,[R1, #+0]
   \   0000008E   0x01C9             LSLS     R1,R1,#+7
   \   00000090   0xD502             BPL.N    ??HAL_RCC_GetOscConfig_10
   1162            {
   1163              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_ON;
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0x61C1             STR      R1,[R0, #+28]
   \   00000096   0xE001             B.N      ??HAL_RCC_GetOscConfig_11
   1164            }
   1165            else
   1166            {
   1167              RCC_OscInitStruct->PLL.PLLState = RCC_PLL_OFF;
   \                     ??HAL_RCC_GetOscConfig_10: (+1)
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x61C1             STR      R1,[R0, #+28]
   1168            }
   1169            RCC_OscInitStruct->PLL.PLLSource = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLSRC);
   \                     ??HAL_RCC_GetOscConfig_11: (+1)
   \   0000009C   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   0000009E   0x6809             LDR      R1,[R1, #+0]
   \   000000A0   0xF411 0x3180      ANDS     R1,R1,#0x10000
   \   000000A4   0x6201             STR      R1,[R0, #+32]
   1170            RCC_OscInitStruct->PLL.PLLMUL = (uint32_t)(RCC->CFGR & RCC_CFGR_PLLMULL);
   \   000000A6   0x....             LDR.N    R1,??DataTable12  ;; 0x40021004
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0xF411 0x1170      ANDS     R1,R1,#0x3C0000
   \   000000AE   0x6241             STR      R1,[R0, #+36]
   1171          #if defined(RCC_CR_PLL2ON)
   1172            /* Get the PLL2 configuration -----------------------------------------------*/
   1173            if((RCC->CR &RCC_CR_PLL2ON) == RCC_CR_PLL2ON)
   1174            {
   1175              RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_ON;
   1176            }
   1177            else
   1178            {
   1179              RCC_OscInitStruct->PLL2.PLL2State = RCC_PLL2_OFF;
   1180            }
   1181            RCC_OscInitStruct->PLL2.HSEPrediv2Value = __HAL_RCC_HSE_GET_PREDIV2();
   1182            RCC_OscInitStruct->PLL2.PLL2MUL = (uint32_t)(RCC->CFGR2 & RCC_CFGR2_PLL2MUL);
   1183          #endif /* RCC_CR_PLL2ON */
   1184          }
   \   000000B0   0x4770             BX       LR               ;; return
   1185          
   1186          /**
   1187            * @brief  Get the RCC_ClkInitStruct according to the internal 
   1188            * RCC configuration registers.
   1189            * @param  RCC_ClkInitStruct pointer to an RCC_ClkInitTypeDef structure that 
   1190            * contains the current clock configuration.
   1191            * @param  pFLatency Pointer on the Flash Latency.
   1192            * @retval None
   1193            */

   \                                 In section .text, align 2, keep-with-next
   1194          void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
   1195          {
   1196            /* Check the parameters */
   1197            assert_param(RCC_ClkInitStruct != NULL);
   1198            assert_param(pFLatency != NULL);
   1199          
   1200            /* Set all possible values for the Clock type parameter --------------------*/
   1201            RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
   \                     HAL_RCC_GetClockConfig: (+1)
   \   00000000   0x220F             MOVS     R2,#+15
   \   00000002   0x6002             STR      R2,[R0, #+0]
   1202            
   1203            /* Get the SYSCLK configuration --------------------------------------------*/ 
   1204            RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
   \   00000004   0x....             LDR.N    R2,??DataTable12  ;; 0x40021004
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   0000000C   0x6042             STR      R2,[R0, #+4]
   1205            
   1206            /* Get the HCLK configuration ----------------------------------------------*/ 
   1207            RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
   \   0000000E   0x....             LDR.N    R2,??DataTable12  ;; 0x40021004
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0xF012 0x02F0      ANDS     R2,R2,#0xF0
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1208            
   1209            /* Get the APB1 configuration ----------------------------------------------*/ 
   1210            RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
   \   00000018   0x....             LDR.N    R2,??DataTable12  ;; 0x40021004
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   00000020   0x60C2             STR      R2,[R0, #+12]
   1211            
   1212            /* Get the APB2 configuration ----------------------------------------------*/ 
   1213            RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
   \   00000022   0x....             LDR.N    R2,??DataTable12  ;; 0x40021004
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0x08D2             LSRS     R2,R2,#+3
   \   00000028   0xF412 0x62E0      ANDS     R2,R2,#0x700
   \   0000002C   0x6102             STR      R2,[R0, #+16]
   1214            
   1215          #if   defined(FLASH_ACR_LATENCY)
   1216            /* Get the Flash Wait State (Latency) configuration ------------------------*/   
   1217            *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
   \   0000002E   0x....             LDR.N    R2,??DataTable12_12  ;; 0x40022000
   \   00000030   0x6812             LDR      R2,[R2, #+0]
   \   00000032   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000036   0x600A             STR      R2,[R1, #+0]
   1218          #else
   1219            /* For VALUE lines devices, only LATENCY_0 can be set*/
   1220            *pFLatency = (uint32_t)FLASH_LATENCY_0; 
   1221          #endif
   1222          }
   \   00000038   0x4770             BX       LR               ;; return
   1223          
   1224          /**
   1225            * @brief This function handles the RCC CSS interrupt request.
   1226            * @note This API should be called under the NMI_Handler().
   1227            * @retval None
   1228            */

   \                                 In section .text, align 2, keep-with-next
   1229          void HAL_RCC_NMI_IRQHandler(void)
   1230          {
   \                     HAL_RCC_NMI_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1231            /* Check RCC CSSF flag  */
   1232            if(__HAL_RCC_GET_IT(RCC_IT_CSS))
   \   00000002   0x....             LDR.N    R0,??DataTable12_3  ;; 0x40021008
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD504             BPL.N    ??HAL_RCC_NMI_IRQHandler_0
   1233            {
   1234              /* RCC Clock Security System interrupt user callback */
   1235              HAL_RCC_CSSCallback();
   \   0000000A   0x.... 0x....      BL       HAL_RCC_CSSCallback
   1236              
   1237              /* Clear RCC CSS pending bit */
   1238              __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
   \   0000000E   0x2080             MOVS     R0,#+128
   \   00000010   0x....             LDR.N    R1,??DataTable12_20  ;; 0x4002100a
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   1239            }
   1240          }
   \                     ??HAL_RCC_NMI_IRQHandler_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   1241          
   1242          /**
   1243            * @brief  RCC Clock Security System interrupt callback
   1244            * @retval none
   1245            */

   \                                 In section .text, align 2
   1246          __weak void HAL_RCC_CSSCallback(void)
   1247          {
   1248            /* NOTE : This function Should not be modified, when the callback is needed,
   1249              the HAL_RCC_CSSCallback could be implemented in the user file
   1250              */ 
   1251          }
   \                     HAL_RCC_CSSCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40021004         DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40021008         DC32     0x40021008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x40021024         DC32     0x40021024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x42420000         DC32     0x42420000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x42420480         DC32     0x42420480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x4002101C         DC32     0x4002101c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40007000         DC32     0x40007000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x40021020         DC32     0x40021020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40022000         DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x........         DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x40021018         DC32     0x40021018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x........         DC32     APBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x4002100A         DC32     0x4002100a

   \                                 In section .rodata, align 4
   \   00000000   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x02 0x03          DC8 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16
   \              0x04 0x05    
   \              0x06 0x07    
   \              0x08 0x09    
   \              0x0A 0x0B    
   \              0x0C 0x0D    
   \              0x0E 0x0F    
   \              0x10 0x10    

   \                                 In section .rodata, align 2
   \                     ?_2:
   \   00000000   0x01 0x02          DC8 1, 2
   1252          
   1253          /**
   1254            * @}
   1255            */
   1256          
   1257          /**
   1258            * @}
   1259            */
   1260          
   1261          #endif /* HAL_RCC_MODULE_ENABLED */
   1262          /**
   1263            * @}
   1264            */
   1265          
   1266          /**
   1267            * @}
   1268            */
   1269          
   1270          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_RCC_CSSCallback
      16   HAL_RCC_ClockConfig
        16   -> HAL_GetTick
        16   -> HAL_InitTick
        16   -> HAL_RCC_GetSysClockFreq
       0   HAL_RCC_DeInit
       0   HAL_RCC_DisableCSS
       0   HAL_RCC_EnableCSS
       0   HAL_RCC_GetClockConfig
       0   HAL_RCC_GetHCLKFreq
       0   HAL_RCC_GetOscConfig
       8   HAL_RCC_GetPCLK1Freq
         8   -> HAL_RCC_GetHCLKFreq
       8   HAL_RCC_GetPCLK2Freq
         8   -> HAL_RCC_GetHCLKFreq
      40   HAL_RCC_GetSysClockFreq
        40   -> __aeabi_memcpy4
      40   HAL_RCC_MCOConfig
        40   -> HAL_GPIO_Init
        40   -> __aeabi_memclr4
       8   HAL_RCC_NMI_IRQHandler
         8   -> HAL_RCC_CSSCallback
      16   HAL_RCC_OscConfig
        16   -> HAL_Delay
        16   -> HAL_GetTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      16  ?_0
      16  ?_1
       2  ?_2
       2  HAL_RCC_CSSCallback
     554  HAL_RCC_ClockConfig
     108  HAL_RCC_DeInit
      20  HAL_RCC_DisableCSS
      20  HAL_RCC_EnableCSS
      58  HAL_RCC_GetClockConfig
       6  HAL_RCC_GetHCLKFreq
     178  HAL_RCC_GetOscConfig
      32  HAL_RCC_GetPCLK1Freq
      32  HAL_RCC_GetPCLK2Freq
     138  HAL_RCC_GetSysClockFreq
      86  HAL_RCC_MCOConfig
      22  HAL_RCC_NMI_IRQHandler
    1782  HAL_RCC_OscConfig

 
    34 bytes in section .rodata
 3 122 bytes in section .text
 
 3 120 bytes of CODE  memory (+ 2 bytes shared)
    34 bytes of CONST memory

Errors: none
Warnings: none
