; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_adc.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADC_ConversionStop_Disable PROC
;;;1988     */
;;;1989   HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
000000  b570              PUSH     {r4-r6,lr}
;;;1990   {
000002  4604              MOV      r4,r0
;;;1991     uint32_t tickstart = 0;
000004  2500              MOVS     r5,#0
;;;1992     
;;;1993     /* Verification if ADC is not already disabled */
;;;1994     if (ADC_IS_ENABLE(hadc) != RESET)
000006  6820              LDR      r0,[r4,#0]
000008  6880              LDR      r0,[r0,#8]
00000a  f0000001          AND      r0,r0,#1
00000e  b1f0              CBZ      r0,|L1.78|
;;;1995     {
;;;1996       /* Disable the ADC peripheral */
;;;1997       __HAL_ADC_DISABLE(hadc);
000010  6820              LDR      r0,[r4,#0]
000012  6880              LDR      r0,[r0,#8]
000014  f0200001          BIC      r0,r0,#1
000018  6821              LDR      r1,[r4,#0]
00001a  6088              STR      r0,[r1,#8]
;;;1998        
;;;1999       /* Get tick count */
;;;2000       tickstart = HAL_GetTick();
00001c  f7fffffe          BL       HAL_GetTick
000020  4605              MOV      r5,r0
;;;2001       
;;;2002       /* Wait for ADC effectively disabled */
;;;2003       while(ADC_IS_ENABLE(hadc) != RESET)
000022  e00e              B        |L1.66|
                  |L1.36|
;;;2004       {
;;;2005         if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
000024  f7fffffe          BL       HAL_GetTick
000028  1b40              SUBS     r0,r0,r5
00002a  2802              CMP      r0,#2
00002c  d909              BLS      |L1.66|
;;;2006         {
;;;2007           /* Update ADC state machine to error */
;;;2008           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
00002e  6aa0              LDR      r0,[r4,#0x28]
000030  f0400010          ORR      r0,r0,#0x10
000034  62a0              STR      r0,[r4,#0x28]
;;;2009           
;;;2010           /* Set ADC error code to ADC IP internal error */
;;;2011           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000036  6ae0              LDR      r0,[r4,#0x2c]
000038  f0400001          ORR      r0,r0,#1
00003c  62e0              STR      r0,[r4,#0x2c]
;;;2012           
;;;2013           return HAL_ERROR;
00003e  2001              MOVS     r0,#1
                  |L1.64|
;;;2014         }
;;;2015       }
;;;2016     }
;;;2017     
;;;2018     /* Return HAL status */
;;;2019     return HAL_OK;
;;;2020   }
000040  bd70              POP      {r4-r6,pc}
                  |L1.66|
000042  6820              LDR      r0,[r4,#0]            ;2003
000044  6880              LDR      r0,[r0,#8]            ;2003
000046  f0000001          AND      r0,r0,#1              ;2003
00004a  2800              CMP      r0,#0                 ;2003
00004c  d1ea              BNE      |L1.36|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;2019
000050  e7f6              B        |L1.64|
;;;2021   
                          ENDP

                  HAL_ADC_MspInit PROC
;;;712      */
;;;713    __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
000052  4770              BX       lr
;;;714    {
;;;715      /* Prevent unused argument(s) compilation warning */
;;;716      UNUSED(hadc);
;;;717      /* NOTE : This function should not be modified. When the callback is needed,
;;;718                function HAL_ADC_MspInit must be implemented in the user file.
;;;719       */ 
;;;720    }
;;;721    
                          ENDP

                  HAL_ADC_Init PROC
;;;373      */
;;;374    HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
000054  e92d41f0          PUSH     {r4-r8,lr}
;;;375    {
000058  4604              MOV      r4,r0
;;;376      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
00005a  2700              MOVS     r7,#0
;;;377      uint32_t tmp_cr1 = 0;
00005c  2500              MOVS     r5,#0
;;;378      uint32_t tmp_cr2 = 0;
00005e  2600              MOVS     r6,#0
;;;379      uint32_t tmp_sqr1 = 0;
000060  46a8              MOV      r8,r5
;;;380      
;;;381      /* Check ADC handle */
;;;382      if(hadc == NULL)
000062  b914              CBNZ     r4,|L1.106|
;;;383      {
;;;384        return HAL_ERROR;
000064  2001              MOVS     r0,#1
                  |L1.102|
;;;385      }
;;;386      
;;;387      /* Check the parameters */
;;;388      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;389      assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
;;;390      assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
;;;391      assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;392      assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
;;;393      
;;;394      if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
;;;395      {
;;;396        assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;397        assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
;;;398        if(hadc->Init.DiscontinuousConvMode != DISABLE)
;;;399        {
;;;400          assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
;;;401        }
;;;402      }
;;;403      
;;;404      /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
;;;405      /* at RCC top level.                                                        */
;;;406      /* Refer to header of this file for more details on clock enabling          */
;;;407      /* procedure.                                                               */
;;;408    
;;;409      /* Actions performed only if ADC is coming from state reset:                */
;;;410      /* - Initialization of ADC MSP                                              */
;;;411      if (hadc->State == HAL_ADC_STATE_RESET)
;;;412      {
;;;413        /* Initialize ADC error code */
;;;414        ADC_CLEAR_ERRORCODE(hadc);
;;;415        
;;;416        /* Allocate lock resource and initialize it */
;;;417        hadc->Lock = HAL_UNLOCKED;
;;;418        
;;;419        /* Init the low level hardware */
;;;420        HAL_ADC_MspInit(hadc);
;;;421      }
;;;422      
;;;423      /* Stop potential conversion on going, on regular and injected groups */
;;;424      /* Disable ADC peripheral */
;;;425      /* Note: In case of ADC already enabled, precaution to not launch an        */
;;;426      /*       unwanted conversion while modifying register CR2 by writing 1 to   */
;;;427      /*       bit ADON.                                                          */
;;;428      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;429      
;;;430      
;;;431      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;432      /* correctly completed.                                                     */
;;;433      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
;;;434          (tmp_hal_status == HAL_OK)                                  )
;;;435      {
;;;436        /* Set ADC state */
;;;437        ADC_STATE_CLR_SET(hadc->State,
;;;438                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;439                          HAL_ADC_STATE_BUSY_INTERNAL);
;;;440        
;;;441        /* Set ADC parameters */
;;;442        
;;;443        /* Configuration of ADC:                                                  */
;;;444        /*  - data alignment                                                      */
;;;445        /*  - external trigger to start conversion                                */
;;;446        /*  - external trigger polarity (always set to 1, because needed for all  */
;;;447        /*    triggers: external trigger of SW start)                             */
;;;448        /*  - continuous conversion mode                                          */
;;;449        /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
;;;450        /*       HAL_ADC_Start_xxx functions because if set in this function,     */
;;;451        /*       a conversion on injected group would start a conversion also on  */
;;;452        /*       regular group after ADC enabling.                                */
;;;453        tmp_cr2 |= (hadc->Init.DataAlign                               |
;;;454                    ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
;;;455                    ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
;;;456        
;;;457        /* Configuration of ADC:                                                  */
;;;458        /*  - scan mode                                                           */
;;;459        /*  - discontinuous mode disable/enable                                   */
;;;460        /*  - discontinuous mode number of conversions                            */
;;;461        tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
;;;462        
;;;463        /* Enable discontinuous mode only if continuous mode is disabled */
;;;464        /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
;;;465        /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
;;;466        if (hadc->Init.DiscontinuousConvMode == ENABLE)
;;;467        {
;;;468          if (hadc->Init.ContinuousConvMode == DISABLE)
;;;469          {
;;;470            /* Enable the selected ADC regular discontinuous mode */
;;;471            /* Set the number of channels to be converted in discontinuous mode */
;;;472            SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
;;;473                             ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
;;;474          }
;;;475          else
;;;476          {
;;;477            /* ADC regular group settings continuous and sequencer discontinuous*/
;;;478            /* cannot be enabled simultaneously.                                */
;;;479            
;;;480            /* Update ADC state machine to error */
;;;481            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;482            
;;;483            /* Set ADC error code to ADC IP internal error */
;;;484            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;485          }
;;;486        }
;;;487        
;;;488        /* Update ADC configuration register CR1 with previous settings */
;;;489          MODIFY_REG(hadc->Instance->CR1,
;;;490                     ADC_CR1_SCAN    |
;;;491                     ADC_CR1_DISCEN  |
;;;492                     ADC_CR1_DISCNUM    ,
;;;493                     tmp_cr1             );
;;;494        
;;;495        /* Update ADC configuration register CR2 with previous settings */
;;;496          MODIFY_REG(hadc->Instance->CR2,
;;;497                     ADC_CR2_ALIGN   |
;;;498                     ADC_CR2_EXTSEL  |
;;;499                     ADC_CR2_EXTTRIG |
;;;500                     ADC_CR2_CONT       ,
;;;501                     tmp_cr2             );
;;;502    
;;;503        /* Configuration of regular group sequencer:                              */
;;;504        /* - if scan mode is disabled, regular channels sequence length is set to */
;;;505        /*   0x00: 1 channel converted (channel on regular rank 1)                */
;;;506        /*   Parameter "NbrOfConversion" is discarded.                            */
;;;507        /*   Note: Scan mode is present by hardware on this device and, if        */
;;;508        /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
;;;509        /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
;;;510        /* - if scan mode is enabled, regular channels sequence length is set to  */
;;;511        /*   parameter "NbrOfConversion"                                          */
;;;512        if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
;;;513        {
;;;514          tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
;;;515        }
;;;516          
;;;517        MODIFY_REG(hadc->Instance->SQR1,
;;;518                   ADC_SQR1_L          ,
;;;519                   tmp_sqr1             );
;;;520        
;;;521        /* Check back that ADC registers have effectively been configured to      */
;;;522        /* ensure of no potential problem of ADC core IP clocking.                */
;;;523        /* Check through register CR2 (excluding bits set in other functions:     */
;;;524        /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
;;;525        /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
;;;526        /* measurement path bit (TSVREFE).                                        */
;;;527        if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
;;;528                                            ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
;;;529                                            ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
;;;530                                            ADC_CR2_TSVREFE                     ))
;;;531             == tmp_cr2)
;;;532        {
;;;533          /* Set ADC error code to none */
;;;534          ADC_CLEAR_ERRORCODE(hadc);
;;;535          
;;;536          /* Set the ADC state */
;;;537          ADC_STATE_CLR_SET(hadc->State,
;;;538                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;539                            HAL_ADC_STATE_READY);
;;;540        }
;;;541        else
;;;542        {
;;;543          /* Update ADC state machine to error */
;;;544          ADC_STATE_CLR_SET(hadc->State,
;;;545                            HAL_ADC_STATE_BUSY_INTERNAL,
;;;546                            HAL_ADC_STATE_ERROR_INTERNAL);
;;;547          
;;;548          /* Set ADC error code to ADC IP internal error */
;;;549          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
;;;550          
;;;551          tmp_hal_status = HAL_ERROR;
;;;552        }
;;;553      
;;;554      }
;;;555      else
;;;556      {
;;;557        /* Update ADC state machine to error */
;;;558        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
;;;559            
;;;560        tmp_hal_status = HAL_ERROR;
;;;561      }
;;;562      
;;;563      /* Return function status */
;;;564      return tmp_hal_status;
;;;565    }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L1.106|
00006a  68a0              LDR      r0,[r4,#8]            ;394
00006c  b110              CBZ      r0,|L1.116|
00006e  6960              LDR      r0,[r4,#0x14]         ;398
000070  b100              CBZ      r0,|L1.116|
000072  bf00              NOP                            ;400
                  |L1.116|
000074  6aa0              LDR      r0,[r4,#0x28]         ;411
000076  b930              CBNZ     r0,|L1.134|
000078  2000              MOVS     r0,#0                 ;414
00007a  62e0              STR      r0,[r4,#0x2c]         ;414
00007c  f8840024          STRB     r0,[r4,#0x24]         ;417
000080  4620              MOV      r0,r4                 ;420
000082  f7fffffe          BL       HAL_ADC_MspInit
                  |L1.134|
000086  4620              MOV      r0,r4                 ;428
000088  f7fffffe          BL       ADC_ConversionStop_Disable
00008c  4607              MOV      r7,r0                 ;428
00008e  6aa0              LDR      r0,[r4,#0x28]         ;433
000090  f0000010          AND      r0,r0,#0x10           ;433
000094  2800              CMP      r0,#0                 ;433
                  |L1.150|
000096  d176              BNE      |L1.390|
000098  2f00              CMP      r7,#0                 ;434
00009a  d1fc              BNE      |L1.150|
00009c  6aa0              LDR      r0,[r4,#0x28]         ;437
00009e  f4205088          BIC      r0,r0,#0x1100         ;437
0000a2  f0400002          ORR      r0,r0,#2              ;437
0000a6  62a0              STR      r0,[r4,#0x28]         ;437
0000a8  69e1              LDR      r1,[r4,#0x1c]         ;453
0000aa  6860              LDR      r0,[r4,#4]            ;453
0000ac  4308              ORRS     r0,r0,r1              ;453
0000ae  2202              MOVS     r2,#2                 ;453
0000b0  fa92f2a2          RBIT     r2,r2                 ;453
0000b4  fab2f282          CLZ      r2,r2                 ;453
0000b8  68e1              LDR      r1,[r4,#0xc]          ;453
0000ba  4091              LSLS     r1,r1,r2              ;453
0000bc  4308              ORRS     r0,r0,r1              ;453
0000be  4306              ORRS     r6,r6,r0              ;453
0000c0  68a0              LDR      r0,[r4,#8]            ;461
0000c2  f5b07f80          CMP      r0,#0x100             ;461
0000c6  d002              BEQ      |L1.206|
0000c8  68a0              LDR      r0,[r4,#8]            ;461
0000ca  2801              CMP      r0,#1                 ;461
0000cc  d102              BNE      |L1.212|
                  |L1.206|
0000ce  f44f7080          MOV      r0,#0x100             ;461
0000d2  e000              B        |L1.214|
                  |L1.212|
0000d4  2000              MOVS     r0,#0                 ;461
                  |L1.214|
0000d6  4305              ORRS     r5,r5,r0              ;461
0000d8  6960              LDR      r0,[r4,#0x14]         ;466
0000da  2801              CMP      r0,#1                 ;466
0000dc  d116              BNE      |L1.268|
0000de  68e0              LDR      r0,[r4,#0xc]          ;468
0000e0  b960              CBNZ     r0,|L1.252|
0000e2  69a0              LDR      r0,[r4,#0x18]         ;472
0000e4  1e40              SUBS     r0,r0,#1              ;472
0000e6  f44f4160          MOV      r1,#0xe000            ;472
0000ea  fa91f1a1          RBIT     r1,r1                 ;472
0000ee  fab1f181          CLZ      r1,r1                 ;472
0000f2  4088              LSLS     r0,r0,r1              ;472
0000f4  f4406000          ORR      r0,r0,#0x800          ;472
0000f8  4305              ORRS     r5,r5,r0              ;472
0000fa  e007              B        |L1.268|
                  |L1.252|
0000fc  6aa0              LDR      r0,[r4,#0x28]         ;481
0000fe  f0400020          ORR      r0,r0,#0x20           ;481
000102  62a0              STR      r0,[r4,#0x28]         ;481
000104  6ae0              LDR      r0,[r4,#0x2c]         ;484
000106  f0400001          ORR      r0,r0,#1              ;484
00010a  62e0              STR      r0,[r4,#0x2c]         ;484
                  |L1.268|
00010c  6820              LDR      r0,[r4,#0]            ;489
00010e  6840              LDR      r0,[r0,#4]            ;489
000110  f4204069          BIC      r0,r0,#0xe900         ;489
000114  4328              ORRS     r0,r0,r5              ;489
000116  6821              LDR      r1,[r4,#0]            ;489
000118  6048              STR      r0,[r1,#4]            ;489
00011a  6820              LDR      r0,[r4,#0]            ;496
00011c  6880              LDR      r0,[r0,#8]            ;496
00011e  49fa              LDR      r1,|L1.1288|
000120  4008              ANDS     r0,r0,r1              ;496
000122  4330              ORRS     r0,r0,r6              ;496
000124  6821              LDR      r1,[r4,#0]            ;496
000126  6088              STR      r0,[r1,#8]            ;496
000128  68a0              LDR      r0,[r4,#8]            ;512
00012a  f5b07f80          CMP      r0,#0x100             ;512
00012e  d002              BEQ      |L1.310|
000130  68a0              LDR      r0,[r4,#8]            ;512
000132  2801              CMP      r0,#1                 ;512
000134  d102              BNE      |L1.316|
                  |L1.310|
000136  f44f7080          MOV      r0,#0x100             ;512
00013a  e000              B        |L1.318|
                  |L1.316|
00013c  2000              MOVS     r0,#0                 ;512
                  |L1.318|
00013e  f5b07f80          CMP      r0,#0x100             ;512
000142  d109              BNE      |L1.344|
000144  6920              LDR      r0,[r4,#0x10]         ;514
000146  1e40              SUBS     r0,r0,#1              ;514
000148  f44f0170          MOV      r1,#0xf00000          ;514
00014c  fa91f1a1          RBIT     r1,r1                 ;514
000150  fab1f181          CLZ      r1,r1                 ;514
000154  fa00f801          LSL      r8,r0,r1              ;514
                  |L1.344|
000158  6820              LDR      r0,[r4,#0]            ;517
00015a  6ac0              LDR      r0,[r0,#0x2c]         ;517
00015c  f4200070          BIC      r0,r0,#0xf00000       ;517
000160  ea400008          ORR      r0,r0,r8              ;517
000164  6821              LDR      r1,[r4,#0]            ;517
000166  62c8              STR      r0,[r1,#0x2c]         ;517
000168  6820              LDR      r0,[r4,#0]            ;527
00016a  6880              LDR      r0,[r0,#8]            ;527
00016c  49e7              LDR      r1,|L1.1292|
00016e  4008              ANDS     r0,r0,r1              ;527
000170  42b0              CMP      r0,r6                 ;527
000172  d109              BNE      |L1.392|
000174  2000              MOVS     r0,#0                 ;534
000176  62e0              STR      r0,[r4,#0x2c]         ;534
000178  6aa0              LDR      r0,[r4,#0x28]         ;537
00017a  f0200002          BIC      r0,r0,#2              ;537
00017e  f0400001          ORR      r0,r0,#1              ;537
000182  62a0              STR      r0,[r4,#0x28]         ;537
000184  e011              B        |L1.426|
                  |L1.390|
000186  e00b              B        |L1.416|
                  |L1.392|
000188  6aa0              LDR      r0,[r4,#0x28]         ;544
00018a  f0200002          BIC      r0,r0,#2              ;544
00018e  f0400010          ORR      r0,r0,#0x10           ;544
000192  62a0              STR      r0,[r4,#0x28]         ;544
000194  6ae0              LDR      r0,[r4,#0x2c]         ;549
000196  f0400001          ORR      r0,r0,#1              ;549
00019a  62e0              STR      r0,[r4,#0x2c]         ;549
00019c  2701              MOVS     r7,#1                 ;551
00019e  e004              B        |L1.426|
                  |L1.416|
0001a0  6aa0              LDR      r0,[r4,#0x28]         ;558
0001a2  f0400010          ORR      r0,r0,#0x10           ;558
0001a6  62a0              STR      r0,[r4,#0x28]         ;558
0001a8  2701              MOVS     r7,#1                 ;560
                  |L1.426|
0001aa  4638              MOV      r0,r7                 ;564
0001ac  e75b              B        |L1.102|
;;;566    
                          ENDP

                  HAL_ADC_MspDeInit PROC
;;;726      */
;;;727    __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
0001ae  4770              BX       lr
;;;728    {
;;;729      /* Prevent unused argument(s) compilation warning */
;;;730      UNUSED(hadc);
;;;731      /* NOTE : This function should not be modified. When the callback is needed,
;;;732                function HAL_ADC_MspDeInit must be implemented in the user file.
;;;733       */ 
;;;734    }
;;;735    
                          ENDP

                  HAL_ADC_DeInit PROC
;;;574      */
;;;575    HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
0001b0  b570              PUSH     {r4-r6,lr}
;;;576    {
0001b2  4604              MOV      r4,r0
;;;577      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
0001b4  2500              MOVS     r5,#0
;;;578      
;;;579      /* Check ADC handle */
;;;580      if(hadc == NULL)
0001b6  b90c              CBNZ     r4,|L1.444|
;;;581      {
;;;582         return HAL_ERROR;
0001b8  2001              MOVS     r0,#1
                  |L1.442|
;;;583      }
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;587      
;;;588      /* Set ADC state */
;;;589      SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
;;;590      
;;;591      /* Stop potential conversion on going, on regular and injected groups */
;;;592      /* Disable ADC peripheral */
;;;593      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;594      
;;;595      
;;;596      /* Configuration of ADC parameters if previous preliminary actions are      */ 
;;;597      /* correctly completed.                                                     */
;;;598      if (tmp_hal_status == HAL_OK)
;;;599      {
;;;600        /* ========== Reset ADC registers ========== */
;;;601    
;;;602    
;;;603    
;;;604    
;;;605        /* Reset register SR */
;;;606        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
;;;607                                    ADC_FLAG_JSTRT | ADC_FLAG_STRT));
;;;608                             
;;;609        /* Reset register CR1 */
;;;610        CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
;;;611                                        ADC_CR1_JDISCEN | ADC_CR1_DISCEN | ADC_CR1_JAUTO   | 
;;;612                                        ADC_CR1_AWDSGL  | ADC_CR1_SCAN   | ADC_CR1_JEOCIE  |   
;;;613                                        ADC_CR1_AWDIE   | ADC_CR1_EOCIE  | ADC_CR1_AWDCH    ));
;;;614        
;;;615        /* Reset register CR2 */
;;;616        CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
;;;617                                        ADC_CR2_EXTTRIG | ADC_CR2_EXTSEL  | ADC_CR2_JEXTTRIG |  
;;;618                                        ADC_CR2_JEXTSEL | ADC_CR2_ALIGN   | ADC_CR2_DMA      |        
;;;619                                        ADC_CR2_RSTCAL  | ADC_CR2_CAL     | ADC_CR2_CONT     |          
;;;620                                        ADC_CR2_ADON                                          ));
;;;621        
;;;622        /* Reset register SMPR1 */
;;;623        CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
;;;624                                          ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP12 | 
;;;625                                          ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10                    ));
;;;626        
;;;627        /* Reset register SMPR2 */
;;;628        CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
;;;629                                          ADC_SMPR2_SMP6 | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | 
;;;630                                          ADC_SMPR2_SMP3 | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | 
;;;631                                          ADC_SMPR2_SMP0                                    ));
;;;632    
;;;633        /* Reset register JOFR1 */
;;;634        CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
;;;635        /* Reset register JOFR2 */
;;;636        CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
;;;637        /* Reset register JOFR3 */
;;;638        CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
;;;639        /* Reset register JOFR4 */
;;;640        CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
;;;641        
;;;642        /* Reset register HTR */
;;;643        CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
;;;644        /* Reset register LTR */
;;;645        CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
;;;646        
;;;647        /* Reset register SQR1 */
;;;648        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;649                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;650                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;651        
;;;652        /* Reset register SQR1 */
;;;653        CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
;;;654                                        ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
;;;655                                        ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
;;;656        
;;;657        /* Reset register SQR2 */
;;;658        CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
;;;659                                        ADC_SQR2_SQ9  | ADC_SQR2_SQ8  | ADC_SQR2_SQ7   );
;;;660        
;;;661        /* Reset register SQR3 */
;;;662        CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
;;;663                                        ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1  );
;;;664        
;;;665        /* Reset register JSQR */
;;;666        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;667                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;668                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;669        
;;;670        /* Reset register JSQR */
;;;671        CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
;;;672                                        ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
;;;673                                        ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
;;;674        
;;;675        /* Reset register DR */
;;;676        /* bits in access mode read only, no direct reset applicable*/
;;;677        
;;;678        /* Reset registers JDR1, JDR2, JDR3, JDR4 */
;;;679        /* bits in access mode read only, no direct reset applicable*/
;;;680        
;;;681        /* ========== Hard reset ADC peripheral ========== */
;;;682        /* Performs a global reset of the entire ADC peripheral: ADC state is     */
;;;683        /* forced to a similar state after device power-on.                       */
;;;684        /* If needed, copy-paste and uncomment the following reset code into      */
;;;685        /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
;;;686        /*                                                                        */
;;;687        /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
;;;688        /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
;;;689        
;;;690        /* DeInit the low level hardware */
;;;691        HAL_ADC_MspDeInit(hadc);
;;;692        
;;;693        /* Set ADC error code to none */
;;;694        ADC_CLEAR_ERRORCODE(hadc);
;;;695        
;;;696        /* Set ADC state */
;;;697        hadc->State = HAL_ADC_STATE_RESET; 
;;;698      
;;;699      }
;;;700      
;;;701      /* Process unlocked */
;;;702      __HAL_UNLOCK(hadc);
;;;703      
;;;704      /* Return function status */
;;;705      return tmp_hal_status;
;;;706    }
0001ba  bd70              POP      {r4-r6,pc}
                  |L1.444|
0001bc  6aa0              LDR      r0,[r4,#0x28]         ;589
0001be  f0400002          ORR      r0,r0,#2              ;589
0001c2  62a0              STR      r0,[r4,#0x28]         ;589
0001c4  4620              MOV      r0,r4                 ;593
0001c6  f7fffffe          BL       ADC_ConversionStop_Disable
0001ca  4605              MOV      r5,r0                 ;593
0001cc  2d00              CMP      r5,#0                 ;598
0001ce  d169              BNE      |L1.676|
0001d0  f06f001f          MVN      r0,#0x1f              ;606
0001d4  6821              LDR      r1,[r4,#0]            ;606
0001d6  6008              STR      r0,[r1,#0]            ;606
0001d8  6820              LDR      r0,[r4,#0]            ;610
0001da  6840              LDR      r0,[r0,#4]            ;610
0001dc  49cc              LDR      r1,|L1.1296|
0001de  4008              ANDS     r0,r0,r1              ;610
0001e0  6821              LDR      r1,[r4,#0]            ;610
0001e2  6048              STR      r0,[r1,#4]            ;610
0001e4  6820              LDR      r0,[r4,#0]            ;616
0001e6  6880              LDR      r0,[r0,#8]            ;616
0001e8  49ca              LDR      r1,|L1.1300|
0001ea  4008              ANDS     r0,r0,r1              ;616
0001ec  6821              LDR      r1,[r4,#0]            ;616
0001ee  6088              STR      r0,[r1,#8]            ;616
0001f0  6820              LDR      r0,[r4,#0]            ;623
0001f2  68c0              LDR      r0,[r0,#0xc]          ;623
0001f4  f000407f          AND      r0,r0,#0xff000000     ;623
0001f8  6821              LDR      r1,[r4,#0]            ;623
0001fa  60c8              STR      r0,[r1,#0xc]          ;623
0001fc  6820              LDR      r0,[r4,#0]            ;628
0001fe  6900              LDR      r0,[r0,#0x10]         ;628
000200  f0004040          AND      r0,r0,#0xc0000000     ;628
000204  6821              LDR      r1,[r4,#0]            ;628
000206  6108              STR      r0,[r1,#0x10]         ;628
000208  6820              LDR      r0,[r4,#0]            ;634
00020a  6940              LDR      r0,[r0,#0x14]         ;634
00020c  f36f000b          BFC      r0,#0,#12             ;634
000210  6821              LDR      r1,[r4,#0]            ;634
000212  6148              STR      r0,[r1,#0x14]         ;634
000214  6820              LDR      r0,[r4,#0]            ;636
000216  6980              LDR      r0,[r0,#0x18]         ;636
000218  f36f000b          BFC      r0,#0,#12             ;636
00021c  6821              LDR      r1,[r4,#0]            ;636
00021e  6188              STR      r0,[r1,#0x18]         ;636
000220  6820              LDR      r0,[r4,#0]            ;638
000222  69c0              LDR      r0,[r0,#0x1c]         ;638
000224  f36f000b          BFC      r0,#0,#12             ;638
000228  6821              LDR      r1,[r4,#0]            ;638
00022a  61c8              STR      r0,[r1,#0x1c]         ;638
00022c  6820              LDR      r0,[r4,#0]            ;640
00022e  6a00              LDR      r0,[r0,#0x20]         ;640
000230  f36f000b          BFC      r0,#0,#12             ;640
000234  6821              LDR      r1,[r4,#0]            ;640
000236  6208              STR      r0,[r1,#0x20]         ;640
000238  6820              LDR      r0,[r4,#0]            ;643
00023a  6a40              LDR      r0,[r0,#0x24]         ;643
00023c  f36f000b          BFC      r0,#0,#12             ;643
000240  6821              LDR      r1,[r4,#0]            ;643
000242  6248              STR      r0,[r1,#0x24]         ;643
000244  6820              LDR      r0,[r4,#0]            ;645
000246  6a80              LDR      r0,[r0,#0x28]         ;645
000248  f36f000b          BFC      r0,#0,#12             ;645
00024c  6821              LDR      r1,[r4,#0]            ;645
00024e  6288              STR      r0,[r1,#0x28]         ;645
000250  6820              LDR      r0,[r4,#0]            ;648
000252  6ac0              LDR      r0,[r0,#0x2c]         ;648
000254  f000407f          AND      r0,r0,#0xff000000     ;648
000258  6821              LDR      r1,[r4,#0]            ;648
00025a  62c8              STR      r0,[r1,#0x2c]         ;648
00025c  6820              LDR      r0,[r4,#0]            ;653
00025e  6ac0              LDR      r0,[r0,#0x2c]         ;653
000260  f000407f          AND      r0,r0,#0xff000000     ;653
000264  6821              LDR      r1,[r4,#0]            ;653
000266  62c8              STR      r0,[r1,#0x2c]         ;653
000268  6820              LDR      r0,[r4,#0]            ;658
00026a  6b00              LDR      r0,[r0,#0x30]         ;658
00026c  f0004040          AND      r0,r0,#0xc0000000     ;658
000270  6821              LDR      r1,[r4,#0]            ;658
000272  6308              STR      r0,[r1,#0x30]         ;658
000274  6820              LDR      r0,[r4,#0]            ;662
000276  6b40              LDR      r0,[r0,#0x34]         ;662
000278  f0004040          AND      r0,r0,#0xc0000000     ;662
00027c  6821              LDR      r1,[r4,#0]            ;662
00027e  6348              STR      r0,[r1,#0x34]         ;662
000280  6820              LDR      r0,[r4,#0]            ;666
000282  6b80              LDR      r0,[r0,#0x38]         ;666
000284  f36f0015          BFC      r0,#0,#22             ;666
000288  6821              LDR      r1,[r4,#0]            ;666
00028a  6388              STR      r0,[r1,#0x38]         ;666
00028c  6820              LDR      r0,[r4,#0]            ;671
00028e  6b80              LDR      r0,[r0,#0x38]         ;671
000290  f36f0015          BFC      r0,#0,#22             ;671
000294  6821              LDR      r1,[r4,#0]            ;671
000296  6388              STR      r0,[r1,#0x38]         ;671
000298  4620              MOV      r0,r4                 ;691
00029a  f7fffffe          BL       HAL_ADC_MspDeInit
00029e  2000              MOVS     r0,#0                 ;694
0002a0  62e0              STR      r0,[r4,#0x2c]         ;694
0002a2  62a0              STR      r0,[r4,#0x28]         ;697
                  |L1.676|
0002a4  bf00              NOP                            ;702
0002a6  2000              MOVS     r0,#0                 ;702
0002a8  f8840024          STRB     r0,[r4,#0x24]         ;702
0002ac  bf00              NOP                            ;702
0002ae  4628              MOV      r0,r5                 ;705
0002b0  e783              B        |L1.442|
;;;707    
                          ENDP

                  ADC_Enable PROC
;;;1933     */
;;;1934   HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
0002b2  b538              PUSH     {r3-r5,lr}
;;;1935   {
0002b4  4604              MOV      r4,r0
;;;1936     uint32_t tickstart = 0;
0002b6  2500              MOVS     r5,#0
;;;1937     __IO uint32_t wait_loop_index = 0;
0002b8  2000              MOVS     r0,#0
0002ba  9000              STR      r0,[sp,#0]
;;;1938     
;;;1939     /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
;;;1940     /* enabling phase not yet completed: flag ADC ready not yet set).           */
;;;1941     /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
;;;1942     /* causes: ADC clock not running, ...).                                     */
;;;1943     if (ADC_IS_ENABLE(hadc) == RESET)
0002bc  6820              LDR      r0,[r4,#0]
0002be  6880              LDR      r0,[r0,#8]
0002c0  f0000001          AND      r0,r0,#1
0002c4  bb80              CBNZ     r0,|L1.808|
;;;1944     {
;;;1945       /* Enable the Peripheral */
;;;1946       __HAL_ADC_ENABLE(hadc);
0002c6  6820              LDR      r0,[r4,#0]
0002c8  6880              LDR      r0,[r0,#8]
0002ca  f0400001          ORR      r0,r0,#1
0002ce  6821              LDR      r1,[r4,#0]
0002d0  6088              STR      r0,[r1,#8]
;;;1947       
;;;1948       /* Delay for ADC stabilization time */
;;;1949       /* Compute number of CPU cycles to wait for */
;;;1950       wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
0002d2  4891              LDR      r0,|L1.1304|
0002d4  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0002d6  4991              LDR      r1,|L1.1308|
0002d8  fbb0f0f1          UDIV     r0,r0,r1
0002dc  9000              STR      r0,[sp,#0]
;;;1951       while(wait_loop_index != 0)
0002de  e002              B        |L1.742|
                  |L1.736|
;;;1952       {
;;;1953         wait_loop_index--;
0002e0  9800              LDR      r0,[sp,#0]
0002e2  1e40              SUBS     r0,r0,#1
0002e4  9000              STR      r0,[sp,#0]
                  |L1.742|
0002e6  9800              LDR      r0,[sp,#0]            ;1951
0002e8  2800              CMP      r0,#0                 ;1951
0002ea  d1f9              BNE      |L1.736|
;;;1954       }
;;;1955       
;;;1956       /* Get tick count */
;;;1957       tickstart = HAL_GetTick();
0002ec  f7fffffe          BL       HAL_GetTick
0002f0  4605              MOV      r5,r0
;;;1958   
;;;1959       /* Wait for ADC effectively enabled */
;;;1960       while(ADC_IS_ENABLE(hadc) == RESET)
0002f2  e013              B        |L1.796|
                  |L1.756|
;;;1961       {
;;;1962         if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
0002f4  f7fffffe          BL       HAL_GetTick
0002f8  1b40              SUBS     r0,r0,r5
0002fa  2802              CMP      r0,#2
0002fc  d90e              BLS      |L1.796|
;;;1963         {
;;;1964           /* Update ADC state machine to error */
;;;1965           SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
0002fe  6aa0              LDR      r0,[r4,#0x28]
000300  f0400010          ORR      r0,r0,#0x10
000304  62a0              STR      r0,[r4,#0x28]
;;;1966         
;;;1967           /* Set ADC error code to ADC IP internal error */
;;;1968           SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
000306  6ae0              LDR      r0,[r4,#0x2c]
000308  f0400001          ORR      r0,r0,#1
00030c  62e0              STR      r0,[r4,#0x2c]
;;;1969           
;;;1970           /* Process unlocked */
;;;1971           __HAL_UNLOCK(hadc);
00030e  bf00              NOP      
000310  2000              MOVS     r0,#0
000312  f8840024          STRB     r0,[r4,#0x24]
000316  bf00              NOP      
;;;1972         
;;;1973           return HAL_ERROR;
000318  2001              MOVS     r0,#1
                  |L1.794|
;;;1974         }
;;;1975       }
;;;1976     }
;;;1977      
;;;1978     /* Return HAL status */
;;;1979     return HAL_OK;
;;;1980   }
00031a  bd38              POP      {r3-r5,pc}
                  |L1.796|
00031c  6820              LDR      r0,[r4,#0]            ;1960
00031e  6880              LDR      r0,[r0,#8]            ;1960
000320  f0000001          AND      r0,r0,#1              ;1960
000324  2800              CMP      r0,#0                 ;1960
000326  d0e5              BEQ      |L1.756|
                  |L1.808|
000328  2000              MOVS     r0,#0                 ;1979
00032a  e7f6              B        |L1.794|
;;;1981   
                          ENDP

                  HAL_ADC_Start PROC
;;;767      */
;;;768    HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
00032c  b570              PUSH     {r4-r6,lr}
;;;769    {
00032e  4604              MOV      r4,r0
;;;770      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000330  2500              MOVS     r5,#0
;;;771      
;;;772      /* Check the parameters */
;;;773      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;774      
;;;775      /* Process locked */
;;;776      __HAL_LOCK(hadc);
000332  bf00              NOP      
000334  f8940024          LDRB     r0,[r4,#0x24]
000338  2801              CMP      r0,#1
00033a  d101              BNE      |L1.832|
00033c  2002              MOVS     r0,#2
                  |L1.830|
;;;777       
;;;778      /* Enable the ADC peripheral */
;;;779      tmp_hal_status = ADC_Enable(hadc);
;;;780      
;;;781      /* Start conversion if ADC is effectively enabled */
;;;782      if (tmp_hal_status == HAL_OK)
;;;783      {
;;;784        /* Set ADC state                                                          */
;;;785        /* - Clear state bitfield related to regular group conversion results     */
;;;786        /* - Set state bitfield related to regular operation                      */
;;;787        ADC_STATE_CLR_SET(hadc->State,
;;;788                          HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC,
;;;789                          HAL_ADC_STATE_REG_BUSY);
;;;790        
;;;791        /* Set group injected state (from auto-injection) and multimode state     */
;;;792        /* for all cases of multimode: independent mode, multimode ADC master     */
;;;793        /* or multimode ADC slave (for devices with several ADCs):                */
;;;794        if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;795        {
;;;796          /* Set ADC state (ADC independent or master) */
;;;797          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;798          
;;;799          /* If conversions on group regular are also triggering group injected,  */
;;;800          /* update ADC state.                                                    */
;;;801          if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;802          {
;;;803            ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;804          }
;;;805        }
;;;806        else
;;;807        {
;;;808          /* Set ADC state (ADC slave) */
;;;809          SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;810          
;;;811          /* If conversions on group regular are also triggering group injected,  */
;;;812          /* update ADC state.                                                    */
;;;813          if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;814          {
;;;815            ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;816          }
;;;817        }
;;;818        
;;;819        /* State machine update: Check if an injected conversion is ongoing */
;;;820        if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;821        {
;;;822          /* Reset ADC error code fields related to conversions on group regular */
;;;823          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;824        }
;;;825        else
;;;826        {
;;;827          /* Reset ADC all error code fields */
;;;828          ADC_CLEAR_ERRORCODE(hadc);
;;;829        }
;;;830        
;;;831        /* Process unlocked */
;;;832        /* Unlock before starting ADC conversions: in case of potential           */
;;;833        /* interruption, to let the process to ADC IRQ Handler.                   */
;;;834        __HAL_UNLOCK(hadc);
;;;835      
;;;836        /* Clear regular group conversion flag */
;;;837        /* (To ensure of no unknown state from potential previous ADC operations) */
;;;838        __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;839        
;;;840        /* Enable conversion of regular group.                                    */
;;;841        /* If software start has been selected, conversion starts immediately.    */
;;;842        /* If external trigger has been selected, conversion will start at next   */
;;;843        /* trigger event.                                                         */
;;;844        /* Case of multimode enabled:                                             */ 
;;;845        /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;846        /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;847        /* If ADC is master, ADC is enabled and conversion is started.            */
;;;848        /* Note: Alternate trigger for single conversion could be to force an     */
;;;849        /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
;;;850        if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;851            ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;852        {
;;;853          /* Start ADC conversion on regular group with SW start */
;;;854          SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;855        }
;;;856        else
;;;857        {
;;;858          /* Start ADC conversion on regular group with external trigger */
;;;859          SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;860        }
;;;861      }
;;;862      else
;;;863      {
;;;864        /* Process unlocked */
;;;865        __HAL_UNLOCK(hadc);
;;;866      }
;;;867        
;;;868      /* Return function status */
;;;869      return tmp_hal_status;
;;;870    }
00033e  bd70              POP      {r4-r6,pc}
                  |L1.832|
000340  2001              MOVS     r0,#1                 ;776
000342  f8840024          STRB     r0,[r4,#0x24]         ;776
000346  bf00              NOP                            ;776
000348  4620              MOV      r0,r4                 ;779
00034a  f7fffffe          BL       ADC_Enable
00034e  4605              MOV      r5,r0                 ;779
000350  bbbd              CBNZ     r5,|L1.962|
000352  6aa0              LDR      r0,[r4,#0x28]         ;787
000354  f2402101          MOV      r1,#0x201             ;787
000358  4388              BICS     r0,r0,r1              ;787
00035a  f4407080          ORR      r0,r0,#0x100          ;787
00035e  62a0              STR      r0,[r4,#0x28]         ;787
000360  6aa0              LDR      r0,[r4,#0x28]         ;797
000362  f4201080          BIC      r0,r0,#0x100000       ;797
000366  62a0              STR      r0,[r4,#0x28]         ;797
000368  6820              LDR      r0,[r4,#0]            ;801
00036a  6840              LDR      r0,[r0,#4]            ;801
00036c  f4006080          AND      r0,r0,#0x400          ;801
000370  b128              CBZ      r0,|L1.894|
000372  6aa0              LDR      r0,[r4,#0x28]         ;803
000374  f4205000          BIC      r0,r0,#0x2000         ;803
000378  f4405080          ORR      r0,r0,#0x1000         ;803
00037c  62a0              STR      r0,[r4,#0x28]         ;803
                  |L1.894|
00037e  6aa0              LDR      r0,[r4,#0x28]         ;820
000380  f4005080          AND      r0,r0,#0x1000         ;820
000384  b120              CBZ      r0,|L1.912|
000386  6ae0              LDR      r0,[r4,#0x2c]         ;823
000388  f0200006          BIC      r0,r0,#6              ;823
00038c  62e0              STR      r0,[r4,#0x2c]         ;823
00038e  e001              B        |L1.916|
                  |L1.912|
000390  2000              MOVS     r0,#0                 ;828
000392  62e0              STR      r0,[r4,#0x2c]         ;828
                  |L1.916|
000394  bf00              NOP                            ;834
000396  2000              MOVS     r0,#0                 ;834
000398  f8840024          STRB     r0,[r4,#0x24]         ;834
00039c  bf00              NOP                            ;834
00039e  1ec0              SUBS     r0,r0,#3              ;838
0003a0  6821              LDR      r1,[r4,#0]            ;838
0003a2  6008              STR      r0,[r1,#0]            ;838
0003a4  6820              LDR      r0,[r4,#0]            ;850
0003a6  6880              LDR      r0,[r0,#8]            ;850
0003a8  f4002060          AND      r0,r0,#0xe0000        ;850
0003ac  f5b02f60          CMP      r0,#0xe0000           ;850
0003b0  d108              BNE      |L1.964|
0003b2  bf00              NOP                            ;851
0003b4  6820              LDR      r0,[r4,#0]            ;854
0003b6  6880              LDR      r0,[r0,#8]            ;854
0003b8  f44000a0          ORR      r0,r0,#0x500000       ;854
0003bc  6821              LDR      r1,[r4,#0]            ;854
0003be  6088              STR      r0,[r1,#8]            ;854
0003c0  e00c              B        |L1.988|
                  |L1.962|
0003c2  e006              B        |L1.978|
                  |L1.964|
0003c4  6820              LDR      r0,[r4,#0]            ;859
0003c6  6880              LDR      r0,[r0,#8]            ;859
0003c8  f4401080          ORR      r0,r0,#0x100000       ;859
0003cc  6821              LDR      r1,[r4,#0]            ;859
0003ce  6088              STR      r0,[r1,#8]            ;859
0003d0  e004              B        |L1.988|
                  |L1.978|
0003d2  bf00              NOP                            ;865
0003d4  2000              MOVS     r0,#0                 ;865
0003d6  f8840024          STRB     r0,[r4,#0x24]         ;865
0003da  bf00              NOP                            ;865
                  |L1.988|
0003dc  4628              MOV      r0,r5                 ;869
0003de  e7ae              B        |L1.830|
;;;871    
                          ENDP

                  HAL_ADC_Stop PROC
;;;880      */
;;;881    HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
0003e0  b570              PUSH     {r4-r6,lr}
;;;882    {
0003e2  4604              MOV      r4,r0
;;;883      HAL_StatusTypeDef tmp_hal_status = HAL_OK;
0003e4  2500              MOVS     r5,#0
;;;884      
;;;885      /* Check the parameters */
;;;886      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;887         
;;;888      /* Process locked */
;;;889      __HAL_LOCK(hadc);
0003e6  bf00              NOP      
0003e8  f8940024          LDRB     r0,[r4,#0x24]
0003ec  2801              CMP      r0,#1
0003ee  d101              BNE      |L1.1012|
0003f0  2002              MOVS     r0,#2
                  |L1.1010|
;;;890      
;;;891      /* Stop potential conversion on going, on regular and injected groups */
;;;892      /* Disable ADC peripheral */
;;;893      tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;894      
;;;895      /* Check if ADC is effectively disabled */
;;;896      if (tmp_hal_status == HAL_OK)
;;;897      {
;;;898        /* Set ADC state */
;;;899        ADC_STATE_CLR_SET(hadc->State,
;;;900                          HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;901                          HAL_ADC_STATE_READY);
;;;902      }
;;;903      
;;;904      /* Process unlocked */
;;;905      __HAL_UNLOCK(hadc);
;;;906      
;;;907      /* Return function status */
;;;908      return tmp_hal_status;
;;;909    }
0003f2  bd70              POP      {r4-r6,pc}
                  |L1.1012|
0003f4  2001              MOVS     r0,#1                 ;889
0003f6  f8840024          STRB     r0,[r4,#0x24]         ;889
0003fa  bf00              NOP                            ;889
0003fc  4620              MOV      r0,r4                 ;893
0003fe  f7fffffe          BL       ADC_ConversionStop_Disable
000402  4605              MOV      r5,r0                 ;893
000404  b92d              CBNZ     r5,|L1.1042|
000406  6aa0              LDR      r0,[r4,#0x28]         ;899
000408  f4205088          BIC      r0,r0,#0x1100         ;899
00040c  f0400001          ORR      r0,r0,#1              ;899
000410  62a0              STR      r0,[r4,#0x28]         ;899
                  |L1.1042|
000412  bf00              NOP                            ;905
000414  2000              MOVS     r0,#0                 ;905
000416  f8840024          STRB     r0,[r4,#0x24]         ;905
00041a  bf00              NOP                            ;905
00041c  4628              MOV      r0,r5                 ;908
00041e  e7e8              B        |L1.1010|
;;;910    
                          ENDP

                  HAL_ADC_PollForConversion PROC
;;;924      */
;;;925    HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
000420  b5f8              PUSH     {r3-r7,lr}
;;;926    {
000422  4604              MOV      r4,r0
000424  460d              MOV      r5,r1
;;;927      uint32_t tickstart = 0;
000426  2600              MOVS     r6,#0
;;;928      
;;;929      /* Variables for polling in case of scan mode enabled and polling for each  */
;;;930      /* conversion.                                                              */
;;;931      __IO uint32_t Conversion_Timeout_CPU_cycles = 0;
000428  2000              MOVS     r0,#0
00042a  9000              STR      r0,[sp,#0]
;;;932      uint32_t Conversion_Timeout_CPU_cycles_max = 0;
00042c  2700              MOVS     r7,#0
;;;933     
;;;934      /* Check the parameters */
;;;935      assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;936      
;;;937      /* Get tick count */
;;;938      tickstart = HAL_GetTick();
00042e  f7fffffe          BL       HAL_GetTick
000432  4606              MOV      r6,r0
;;;939      
;;;940      /* Verification that ADC configuration is compliant with polling for        */
;;;941      /* each conversion:                                                         */
;;;942      /* Particular case is ADC configured in DMA mode                            */
;;;943      if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
000434  6820              LDR      r0,[r4,#0]
000436  6880              LDR      r0,[r0,#8]
000438  f4007080          AND      r0,r0,#0x100
00043c  b150              CBZ      r0,|L1.1108|
;;;944      {
;;;945        /* Update ADC state machine to error */
;;;946        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
00043e  6aa0              LDR      r0,[r4,#0x28]
000440  f0400020          ORR      r0,r0,#0x20
000444  62a0              STR      r0,[r4,#0x28]
;;;947        
;;;948        /* Process unlocked */
;;;949        __HAL_UNLOCK(hadc);
000446  bf00              NOP      
000448  2000              MOVS     r0,#0
00044a  f8840024          STRB     r0,[r4,#0x24]
00044e  bf00              NOP      
;;;950        
;;;951        return HAL_ERROR;
000450  2001              MOVS     r0,#1
                  |L1.1106|
;;;952      }
;;;953      
;;;954      /* Polling for end of conversion: differentiation if single/sequence        */
;;;955      /* conversion.                                                              */
;;;956      /*  - If single conversion for regular group (Scan mode disabled or enabled */
;;;957      /*    with NbrOfConversion =1), flag EOC is used to determine the           */
;;;958      /*    conversion completion.                                                */
;;;959      /*  - If sequence conversion for regular group (scan mode enabled and       */
;;;960      /*    NbrOfConversion >=2), flag EOC is set only at the end of the          */
;;;961      /*    sequence.                                                             */
;;;962      /*    To poll for each conversion, the maximum conversion time is computed  */
;;;963      /*    from ADC conversion time (selected sampling time + conversion time of */
;;;964      /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
;;;965      /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
;;;966      /*    As flag EOC is not set after each conversion, no timeout status can   */
;;;967      /*    be set.                                                               */
;;;968      if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
;;;969          HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
;;;970      {
;;;971        /* Wait until End of Conversion flag is raised */
;;;972        while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
;;;973        {
;;;974          /* Check if timeout is disabled (set to infinite wait) */
;;;975          if(Timeout != HAL_MAX_DELAY)
;;;976          {
;;;977            if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
;;;978            {
;;;979              /* Update ADC state machine to timeout */
;;;980              SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;981              
;;;982              /* Process unlocked */
;;;983              __HAL_UNLOCK(hadc);
;;;984              
;;;985              return HAL_TIMEOUT;
;;;986            }
;;;987          }
;;;988        }
;;;989      }
;;;990      else
;;;991      {
;;;992        /* Replace polling by wait for maximum conversion time */
;;;993        /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
;;;994        /*    and ADC maximum conversion cycles on all channels.                  */
;;;995        /*  - Wait for the expected ADC clock cycles delay                        */
;;;996        Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
;;;997                                              / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
;;;998                                             * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
;;;999        
;;;1000       while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
;;;1001       {
;;;1002         /* Check if timeout is disabled (set to infinite wait) */
;;;1003         if(Timeout != HAL_MAX_DELAY)
;;;1004         {
;;;1005           if((Timeout == 0) || ((HAL_GetTick() - tickstart) > Timeout))
;;;1006           {
;;;1007             /* Update ADC state machine to timeout */
;;;1008             SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
;;;1009             
;;;1010             /* Process unlocked */
;;;1011             __HAL_UNLOCK(hadc);
;;;1012             
;;;1013             return HAL_TIMEOUT;
;;;1014           }
;;;1015         }
;;;1016         Conversion_Timeout_CPU_cycles ++;
;;;1017       }
;;;1018     }
;;;1019     
;;;1020     /* Clear regular group conversion flag */
;;;1021     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
;;;1022     
;;;1023     /* Update ADC state machine */
;;;1024     SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
;;;1025     
;;;1026     /* Determine whether any further conversion upcoming on group regular       */
;;;1027     /* by external trigger, continuous mode or scan sequence on going.          */
;;;1028     /* Note: On STM32F1 devices, in case of sequencer enabled                   */
;;;1029     /*       (several ranks selected), end of conversion flag is raised         */
;;;1030     /*       at the end of the sequence.                                        */
;;;1031     if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
;;;1032        (hadc->Init.ContinuousConvMode == DISABLE)   )
;;;1033     {   
;;;1034       /* Set ADC state */
;;;1035       CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
;;;1036   
;;;1037       if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1038       { 
;;;1039         SET_BIT(hadc->State, HAL_ADC_STATE_READY);
;;;1040       }
;;;1041     }
;;;1042     
;;;1043     /* Return ADC state */
;;;1044     return HAL_OK;
;;;1045   }
000452  bdf8              POP      {r3-r7,pc}
                  |L1.1108|
000454  6820              LDR      r0,[r4,#0]            ;968
000456  6840              LDR      r0,[r0,#4]            ;968
000458  f4007080          AND      r0,r0,#0x100          ;968
00045c  b9f8              CBNZ     r0,|L1.1182|
00045e  6820              LDR      r0,[r4,#0]            ;969
000460  6ac0              LDR      r0,[r0,#0x2c]         ;969
000462  f4000070          AND      r0,r0,#0xf00000       ;969
000466  b9d0              CBNZ     r0,|L1.1182|
000468  e012              B        |L1.1168|
                  |L1.1130|
00046a  1c68              ADDS     r0,r5,#1              ;975
00046c  b180              CBZ      r0,|L1.1168|
00046e  b125              CBZ      r5,|L1.1146|
000470  f7fffffe          BL       HAL_GetTick
000474  1b80              SUBS     r0,r0,r6              ;977
000476  42a8              CMP      r0,r5                 ;977
000478  d90a              BLS      |L1.1168|
                  |L1.1146|
00047a  6aa0              LDR      r0,[r4,#0x28]         ;980
00047c  f0400004          ORR      r0,r0,#4              ;980
000480  62a0              STR      r0,[r4,#0x28]         ;980
000482  bf00              NOP                            ;983
000484  2000              MOVS     r0,#0                 ;983
000486  f8840024          STRB     r0,[r4,#0x24]         ;983
00048a  bf00              NOP                            ;983
00048c  2003              MOVS     r0,#3                 ;985
00048e  e7e0              B        |L1.1106|
                  |L1.1168|
000490  6820              LDR      r0,[r4,#0]            ;972
000492  6800              LDR      r0,[r0,#0]            ;972
000494  f0000002          AND      r0,r0,#2              ;972
000498  2800              CMP      r0,#0                 ;972
00049a  d0e6              BEQ      |L1.1130|
00049c  e063              B        |L1.1382|
                  |L1.1182|
00049e  2002              MOVS     r0,#2                 ;996
0004a0  f7fffffe          BL       HAL_RCCEx_GetPeriphCLKFreq
0004a4  491c              LDR      r1,|L1.1304|
0004a6  6809              LDR      r1,[r1,#0]            ;996  ; SystemCoreClock
0004a8  fbb1f0f0          UDIV     r0,r1,r0              ;996
0004ac  6821              LDR      r1,[r4,#0]            ;996
0004ae  6909              LDR      r1,[r1,#0x10]         ;996
0004b0  4a1b              LDR      r2,|L1.1312|
0004b2  4011              ANDS     r1,r1,r2              ;996
0004b4  b991              CBNZ     r1,|L1.1244|
0004b6  6821              LDR      r1,[r4,#0]            ;998
0004b8  68c9              LDR      r1,[r1,#0xc]          ;998
0004ba  1192              ASRS     r2,r2,#6              ;998
0004bc  4011              ANDS     r1,r1,r2              ;998
0004be  b969              CBNZ     r1,|L1.1244|
0004c0  6821              LDR      r1,[r4,#0]            ;998
0004c2  6909              LDR      r1,[r1,#0x10]         ;998
0004c4  4a17              LDR      r2,|L1.1316|
0004c6  4011              ANDS     r1,r1,r2              ;998
0004c8  b931              CBNZ     r1,|L1.1240|
0004ca  6821              LDR      r1,[r4,#0]            ;998
0004cc  68c9              LDR      r1,[r1,#0xc]          ;998
0004ce  1192              ASRS     r2,r2,#6              ;998
0004d0  4011              ANDS     r1,r1,r2              ;998
0004d2  b909              CBNZ     r1,|L1.1240|
0004d4  2114              MOVS     r1,#0x14              ;998
0004d6  e02a              B        |L1.1326|
                  |L1.1240|
0004d8  2129              MOVS     r1,#0x29              ;998
0004da  e028              B        |L1.1326|
                  |L1.1244|
0004dc  6821              LDR      r1,[r4,#0]            ;998
0004de  6909              LDR      r1,[r1,#0x10]         ;998
0004e0  4a10              LDR      r2,|L1.1316|
0004e2  4011              ANDS     r1,r1,r2              ;998
0004e4  b921              CBNZ     r1,|L1.1264|
0004e6  6821              LDR      r1,[r4,#0]            ;998
0004e8  68c9              LDR      r1,[r1,#0xc]          ;998
0004ea  1192              ASRS     r2,r2,#6              ;998
0004ec  4011              ANDS     r1,r1,r2              ;998
0004ee  b141              CBZ      r1,|L1.1282|
                  |L1.1264|
0004f0  6821              LDR      r1,[r4,#0]            ;998
0004f2  6909              LDR      r1,[r1,#0x10]         ;998
0004f4  4a0c              LDR      r2,|L1.1320|
0004f6  4011              ANDS     r1,r1,r2              ;998
0004f8  b9c1              CBNZ     r1,|L1.1324|
0004fa  6821              LDR      r1,[r4,#0]            ;998
0004fc  68c9              LDR      r1,[r1,#0xc]          ;998
0004fe  4011              ANDS     r1,r1,r2              ;998
000500  b9a1              CBNZ     r1,|L1.1324|
                  |L1.1282|
000502  2154              MOVS     r1,#0x54              ;998
000504  e013              B        |L1.1326|
000506  0000              DCW      0x0000
                  |L1.1288|
                          DCD      0xffe1f7fd
                  |L1.1292|
                          DCD      0xff1f0efe
                  |L1.1296|
                          DCD      0xff3f0000
                  |L1.1300|
                          DCD      0xff0106f0
                  |L1.1304|
                          DCD      SystemCoreClock
                  |L1.1308|
                          DCD      0x000f4240
                  |L1.1312|
                          DCD      0x24924924
                  |L1.1316|
                          DCD      0x12492492
                  |L1.1320|
                          DCD      0x00249249
                  |L1.1324|
00052c  21fc              MOVS     r1,#0xfc              ;998
                  |L1.1326|
00052e  fb00f701          MUL      r7,r0,r1              ;998
000532  e015              B        |L1.1376|
                  |L1.1332|
000534  1c68              ADDS     r0,r5,#1              ;1003
000536  b180              CBZ      r0,|L1.1370|
000538  b125              CBZ      r5,|L1.1348|
00053a  f7fffffe          BL       HAL_GetTick
00053e  1b80              SUBS     r0,r0,r6              ;1005
000540  42a8              CMP      r0,r5                 ;1005
000542  d90a              BLS      |L1.1370|
                  |L1.1348|
000544  6aa0              LDR      r0,[r4,#0x28]         ;1008
000546  f0400004          ORR      r0,r0,#4              ;1008
00054a  62a0              STR      r0,[r4,#0x28]         ;1008
00054c  bf00              NOP                            ;1011
00054e  2000              MOVS     r0,#0                 ;1011
000550  f8840024          STRB     r0,[r4,#0x24]         ;1011
000554  bf00              NOP                            ;1011
000556  2003              MOVS     r0,#3                 ;1013
000558  e77b              B        |L1.1106|
                  |L1.1370|
00055a  9800              LDR      r0,[sp,#0]            ;1016
00055c  1c40              ADDS     r0,r0,#1              ;1016
00055e  9000              STR      r0,[sp,#0]            ;1016
                  |L1.1376|
000560  9800              LDR      r0,[sp,#0]            ;1000
000562  42b8              CMP      r0,r7                 ;1000
000564  d3e6              BCC      |L1.1332|
                  |L1.1382|
000566  f06f0012          MVN      r0,#0x12              ;1021
00056a  6821              LDR      r1,[r4,#0]            ;1021
00056c  6008              STR      r0,[r1,#0]            ;1021
00056e  6aa0              LDR      r0,[r4,#0x28]         ;1024
000570  f4407000          ORR      r0,r0,#0x200          ;1024
000574  62a0              STR      r0,[r4,#0x28]         ;1024
000576  6820              LDR      r0,[r4,#0]            ;1031
000578  6880              LDR      r0,[r0,#8]            ;1031
00057a  f4002060          AND      r0,r0,#0xe0000        ;1031
00057e  f5b02f60          CMP      r0,#0xe0000           ;1031
000582  d10d              BNE      |L1.1440|
000584  68e0              LDR      r0,[r4,#0xc]          ;1032
000586  b958              CBNZ     r0,|L1.1440|
000588  6aa0              LDR      r0,[r4,#0x28]         ;1035
00058a  f4207080          BIC      r0,r0,#0x100          ;1035
00058e  62a0              STR      r0,[r4,#0x28]         ;1035
000590  6aa0              LDR      r0,[r4,#0x28]         ;1037
000592  f4005080          AND      r0,r0,#0x1000         ;1037
000596  b918              CBNZ     r0,|L1.1440|
000598  6aa0              LDR      r0,[r4,#0x28]         ;1039
00059a  f0400001          ORR      r0,r0,#1              ;1039
00059e  62a0              STR      r0,[r4,#0x28]         ;1039
                  |L1.1440|
0005a0  2000              MOVS     r0,#0                 ;1044
0005a2  e756              B        |L1.1106|
;;;1046   
                          ENDP

                  HAL_ADC_PollForEvent PROC
;;;1055     */
;;;1056   HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
0005a4  e92d41f0          PUSH     {r4-r8,lr}
;;;1057   {
0005a8  4604              MOV      r4,r0
0005aa  460e              MOV      r6,r1
0005ac  4615              MOV      r5,r2
;;;1058     uint32_t tickstart = 0; 
0005ae  2700              MOVS     r7,#0
;;;1059   
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1062     assert_param(IS_ADC_EVENT_TYPE(EventType));
;;;1063     
;;;1064     /* Get tick count */
;;;1065     tickstart = HAL_GetTick();
0005b0  f7fffffe          BL       HAL_GetTick
0005b4  4607              MOV      r7,r0
;;;1066     
;;;1067     /* Check selected event flag */
;;;1068     while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
0005b6  e013              B        |L1.1504|
                  |L1.1464|
;;;1069     {
;;;1070       /* Check if timeout is disabled (set to infinite wait) */
;;;1071       if(Timeout != HAL_MAX_DELAY)
0005b8  1c68              ADDS     r0,r5,#1
0005ba  b188              CBZ      r0,|L1.1504|
;;;1072       {
;;;1073         if((Timeout == 0) || ((HAL_GetTick() - tickstart ) > Timeout))
0005bc  b125              CBZ      r5,|L1.1480|
0005be  f7fffffe          BL       HAL_GetTick
0005c2  1bc0              SUBS     r0,r0,r7
0005c4  42a8              CMP      r0,r5
0005c6  d90b              BLS      |L1.1504|
                  |L1.1480|
;;;1074         {
;;;1075           /* Update ADC state machine to timeout */
;;;1076           SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
0005c8  6aa0              LDR      r0,[r4,#0x28]
0005ca  f0400004          ORR      r0,r0,#4
0005ce  62a0              STR      r0,[r4,#0x28]
;;;1077           
;;;1078           /* Process unlocked */
;;;1079           __HAL_UNLOCK(hadc);
0005d0  bf00              NOP      
0005d2  2000              MOVS     r0,#0
0005d4  f8840024          STRB     r0,[r4,#0x24]
0005d8  bf00              NOP      
;;;1080           
;;;1081           return HAL_TIMEOUT;
0005da  2003              MOVS     r0,#3
                  |L1.1500|
;;;1082         }
;;;1083       }
;;;1084     }
;;;1085     
;;;1086     /* Analog watchdog (level out of window) event */
;;;1087     /* Set ADC state */
;;;1088     SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
;;;1089       
;;;1090     /* Clear ADC analog watchdog flag */
;;;1091     __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
;;;1092     
;;;1093     /* Return ADC state */
;;;1094     return HAL_OK;
;;;1095   }
0005dc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1504|
0005e0  6820              LDR      r0,[r4,#0]            ;1068
0005e2  6800              LDR      r0,[r0,#0]            ;1068
0005e4  4030              ANDS     r0,r0,r6              ;1068
0005e6  42b0              CMP      r0,r6                 ;1068
0005e8  d101              BNE      |L1.1518|
0005ea  2001              MOVS     r0,#1                 ;1068
0005ec  e000              B        |L1.1520|
                  |L1.1518|
0005ee  2000              MOVS     r0,#0                 ;1068
                  |L1.1520|
0005f0  2800              CMP      r0,#0                 ;1068
0005f2  d0e1              BEQ      |L1.1464|
0005f4  6aa0              LDR      r0,[r4,#0x28]         ;1088
0005f6  f4403080          ORR      r0,r0,#0x10000        ;1088
0005fa  62a0              STR      r0,[r4,#0x28]         ;1088
0005fc  f06f0001          MVN      r0,#1                 ;1091
000600  6821              LDR      r1,[r4,#0]            ;1091
000602  6008              STR      r0,[r1,#0]            ;1091
000604  2000              MOVS     r0,#0                 ;1094
000606  e7e9              B        |L1.1500|
;;;1096   
                          ENDP

                  HAL_ADC_Start_IT PROC
;;;1104     */
;;;1105   HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
000608  b570              PUSH     {r4-r6,lr}
;;;1106   {
00060a  4604              MOV      r4,r0
;;;1107     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
00060c  2500              MOVS     r5,#0
;;;1108     
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1111     
;;;1112     /* Process locked */
;;;1113     __HAL_LOCK(hadc);
00060e  bf00              NOP      
000610  f8940024          LDRB     r0,[r4,#0x24]
000614  2801              CMP      r0,#1
000616  d101              BNE      |L1.1564|
000618  2002              MOVS     r0,#2
                  |L1.1562|
;;;1114       
;;;1115     /* Enable the ADC peripheral */
;;;1116     tmp_hal_status = ADC_Enable(hadc);
;;;1117     
;;;1118     /* Start conversion if ADC is effectively enabled */
;;;1119     if (tmp_hal_status == HAL_OK)
;;;1120     {
;;;1121       /* Set ADC state                                                          */
;;;1122       /* - Clear state bitfield related to regular group conversion results     */
;;;1123       /* - Set state bitfield related to regular operation                      */
;;;1124       ADC_STATE_CLR_SET(hadc->State,
;;;1125                         HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1126                         HAL_ADC_STATE_REG_BUSY);
;;;1127       
;;;1128       /* Set group injected state (from auto-injection) and multimode state     */
;;;1129       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1130       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1131       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1132       {
;;;1133         /* Set ADC state (ADC independent or master) */
;;;1134         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1135         
;;;1136         /* If conversions on group regular are also triggering group injected,  */
;;;1137         /* update ADC state.                                                    */
;;;1138         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1139         {
;;;1140           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1141         }
;;;1142       }
;;;1143       else
;;;1144       {
;;;1145         /* Set ADC state (ADC slave) */
;;;1146         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1147         
;;;1148         /* If conversions on group regular are also triggering group injected,  */
;;;1149         /* update ADC state.                                                    */
;;;1150         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1151         {
;;;1152           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1153         }
;;;1154       }
;;;1155       
;;;1156       /* State machine update: Check if an injected conversion is ongoing */
;;;1157       if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1158       {
;;;1159         /* Reset ADC error code fields related to conversions on group regular */
;;;1160         CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1161       }
;;;1162       else
;;;1163       {
;;;1164         /* Reset ADC all error code fields */
;;;1165         ADC_CLEAR_ERRORCODE(hadc);
;;;1166       }
;;;1167       
;;;1168       /* Process unlocked */
;;;1169       /* Unlock before starting ADC conversions: in case of potential           */
;;;1170       /* interruption, to let the process to ADC IRQ Handler.                   */
;;;1171       __HAL_UNLOCK(hadc);
;;;1172       
;;;1173       /* Clear regular group conversion flag and overrun flag */
;;;1174       /* (To ensure of no unknown state from potential previous ADC operations) */
;;;1175       __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1176       
;;;1177       /* Enable end of conversion interrupt for regular group */
;;;1178       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
;;;1179       
;;;1180       /* Enable conversion of regular group.                                    */
;;;1181       /* If software start has been selected, conversion starts immediately.    */
;;;1182       /* If external trigger has been selected, conversion will start at next   */
;;;1183       /* trigger event.                                                         */
;;;1184       /* Case of multimode enabled:                                             */ 
;;;1185       /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
;;;1186       /*  - if ADC is master, ADC is enabled and conversion is started.         */
;;;1187       if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
;;;1188           ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
;;;1189       {
;;;1190         /* Start ADC conversion on regular group with SW start */
;;;1191         SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1192       }
;;;1193       else
;;;1194       {
;;;1195         /* Start ADC conversion on regular group with external trigger */
;;;1196         SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1197       }
;;;1198     }
;;;1199     else
;;;1200     {
;;;1201       /* Process unlocked */
;;;1202       __HAL_UNLOCK(hadc);
;;;1203     }
;;;1204     
;;;1205     /* Return function status */
;;;1206     return tmp_hal_status;
;;;1207   }
00061a  bd70              POP      {r4-r6,pc}
                  |L1.1564|
00061c  2001              MOVS     r0,#1                 ;1113
00061e  f8840024          STRB     r0,[r4,#0x24]         ;1113
000622  bf00              NOP                            ;1113
000624  4620              MOV      r0,r4                 ;1116
000626  f7fffffe          BL       ADC_Enable
00062a  4605              MOV      r5,r0                 ;1116
00062c  2d00              CMP      r5,#0                 ;1119
00062e  d144              BNE      |L1.1722|
000630  6aa0              LDR      r0,[r4,#0x28]         ;1124
000632  f6406101          MOV      r1,#0xe01             ;1124
000636  4388              BICS     r0,r0,r1              ;1124
000638  f4407080          ORR      r0,r0,#0x100          ;1124
00063c  62a0              STR      r0,[r4,#0x28]         ;1124
00063e  6aa0              LDR      r0,[r4,#0x28]         ;1134
000640  f4201080          BIC      r0,r0,#0x100000       ;1134
000644  62a0              STR      r0,[r4,#0x28]         ;1134
000646  6820              LDR      r0,[r4,#0]            ;1138
000648  6840              LDR      r0,[r0,#4]            ;1138
00064a  f4006080          AND      r0,r0,#0x400          ;1138
00064e  b128              CBZ      r0,|L1.1628|
000650  6aa0              LDR      r0,[r4,#0x28]         ;1140
000652  f4205000          BIC      r0,r0,#0x2000         ;1140
000656  f4405080          ORR      r0,r0,#0x1000         ;1140
00065a  62a0              STR      r0,[r4,#0x28]         ;1140
                  |L1.1628|
00065c  6aa0              LDR      r0,[r4,#0x28]         ;1157
00065e  f4005080          AND      r0,r0,#0x1000         ;1157
000662  b120              CBZ      r0,|L1.1646|
000664  6ae0              LDR      r0,[r4,#0x2c]         ;1160
000666  f0200006          BIC      r0,r0,#6              ;1160
00066a  62e0              STR      r0,[r4,#0x2c]         ;1160
00066c  e001              B        |L1.1650|
                  |L1.1646|
00066e  2000              MOVS     r0,#0                 ;1165
000670  62e0              STR      r0,[r4,#0x2c]         ;1165
                  |L1.1650|
000672  bf00              NOP                            ;1171
000674  2000              MOVS     r0,#0                 ;1171
000676  f8840024          STRB     r0,[r4,#0x24]         ;1171
00067a  bf00              NOP                            ;1171
00067c  1ec0              SUBS     r0,r0,#3              ;1175
00067e  6821              LDR      r1,[r4,#0]            ;1175
000680  6008              STR      r0,[r1,#0]            ;1175
000682  6820              LDR      r0,[r4,#0]            ;1178
000684  6840              LDR      r0,[r0,#4]            ;1178
000686  f0400020          ORR      r0,r0,#0x20           ;1178
00068a  6821              LDR      r1,[r4,#0]            ;1178
00068c  6048              STR      r0,[r1,#4]            ;1178
00068e  6820              LDR      r0,[r4,#0]            ;1187
000690  6880              LDR      r0,[r0,#8]            ;1187
000692  f4002060          AND      r0,r0,#0xe0000        ;1187
000696  f5b02f60          CMP      r0,#0xe0000           ;1187
00069a  d107              BNE      |L1.1708|
00069c  bf00              NOP                            ;1188
00069e  6820              LDR      r0,[r4,#0]            ;1191
0006a0  6880              LDR      r0,[r0,#8]            ;1191
0006a2  f44000a0          ORR      r0,r0,#0x500000       ;1191
0006a6  6821              LDR      r1,[r4,#0]            ;1191
0006a8  6088              STR      r0,[r1,#8]            ;1191
0006aa  e00b              B        |L1.1732|
                  |L1.1708|
0006ac  6820              LDR      r0,[r4,#0]            ;1196
0006ae  6880              LDR      r0,[r0,#8]            ;1196
0006b0  f4401080          ORR      r0,r0,#0x100000       ;1196
0006b4  6821              LDR      r1,[r4,#0]            ;1196
0006b6  6088              STR      r0,[r1,#8]            ;1196
0006b8  e004              B        |L1.1732|
                  |L1.1722|
0006ba  bf00              NOP                            ;1202
0006bc  2000              MOVS     r0,#0                 ;1202
0006be  f8840024          STRB     r0,[r4,#0x24]         ;1202
0006c2  bf00              NOP                            ;1202
                  |L1.1732|
0006c4  4628              MOV      r0,r5                 ;1206
0006c6  e7a8              B        |L1.1562|
;;;1208   
                          ENDP

                  HAL_ADC_Stop_IT PROC
;;;1215     */
;;;1216   HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
0006c8  b570              PUSH     {r4-r6,lr}
;;;1217   {
0006ca  4604              MOV      r4,r0
;;;1218     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
0006cc  2500              MOVS     r5,#0
;;;1219     
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1222        
;;;1223     /* Process locked */
;;;1224     __HAL_LOCK(hadc);
0006ce  bf00              NOP      
0006d0  f8940024          LDRB     r0,[r4,#0x24]
0006d4  2801              CMP      r0,#1
0006d6  d101              BNE      |L1.1756|
0006d8  2002              MOVS     r0,#2
                  |L1.1754|
;;;1225     
;;;1226     /* Stop potential conversion on going, on regular and injected groups */
;;;1227     /* Disable ADC peripheral */
;;;1228     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;1229     
;;;1230     /* Check if ADC is effectively disabled */
;;;1231     if (tmp_hal_status == HAL_OK)
;;;1232     {
;;;1233       /* Disable ADC end of conversion interrupt for regular group */
;;;1234       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
;;;1235       
;;;1236       /* Set ADC state */
;;;1237       ADC_STATE_CLR_SET(hadc->State,
;;;1238                         HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1239                         HAL_ADC_STATE_READY);
;;;1240     }
;;;1241     
;;;1242     /* Process unlocked */
;;;1243     __HAL_UNLOCK(hadc);
;;;1244     
;;;1245     /* Return function status */
;;;1246     return tmp_hal_status;
;;;1247   }
0006da  bd70              POP      {r4-r6,pc}
                  |L1.1756|
0006dc  2001              MOVS     r0,#1                 ;1224
0006de  f8840024          STRB     r0,[r4,#0x24]         ;1224
0006e2  bf00              NOP                            ;1224
0006e4  4620              MOV      r0,r4                 ;1228
0006e6  f7fffffe          BL       ADC_ConversionStop_Disable
0006ea  4605              MOV      r5,r0                 ;1228
0006ec  b95d              CBNZ     r5,|L1.1798|
0006ee  6820              LDR      r0,[r4,#0]            ;1234
0006f0  6840              LDR      r0,[r0,#4]            ;1234
0006f2  f0200020          BIC      r0,r0,#0x20           ;1234
0006f6  6821              LDR      r1,[r4,#0]            ;1234
0006f8  6048              STR      r0,[r1,#4]            ;1234
0006fa  6aa0              LDR      r0,[r4,#0x28]         ;1237
0006fc  f4205088          BIC      r0,r0,#0x1100         ;1237
000700  f0400001          ORR      r0,r0,#1              ;1237
000704  62a0              STR      r0,[r4,#0x28]         ;1237
                  |L1.1798|
000706  bf00              NOP                            ;1243
000708  2000              MOVS     r0,#0                 ;1243
00070a  f8840024          STRB     r0,[r4,#0x24]         ;1243
00070e  bf00              NOP                            ;1243
000710  4628              MOV      r0,r5                 ;1246
000712  e7e2              B        |L1.1754|
;;;1248   
                          ENDP

                  HAL_ADC_ErrorCallback PROC
;;;1653     */
;;;1654   __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
000714  4770              BX       lr
;;;1655   {
;;;1656     /* Prevent unused argument(s) compilation warning */
;;;1657     UNUSED(hadc);
;;;1658     /* NOTE : This function should not be modified. When the callback is needed,
;;;1659               function HAL_ADC_ErrorCallback must be implemented in the user file.
;;;1660     */
;;;1661   }
;;;1662   
                          ENDP

                  ADC_DMAError PROC
;;;2083     */
;;;2084   void ADC_DMAError(DMA_HandleTypeDef *hdma)   
000716  b570              PUSH     {r4-r6,lr}
;;;2085   {
000718  4605              MOV      r5,r0
;;;2086     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2087     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00071a  6a6c              LDR      r4,[r5,#0x24]
;;;2088     
;;;2089     /* Set ADC state */
;;;2090     SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
00071c  6aa0              LDR      r0,[r4,#0x28]
00071e  f0400040          ORR      r0,r0,#0x40
000722  62a0              STR      r0,[r4,#0x28]
;;;2091     
;;;2092     /* Set ADC error code to DMA error */
;;;2093     SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
000724  6ae0              LDR      r0,[r4,#0x2c]
000726  f0400004          ORR      r0,r0,#4
00072a  62e0              STR      r0,[r4,#0x2c]
;;;2094     
;;;2095     /* Error callback */
;;;2096     HAL_ADC_ErrorCallback(hadc); 
00072c  4620              MOV      r0,r4
00072e  f7fffffe          BL       HAL_ADC_ErrorCallback
;;;2097   }
000732  bd70              POP      {r4-r6,pc}
;;;2098   
                          ENDP

                  HAL_ADC_ConvHalfCpltCallback PROC
;;;1624     */
;;;1625   __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
000734  4770              BX       lr
;;;1626   {
;;;1627     /* Prevent unused argument(s) compilation warning */
;;;1628     UNUSED(hadc);
;;;1629     /* NOTE : This function should not be modified. When the callback is needed,
;;;1630               function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
;;;1631     */
;;;1632   }
;;;1633   
                          ENDP

                  ADC_DMAHalfConvCplt PROC
;;;2069     */
;;;2070   void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
000736  b570              PUSH     {r4-r6,lr}
;;;2071   {
000738  4604              MOV      r4,r0
;;;2072     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2073     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00073a  6a65              LDR      r5,[r4,#0x24]
;;;2074     
;;;2075     /* Half conversion callback */
;;;2076     HAL_ADC_ConvHalfCpltCallback(hadc); 
00073c  4628              MOV      r0,r5
00073e  f7fffffe          BL       HAL_ADC_ConvHalfCpltCallback
;;;2077   }
000742  bd70              POP      {r4-r6,pc}
;;;2078   
                          ENDP

                  HAL_ADC_ConvCpltCallback PROC
;;;1610     */
;;;1611   __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
000744  4770              BX       lr
;;;1612   {
;;;1613     /* Prevent unused argument(s) compilation warning */
;;;1614     UNUSED(hadc);
;;;1615     /* NOTE : This function should not be modified. When the callback is needed,
;;;1616               function HAL_ADC_ConvCpltCallback must be implemented in the user file.
;;;1617      */
;;;1618   }
;;;1619   
                          ENDP

                  ADC_DMAConvCplt PROC
;;;2026     */
;;;2027   void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
000746  b570              PUSH     {r4-r6,lr}
;;;2028   {
000748  4605              MOV      r5,r0
;;;2029     /* Retrieve ADC handle corresponding to current DMA handle */
;;;2030     ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00074a  6a6c              LDR      r4,[r5,#0x24]
;;;2031    
;;;2032     /* Update state machine on conversion status if not in error state */
;;;2033     if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
00074c  6aa0              LDR      r0,[r4,#0x28]
00074e  f0000050          AND      r0,r0,#0x50
000752  b9e0              CBNZ     r0,|L1.1934|
;;;2034     {
;;;2035       /* Update ADC state machine */
;;;2036       SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
000754  6aa0              LDR      r0,[r4,#0x28]
000756  f4407000          ORR      r0,r0,#0x200
00075a  62a0              STR      r0,[r4,#0x28]
;;;2037       
;;;2038       /* Determine whether any further conversion upcoming on group regular     */
;;;2039       /* by external trigger, continuous mode or scan sequence on going.        */
;;;2040       /* Note: On STM32F1 devices, in case of sequencer enabled                 */
;;;2041       /*       (several ranks selected), end of conversion flag is raised       */
;;;2042       /*       at the end of the sequence.                                      */
;;;2043       if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
00075c  6820              LDR      r0,[r4,#0]
00075e  6880              LDR      r0,[r0,#8]
000760  f4002060          AND      r0,r0,#0xe0000
000764  f5b02f60          CMP      r0,#0xe0000
000768  d10d              BNE      |L1.1926|
;;;2044          (hadc->Init.ContinuousConvMode == DISABLE)   )
00076a  68e0              LDR      r0,[r4,#0xc]
00076c  b958              CBNZ     r0,|L1.1926|
;;;2045       {
;;;2046         /* Set ADC state */
;;;2047         CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
00076e  6aa0              LDR      r0,[r4,#0x28]
000770  f4207080          BIC      r0,r0,#0x100
000774  62a0              STR      r0,[r4,#0x28]
;;;2048         
;;;2049         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
000776  6aa0              LDR      r0,[r4,#0x28]
000778  f4005080          AND      r0,r0,#0x1000
00077c  b918              CBNZ     r0,|L1.1926|
;;;2050         {
;;;2051           SET_BIT(hadc->State, HAL_ADC_STATE_READY);
00077e  6aa0              LDR      r0,[r4,#0x28]
000780  f0400001          ORR      r0,r0,#1
000784  62a0              STR      r0,[r4,#0x28]
                  |L1.1926|
;;;2052         }
;;;2053       }
;;;2054       
;;;2055       /* Conversion complete callback */
;;;2056       HAL_ADC_ConvCpltCallback(hadc); 
000786  4620              MOV      r0,r4
000788  f7fffffe          BL       HAL_ADC_ConvCpltCallback
00078c  e003              B        |L1.1942|
                  |L1.1934|
;;;2057     }
;;;2058     else
;;;2059     {
;;;2060       /* Call DMA error callback */
;;;2061       hadc->DMA_Handle->XferErrorCallback(hdma);
00078e  6a20              LDR      r0,[r4,#0x20]
000790  6b01              LDR      r1,[r0,#0x30]
000792  4628              MOV      r0,r5
000794  4788              BLX      r1
                  |L1.1942|
;;;2062     }
;;;2063   }
000796  bd70              POP      {r4-r6,pc}
;;;2064   
                          ENDP

                  HAL_ADC_Start_DMA PROC
;;;1272     */
;;;1273   HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
000798  e92d41f0          PUSH     {r4-r8,lr}
;;;1274   {
00079c  4604              MOV      r4,r0
00079e  460d              MOV      r5,r1
0007a0  4616              MOV      r6,r2
;;;1275     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
0007a2  2700              MOVS     r7,#0
;;;1276     
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1279       
;;;1280     /* Verification if multimode is disabled (for devices with several ADC)     */
;;;1281     /* If multimode is enabled, dedicated function multimode conversion         */
;;;1282     /* start DMA must be used.                                                  */
;;;1283     if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
;;;1284     {
;;;1285       /* Process locked */
;;;1286       __HAL_LOCK(hadc);
0007a4  bf00              NOP      
0007a6  f8940024          LDRB     r0,[r4,#0x24]
0007aa  2801              CMP      r0,#1
0007ac  d102              BNE      |L1.1972|
0007ae  2002              MOVS     r0,#2
                  |L1.1968|
;;;1287       
;;;1288       /* Enable the ADC peripheral */
;;;1289       tmp_hal_status = ADC_Enable(hadc);
;;;1290       
;;;1291       /* Start conversion if ADC is effectively enabled */
;;;1292       if (tmp_hal_status == HAL_OK)
;;;1293       {
;;;1294         /* Set ADC state                                                        */
;;;1295         /* - Clear state bitfield related to regular group conversion results   */
;;;1296         /* - Set state bitfield related to regular operation                    */
;;;1297         ADC_STATE_CLR_SET(hadc->State,
;;;1298                           HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
;;;1299                           HAL_ADC_STATE_REG_BUSY);
;;;1300       
;;;1301       /* Set group injected state (from auto-injection) and multimode state     */
;;;1302       /* for all cases of multimode: independent mode, multimode ADC master     */
;;;1303       /* or multimode ADC slave (for devices with several ADCs):                */
;;;1304       if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
;;;1305       {
;;;1306         /* Set ADC state (ADC independent or master) */
;;;1307         CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1308         
;;;1309         /* If conversions on group regular are also triggering group injected,  */
;;;1310         /* update ADC state.                                                    */
;;;1311         if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
;;;1312         {
;;;1313           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
;;;1314         }
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* Set ADC state (ADC slave) */
;;;1319         SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
;;;1320         
;;;1321         /* If conversions on group regular are also triggering group injected,  */
;;;1322         /* update ADC state.                                                    */
;;;1323         if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
;;;1324         {
;;;1325           ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
;;;1326         }
;;;1327       }
;;;1328         
;;;1329         /* State machine update: Check if an injected conversion is ongoing */
;;;1330         if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
;;;1331         {
;;;1332           /* Reset ADC error code fields related to conversions on group regular */
;;;1333           CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
;;;1334         }
;;;1335         else
;;;1336         {
;;;1337           /* Reset ADC all error code fields */
;;;1338           ADC_CLEAR_ERRORCODE(hadc);
;;;1339         }
;;;1340         
;;;1341         /* Process unlocked */
;;;1342         /* Unlock before starting ADC conversions: in case of potential         */
;;;1343         /* interruption, to let the process to ADC IRQ Handler.                 */
;;;1344         __HAL_UNLOCK(hadc);
;;;1345         
;;;1346         /* Set the DMA transfer complete callback */
;;;1347         hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
;;;1348   
;;;1349         /* Set the DMA half transfer complete callback */
;;;1350         hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
;;;1351         
;;;1352         /* Set the DMA error callback */
;;;1353         hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
;;;1354   
;;;1355         
;;;1356         /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
;;;1357         /* start (in case of SW start):                                         */
;;;1358         
;;;1359         /* Clear regular group conversion flag and overrun flag */
;;;1360         /* (To ensure of no unknown state from potential previous ADC           */
;;;1361         /* operations)                                                          */
;;;1362         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
;;;1363         
;;;1364         /* Enable ADC DMA mode */
;;;1365         SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1366         
;;;1367         /* Start the DMA channel */
;;;1368         HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
;;;1369         
;;;1370         /* Enable conversion of regular group.                                  */
;;;1371         /* If software start has been selected, conversion starts immediately.  */
;;;1372         /* If external trigger has been selected, conversion will start at next */
;;;1373         /* trigger event.                                                       */
;;;1374         if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
;;;1375         {
;;;1376           /* Start ADC conversion on regular group with SW start */
;;;1377           SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
;;;1378         }
;;;1379         else
;;;1380         {
;;;1381           /* Start ADC conversion on regular group with external trigger */
;;;1382           SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
;;;1383         }
;;;1384       }
;;;1385       else
;;;1386       {
;;;1387         /* Process unlocked */
;;;1388         __HAL_UNLOCK(hadc);
;;;1389       }
;;;1390     }
;;;1391     else
;;;1392     {
;;;1393       tmp_hal_status = HAL_ERROR;
;;;1394     }
;;;1395     
;;;1396     /* Return function status */
;;;1397     return tmp_hal_status;
;;;1398   }
0007b0  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1972|
0007b4  2001              MOVS     r0,#1                 ;1286
0007b6  f8840024          STRB     r0,[r4,#0x24]         ;1286
0007ba  bf00              NOP                            ;1286
0007bc  4620              MOV      r0,r4                 ;1289
0007be  f7fffffe          BL       ADC_Enable
0007c2  4607              MOV      r7,r0                 ;1289
0007c4  2f00              CMP      r7,#0                 ;1292
0007c6  d158              BNE      |L1.2170|
0007c8  6aa0              LDR      r0,[r4,#0x28]         ;1297
0007ca  f6406101          MOV      r1,#0xe01             ;1297
0007ce  4388              BICS     r0,r0,r1              ;1297
0007d0  f4407080          ORR      r0,r0,#0x100          ;1297
0007d4  62a0              STR      r0,[r4,#0x28]         ;1297
0007d6  6aa0              LDR      r0,[r4,#0x28]         ;1307
0007d8  f4201080          BIC      r0,r0,#0x100000       ;1307
0007dc  62a0              STR      r0,[r4,#0x28]         ;1307
0007de  6820              LDR      r0,[r4,#0]            ;1311
0007e0  6840              LDR      r0,[r0,#4]            ;1311
0007e2  f4006080          AND      r0,r0,#0x400          ;1311
0007e6  b128              CBZ      r0,|L1.2036|
0007e8  6aa0              LDR      r0,[r4,#0x28]         ;1313
0007ea  f4205000          BIC      r0,r0,#0x2000         ;1313
0007ee  f4405080          ORR      r0,r0,#0x1000         ;1313
0007f2  62a0              STR      r0,[r4,#0x28]         ;1313
                  |L1.2036|
0007f4  6aa0              LDR      r0,[r4,#0x28]         ;1330
0007f6  f4005080          AND      r0,r0,#0x1000         ;1330
0007fa  b120              CBZ      r0,|L1.2054|
0007fc  6ae0              LDR      r0,[r4,#0x2c]         ;1333
0007fe  f0200006          BIC      r0,r0,#6              ;1333
000802  62e0              STR      r0,[r4,#0x2c]         ;1333
000804  e001              B        |L1.2058|
                  |L1.2054|
000806  2000              MOVS     r0,#0                 ;1338
000808  62e0              STR      r0,[r4,#0x2c]         ;1338
                  |L1.2058|
00080a  bf00              NOP                            ;1344
00080c  2000              MOVS     r0,#0                 ;1344
00080e  f8840024          STRB     r0,[r4,#0x24]         ;1344
000812  bf00              NOP                            ;1344
000814  f2af00d1          ADR      r0,ADC_DMAConvCplt + 1
000818  6a21              LDR      r1,[r4,#0x20]         ;1347
00081a  6288              STR      r0,[r1,#0x28]         ;1347
00081c  f2af00e9          ADR      r0,ADC_DMAHalfConvCplt + 1
000820  6a21              LDR      r1,[r4,#0x20]         ;1350
000822  62c8              STR      r0,[r1,#0x2c]         ;1350
000824  f2af1011          ADR      r0,ADC_DMAError + 1
000828  6a21              LDR      r1,[r4,#0x20]         ;1353
00082a  6308              STR      r0,[r1,#0x30]         ;1353
00082c  f06f0002          MVN      r0,#2                 ;1362
000830  6821              LDR      r1,[r4,#0]            ;1362
000832  6008              STR      r0,[r1,#0]            ;1362
000834  6820              LDR      r0,[r4,#0]            ;1365
000836  6880              LDR      r0,[r0,#8]            ;1365
000838  f4407080          ORR      r0,r0,#0x100          ;1365
00083c  6821              LDR      r1,[r4,#0]            ;1365
00083e  6088              STR      r0,[r1,#8]            ;1365
000840  6822              LDR      r2,[r4,#0]            ;1368
000842  f102014c          ADD      r1,r2,#0x4c           ;1368
000846  4633              MOV      r3,r6                 ;1368
000848  462a              MOV      r2,r5                 ;1368
00084a  6a20              LDR      r0,[r4,#0x20]         ;1368
00084c  f7fffffe          BL       HAL_DMA_Start_IT
000850  6820              LDR      r0,[r4,#0]            ;1374
000852  6880              LDR      r0,[r0,#8]            ;1374
000854  f4002060          AND      r0,r0,#0xe0000        ;1374
000858  f5b02f60          CMP      r0,#0xe0000           ;1374
00085c  d106              BNE      |L1.2156|
00085e  6820              LDR      r0,[r4,#0]            ;1377
000860  6880              LDR      r0,[r0,#8]            ;1377
000862  f44000a0          ORR      r0,r0,#0x500000       ;1377
000866  6821              LDR      r1,[r4,#0]            ;1377
000868  6088              STR      r0,[r1,#8]            ;1377
00086a  e00b              B        |L1.2180|
                  |L1.2156|
00086c  6820              LDR      r0,[r4,#0]            ;1382
00086e  6880              LDR      r0,[r0,#8]            ;1382
000870  f4401080          ORR      r0,r0,#0x100000       ;1382
000874  6821              LDR      r1,[r4,#0]            ;1382
000876  6088              STR      r0,[r1,#8]            ;1382
000878  e004              B        |L1.2180|
                  |L1.2170|
00087a  bf00              NOP                            ;1388
00087c  2000              MOVS     r0,#0                 ;1388
00087e  f8840024          STRB     r0,[r4,#0x24]         ;1388
000882  bf00              NOP                            ;1388
                  |L1.2180|
000884  4638              MOV      r0,r7                 ;1397
000886  e793              B        |L1.1968|
;;;1399   
                          ENDP

                  HAL_ADC_Stop_DMA PROC
;;;1413     */
;;;1414   HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
000888  b570              PUSH     {r4-r6,lr}
;;;1415   {
00088a  4604              MOV      r4,r0
;;;1416     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
00088c  2500              MOVS     r5,#0
;;;1417     
;;;1418     /* Check the parameters */
;;;1419     assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
;;;1420        
;;;1421     /* Process locked */
;;;1422     __HAL_LOCK(hadc);
00088e  bf00              NOP      
000890  f8940024          LDRB     r0,[r4,#0x24]
000894  2801              CMP      r0,#1
000896  d101              BNE      |L1.2204|
000898  2002              MOVS     r0,#2
                  |L1.2202|
;;;1423     
;;;1424     /* Stop potential conversion on going, on regular and injected groups */
;;;1425     /* Disable ADC peripheral */
;;;1426     tmp_hal_status = ADC_ConversionStop_Disable(hadc);
;;;1427     
;;;1428     /* Check if ADC is effectively disabled */
;;;1429     if (tmp_hal_status == HAL_OK)
;;;1430     {
;;;1431       /* Disable ADC DMA mode */
;;;1432       CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
;;;1433       
;;;1434       /* Disable the DMA channel (in case of DMA in circular mode or stop while */
;;;1435       /* DMA transfer is on going)                                              */
;;;1436       tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
;;;1437       
;;;1438       /* Check if DMA channel effectively disabled */
;;;1439       if (tmp_hal_status == HAL_OK)
;;;1440       {
;;;1441         /* Set ADC state */
;;;1442         ADC_STATE_CLR_SET(hadc->State,
;;;1443                           HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
;;;1444                           HAL_ADC_STATE_READY);
;;;1445       }
;;;1446       else
;;;1447       {
;;;1448         /* Update ADC state machine to error */
;;;1449         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
;;;1450       }
;;;1451     }
;;;1452       
;;;1453     /* Process unlocked */
;;;1454     __HAL_UNLOCK(hadc);
;;;1455       
;;;1456     /* Return function status */
;;;1457     return tmp_hal_status;
;;;1458   }
00089a  bd70              POP      {r4-r6,pc}
                  |L1.2204|
00089c  2001              MOVS     r0,#1                 ;1422
00089e  f8840024          STRB     r0,[r4,#0x24]         ;1422
0008a2  bf00              NOP                            ;1422
0008a4  4620              MOV      r0,r4                 ;1426
0008a6  f7fffffe          BL       ADC_ConversionStop_Disable
0008aa  4605              MOV      r5,r0                 ;1426
0008ac  b9ad              CBNZ     r5,|L1.2266|
0008ae  6820              LDR      r0,[r4,#0]            ;1432
0008b0  6880              LDR      r0,[r0,#8]            ;1432
0008b2  f4207080          BIC      r0,r0,#0x100          ;1432
0008b6  6821              LDR      r1,[r4,#0]            ;1432
0008b8  6088              STR      r0,[r1,#8]            ;1432
0008ba  6a20              LDR      r0,[r4,#0x20]         ;1436
0008bc  f7fffffe          BL       HAL_DMA_Abort
0008c0  4605              MOV      r5,r0                 ;1436
0008c2  b935              CBNZ     r5,|L1.2258|
0008c4  6aa0              LDR      r0,[r4,#0x28]         ;1442
0008c6  f4205088          BIC      r0,r0,#0x1100         ;1442
0008ca  f0400001          ORR      r0,r0,#1              ;1442
0008ce  62a0              STR      r0,[r4,#0x28]         ;1442
0008d0  e003              B        |L1.2266|
                  |L1.2258|
0008d2  6aa0              LDR      r0,[r4,#0x28]         ;1449
0008d4  f0400040          ORR      r0,r0,#0x40           ;1449
0008d8  62a0              STR      r0,[r4,#0x28]         ;1449
                  |L1.2266|
0008da  bf00              NOP                            ;1454
0008dc  2000              MOVS     r0,#0                 ;1454
0008de  f8840024          STRB     r0,[r4,#0x24]         ;1454
0008e2  bf00              NOP                            ;1454
0008e4  4628              MOV      r0,r5                 ;1457
0008e6  e7d8              B        |L1.2202|
;;;1459   
                          ENDP

                  HAL_ADC_GetValue PROC
;;;1478     */
;;;1479   uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
0008e8  4601              MOV      r1,r0
;;;1480   {
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1483   
;;;1484     /* Note: EOC flag is not cleared here by software because automatically     */
;;;1485     /*       cleared by hardware when reading register DR.                      */
;;;1486     
;;;1487     /* Return ADC converted value */ 
;;;1488     return hadc->Instance->DR;
0008ea  6808              LDR      r0,[r1,#0]
0008ec  6cc0              LDR      r0,[r0,#0x4c]
;;;1489   }
0008ee  4770              BX       lr
;;;1490   
                          ENDP

                  HAL_ADC_LevelOutOfWindowCallback PROC
;;;1638     */
;;;1639   __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
0008f0  4770              BX       lr
;;;1640   {
;;;1641     /* Prevent unused argument(s) compilation warning */
;;;1642     UNUSED(hadc);
;;;1643     /* NOTE : This function should not be modified. When the callback is needed,
;;;1644               function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
;;;1645     */
;;;1646   }
;;;1647   
                          ENDP

                  HAL_ADC_IRQHandler PROC
;;;1495     */
;;;1496   void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
0008f2  b510              PUSH     {r4,lr}
;;;1497   {
0008f4  4604              MOV      r4,r0
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1500     assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
;;;1501     assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
;;;1502     
;;;1503     
;;;1504     /* ========== Check End of Conversion flag for regular group ========== */
;;;1505     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
0008f6  6820              LDR      r0,[r4,#0]
0008f8  6840              LDR      r0,[r0,#4]
0008fa  f0000020          AND      r0,r0,#0x20
0008fe  2820              CMP      r0,#0x20
000900  d12f              BNE      |L1.2402|
;;;1506     {
;;;1507       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
000902  6820              LDR      r0,[r4,#0]
000904  6800              LDR      r0,[r0,#0]
000906  f0000002          AND      r0,r0,#2
00090a  2802              CMP      r0,#2
00090c  d129              BNE      |L1.2402|
;;;1508       {
;;;1509         /* Update state machine on conversion status if not in error state */
;;;1510         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
00090e  6aa0              LDR      r0,[r4,#0x28]
000910  f0000010          AND      r0,r0,#0x10
000914  b918              CBNZ     r0,|L1.2334|
;;;1511         {
;;;1512           /* Set ADC state */
;;;1513           SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
000916  6aa0              LDR      r0,[r4,#0x28]
000918  f4407000          ORR      r0,r0,#0x200
00091c  62a0              STR      r0,[r4,#0x28]
                  |L1.2334|
;;;1514         }
;;;1515         
;;;1516         /* Determine whether any further conversion upcoming on group regular   */
;;;1517         /* by external trigger, continuous mode or scan sequence on going.      */
;;;1518         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1519         /*       (several ranks selected), end of conversion flag is raised     */
;;;1520         /*       at the end of the sequence.                                    */
;;;1521         if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
00091e  6820              LDR      r0,[r4,#0]
000920  6880              LDR      r0,[r0,#8]
000922  f4002060          AND      r0,r0,#0xe0000
000926  f5b02f60          CMP      r0,#0xe0000
00092a  d113              BNE      |L1.2388|
;;;1522            (hadc->Init.ContinuousConvMode == DISABLE)   )
00092c  68e0              LDR      r0,[r4,#0xc]
00092e  b988              CBNZ     r0,|L1.2388|
;;;1523         {
;;;1524           /* Disable ADC end of conversion interrupt on group regular */
;;;1525           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
000930  6820              LDR      r0,[r4,#0]
000932  6840              LDR      r0,[r0,#4]
000934  f0200020          BIC      r0,r0,#0x20
000938  6821              LDR      r1,[r4,#0]
00093a  6048              STR      r0,[r1,#4]
;;;1526           
;;;1527           /* Set ADC state */
;;;1528           CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
00093c  6aa0              LDR      r0,[r4,#0x28]
00093e  f4207080          BIC      r0,r0,#0x100
000942  62a0              STR      r0,[r4,#0x28]
;;;1529           
;;;1530           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
000944  6aa0              LDR      r0,[r4,#0x28]
000946  f4005080          AND      r0,r0,#0x1000
00094a  b918              CBNZ     r0,|L1.2388|
;;;1531           {
;;;1532             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
00094c  6aa0              LDR      r0,[r4,#0x28]
00094e  f0400001          ORR      r0,r0,#1
000952  62a0              STR      r0,[r4,#0x28]
                  |L1.2388|
;;;1533           }
;;;1534         }
;;;1535   
;;;1536         /* Conversion complete callback */
;;;1537         HAL_ADC_ConvCpltCallback(hadc);
000954  4620              MOV      r0,r4
000956  f7fffffe          BL       HAL_ADC_ConvCpltCallback
;;;1538         
;;;1539         /* Clear regular group conversion flag */
;;;1540         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
00095a  f06f0012          MVN      r0,#0x12
00095e  6821              LDR      r1,[r4,#0]
000960  6008              STR      r0,[r1,#0]
                  |L1.2402|
;;;1541       }
;;;1542     }
;;;1543     
;;;1544     /* ========== Check End of Conversion flag for injected group ========== */
;;;1545     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
000962  6820              LDR      r0,[r4,#0]
000964  6840              LDR      r0,[r0,#4]
000966  f0000080          AND      r0,r0,#0x80
00096a  2880              CMP      r0,#0x80
00096c  d13b              BNE      |L1.2534|
;;;1546     {
;;;1547       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
00096e  6820              LDR      r0,[r4,#0]
000970  6800              LDR      r0,[r0,#0]
000972  f0000004          AND      r0,r0,#4
000976  2804              CMP      r0,#4
000978  d135              BNE      |L1.2534|
;;;1548       {
;;;1549         /* Update state machine on conversion status if not in error state */
;;;1550         if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
00097a  6aa0              LDR      r0,[r4,#0x28]
00097c  f0000010          AND      r0,r0,#0x10
000980  b918              CBNZ     r0,|L1.2442|
;;;1551         {
;;;1552           /* Set ADC state */
;;;1553           SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
000982  6aa0              LDR      r0,[r4,#0x28]
000984  f4405000          ORR      r0,r0,#0x2000
000988  62a0              STR      r0,[r4,#0x28]
                  |L1.2442|
;;;1554         }
;;;1555   
;;;1556         /* Determine whether any further conversion upcoming on group injected  */
;;;1557         /* by external trigger, scan sequence on going or by automatic injected */
;;;1558         /* conversion from group regular (same conditions as group regular      */
;;;1559         /* interruption disabling above).                                       */
;;;1560         /* Note: On STM32F1 devices, in case of sequencer enabled               */
;;;1561         /*       (several ranks selected), end of conversion flag is raised     */
;;;1562         /*       at the end of the sequence.                                    */
;;;1563         if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
00098a  6820              LDR      r0,[r4,#0]
00098c  6880              LDR      r0,[r0,#8]
00098e  f40040e0          AND      r0,r0,#0x7000
000992  f5b04fe0          CMP      r0,#0x7000
000996  d00d              BEQ      |L1.2484|
;;;1564            (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
000998  6820              LDR      r0,[r4,#0]
00099a  6840              LDR      r0,[r0,#4]
00099c  f4006080          AND      r0,r0,#0x400
0009a0  b9d0              CBNZ     r0,|L1.2520|
;;;1565            (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
0009a2  6820              LDR      r0,[r4,#0]
0009a4  6880              LDR      r0,[r0,#8]
0009a6  f4002060          AND      r0,r0,#0xe0000
0009aa  f5b02f60          CMP      r0,#0xe0000
0009ae  d113              BNE      |L1.2520|
;;;1566             (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
0009b0  68e0              LDR      r0,[r4,#0xc]
0009b2  b988              CBNZ     r0,|L1.2520|
                  |L1.2484|
;;;1567         {
;;;1568           /* Disable ADC end of conversion interrupt on group injected */
;;;1569           __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
0009b4  6820              LDR      r0,[r4,#0]
0009b6  6840              LDR      r0,[r0,#4]
0009b8  f0200080          BIC      r0,r0,#0x80
0009bc  6821              LDR      r1,[r4,#0]
0009be  6048              STR      r0,[r1,#4]
;;;1570           
;;;1571           /* Set ADC state */
;;;1572           CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
0009c0  6aa0              LDR      r0,[r4,#0x28]
0009c2  f4205080          BIC      r0,r0,#0x1000
0009c6  62a0              STR      r0,[r4,#0x28]
;;;1573   
;;;1574           if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
0009c8  6aa0              LDR      r0,[r4,#0x28]
0009ca  f4007080          AND      r0,r0,#0x100
0009ce  b918              CBNZ     r0,|L1.2520|
;;;1575           { 
;;;1576             SET_BIT(hadc->State, HAL_ADC_STATE_READY);
0009d0  6aa0              LDR      r0,[r4,#0x28]
0009d2  f0400001          ORR      r0,r0,#1
0009d6  62a0              STR      r0,[r4,#0x28]
                  |L1.2520|
;;;1577           }
;;;1578         }
;;;1579   
;;;1580         /* Conversion complete callback */ 
;;;1581         HAL_ADCEx_InjectedConvCpltCallback(hadc);
0009d8  4620              MOV      r0,r4
0009da  f7fffffe          BL       HAL_ADCEx_InjectedConvCpltCallback
;;;1582         
;;;1583         /* Clear injected group conversion flag */
;;;1584         __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
0009de  f06f000c          MVN      r0,#0xc
0009e2  6821              LDR      r1,[r4,#0]
0009e4  6008              STR      r0,[r1,#0]
                  |L1.2534|
;;;1585       }
;;;1586     }
;;;1587      
;;;1588     /* ========== Check Analog watchdog flags ========== */
;;;1589     if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
0009e6  6820              LDR      r0,[r4,#0]
0009e8  6840              LDR      r0,[r0,#4]
0009ea  f0000040          AND      r0,r0,#0x40
0009ee  2840              CMP      r0,#0x40
0009f0  d10f              BNE      |L1.2578|
;;;1590     {
;;;1591       if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
0009f2  6820              LDR      r0,[r4,#0]
0009f4  6800              LDR      r0,[r0,#0]
0009f6  f0000001          AND      r0,r0,#1
0009fa  b150              CBZ      r0,|L1.2578|
;;;1592       {
;;;1593         /* Set ADC state */
;;;1594         SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
0009fc  6aa0              LDR      r0,[r4,#0x28]
0009fe  f4403080          ORR      r0,r0,#0x10000
000a02  62a0              STR      r0,[r4,#0x28]
;;;1595         
;;;1596         /* Level out of window callback */ 
;;;1597         HAL_ADC_LevelOutOfWindowCallback(hadc);
000a04  4620              MOV      r0,r4
000a06  f7fffffe          BL       HAL_ADC_LevelOutOfWindowCallback
;;;1598         
;;;1599         /* Clear the ADC analog watchdog flag */
;;;1600         __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
000a0a  f06f0001          MVN      r0,#1
000a0e  6821              LDR      r1,[r4,#0]
000a10  6008              STR      r0,[r1,#0]
                  |L1.2578|
;;;1601       }
;;;1602     }
;;;1603     
;;;1604   }
000a12  bd10              POP      {r4,pc}
;;;1605   
                          ENDP

                  HAL_ADC_ConfigChannel PROC
;;;1701     */
;;;1702   HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
000a14  b578              PUSH     {r3-r6,lr}
;;;1703   { 
000a16  4602              MOV      r2,r0
;;;1704     HAL_StatusTypeDef tmp_hal_status = HAL_OK;
000a18  2300              MOVS     r3,#0
;;;1705     __IO uint32_t wait_loop_index = 0;
000a1a  2000              MOVS     r0,#0
000a1c  9000              STR      r0,[sp,#0]
;;;1706     
;;;1707     /* Check the parameters */
;;;1708     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1709     assert_param(IS_ADC_CHANNEL(sConfig->Channel));
;;;1710     assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
;;;1711     assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
;;;1712     
;;;1713     /* Process locked */
;;;1714     __HAL_LOCK(hadc);
000a1e  bf00              NOP      
000a20  f8920024          LDRB     r0,[r2,#0x24]
000a24  2801              CMP      r0,#1
000a26  d101              BNE      |L1.2604|
000a28  2002              MOVS     r0,#2
                  |L1.2602|
;;;1715     
;;;1716     
;;;1717     /* Regular sequence configuration */
;;;1718     /* For Rank 1 to 6 */
;;;1719     if (sConfig->Rank < 7)
;;;1720     {
;;;1721       MODIFY_REG(hadc->Instance->SQR3                        ,
;;;1722                  ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
;;;1723                  ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
;;;1724     }
;;;1725     /* For Rank 7 to 12 */
;;;1726     else if (sConfig->Rank < 13)
;;;1727     {
;;;1728       MODIFY_REG(hadc->Instance->SQR2                        ,
;;;1729                  ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank)    ,
;;;1730                  ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
;;;1731     }
;;;1732     /* For Rank 13 to 16 */
;;;1733     else
;;;1734     {
;;;1735       MODIFY_REG(hadc->Instance->SQR1                        ,
;;;1736                  ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank)   ,
;;;1737                  ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
;;;1738     }
;;;1739     
;;;1740     
;;;1741     /* Channel sampling time configuration */
;;;1742     /* For channels 10 to 17 */
;;;1743     if (sConfig->Channel >= ADC_CHANNEL_10)
;;;1744     {
;;;1745       MODIFY_REG(hadc->Instance->SMPR1                             ,
;;;1746                  ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
;;;1747                  ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
;;;1748     }
;;;1749     else /* For channels 0 to 9 */
;;;1750     {
;;;1751       MODIFY_REG(hadc->Instance->SMPR2                             ,
;;;1752                  ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel)       ,
;;;1753                  ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
;;;1754     }
;;;1755     
;;;1756     /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
;;;1757     /* and VREFINT measurement path.                                            */
;;;1758     if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
;;;1759         (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
;;;1760     {
;;;1761       /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
;;;1762       /* measurement channels (VrefInt/TempSensor). If these channels are       */
;;;1763       /* intended to be set on other ADC instances, an error is reported.       */
;;;1764       if (hadc->Instance == ADC1)
;;;1765       {
;;;1766         if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
;;;1767         {
;;;1768           SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
;;;1769           
;;;1770           if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
;;;1771           {
;;;1772             /* Delay for temperature sensor stabilization time */
;;;1773             /* Compute number of CPU cycles to wait for */
;;;1774             wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
;;;1775             while(wait_loop_index != 0)
;;;1776             {
;;;1777               wait_loop_index--;
;;;1778             }
;;;1779           }
;;;1780         }
;;;1781       }
;;;1782       else
;;;1783       {
;;;1784         /* Update ADC state machine to error */
;;;1785         SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
;;;1786         
;;;1787         tmp_hal_status = HAL_ERROR;
;;;1788       }
;;;1789     }
;;;1790     
;;;1791     /* Process unlocked */
;;;1792     __HAL_UNLOCK(hadc);
;;;1793     
;;;1794     /* Return function status */
;;;1795     return tmp_hal_status;
;;;1796   }
000a2a  bd78              POP      {r3-r6,pc}
                  |L1.2604|
000a2c  2001              MOVS     r0,#1                 ;1714
000a2e  f8820024          STRB     r0,[r2,#0x24]         ;1714
000a32  bf00              NOP                            ;1714
000a34  6848              LDR      r0,[r1,#4]            ;1719
000a36  2807              CMP      r0,#7                 ;1719
000a38  d21d              BCS      |L1.2678|
000a3a  6810              LDR      r0,[r2,#0]            ;1721
000a3c  6b44              LDR      r4,[r0,#0x34]         ;1721
000a3e  7908              LDRB     r0,[r1,#4]            ;1721
000a40  1e40              SUBS     r0,r0,#1              ;1721
000a42  f44f7578          MOV      r5,#0x3e0             ;1721
000a46  fa95f5a5          RBIT     r5,r5                 ;1721
000a4a  fab5f585          CLZ      r5,r5                 ;1721
000a4e  4368              MULS     r0,r5,r0              ;1721
000a50  251f              MOVS     r5,#0x1f              ;1721
000a52  4085              LSLS     r5,r5,r0              ;1721
000a54  ea240005          BIC      r0,r4,r5              ;1721
000a58  790c              LDRB     r4,[r1,#4]            ;1721
000a5a  1e64              SUBS     r4,r4,#1              ;1721
000a5c  f44f7678          MOV      r6,#0x3e0             ;1721
000a60  fa96f6a6          RBIT     r6,r6                 ;1721
000a64  fab6f686          CLZ      r6,r6                 ;1721
000a68  4374              MULS     r4,r6,r4              ;1721
000a6a  680d              LDR      r5,[r1,#0]            ;1721
000a6c  40a5              LSLS     r5,r5,r4              ;1721
000a6e  4328              ORRS     r0,r0,r5              ;1721
000a70  6814              LDR      r4,[r2,#0]            ;1721
000a72  6360              STR      r0,[r4,#0x34]         ;1721
000a74  e03d              B        |L1.2802|
                  |L1.2678|
000a76  6848              LDR      r0,[r1,#4]            ;1726
000a78  280d              CMP      r0,#0xd               ;1726
000a7a  d21d              BCS      |L1.2744|
000a7c  6810              LDR      r0,[r2,#0]            ;1728
000a7e  6b04              LDR      r4,[r0,#0x30]         ;1728
000a80  7908              LDRB     r0,[r1,#4]            ;1728
000a82  1fc0              SUBS     r0,r0,#7              ;1728
000a84  f44f7578          MOV      r5,#0x3e0             ;1728
000a88  fa95f5a5          RBIT     r5,r5                 ;1728
000a8c  fab5f585          CLZ      r5,r5                 ;1728
000a90  4368              MULS     r0,r5,r0              ;1728
000a92  251f              MOVS     r5,#0x1f              ;1728
000a94  4085              LSLS     r5,r5,r0              ;1728
000a96  ea240005          BIC      r0,r4,r5              ;1728
000a9a  790c              LDRB     r4,[r1,#4]            ;1728
000a9c  1fe4              SUBS     r4,r4,#7              ;1728
000a9e  f44f7678          MOV      r6,#0x3e0             ;1728
000aa2  fa96f6a6          RBIT     r6,r6                 ;1728
000aa6  fab6f686          CLZ      r6,r6                 ;1728
000aaa  4374              MULS     r4,r6,r4              ;1728
000aac  680d              LDR      r5,[r1,#0]            ;1728
000aae  40a5              LSLS     r5,r5,r4              ;1728
000ab0  4328              ORRS     r0,r0,r5              ;1728
000ab2  6814              LDR      r4,[r2,#0]            ;1728
000ab4  6320              STR      r0,[r4,#0x30]         ;1728
000ab6  e01c              B        |L1.2802|
                  |L1.2744|
000ab8  6810              LDR      r0,[r2,#0]            ;1735
000aba  6ac4              LDR      r4,[r0,#0x2c]         ;1735
000abc  7908              LDRB     r0,[r1,#4]            ;1735
000abe  380d              SUBS     r0,r0,#0xd            ;1735
000ac0  f44f7578          MOV      r5,#0x3e0             ;1735
000ac4  fa95f5a5          RBIT     r5,r5                 ;1735
000ac8  fab5f585          CLZ      r5,r5                 ;1735
000acc  4368              MULS     r0,r5,r0              ;1735
000ace  251f              MOVS     r5,#0x1f              ;1735
000ad0  4085              LSLS     r5,r5,r0              ;1735
000ad2  ea240005          BIC      r0,r4,r5              ;1735
000ad6  790c              LDRB     r4,[r1,#4]            ;1735
000ad8  3c0d              SUBS     r4,r4,#0xd            ;1735
000ada  f44f7678          MOV      r6,#0x3e0             ;1735
000ade  fa96f6a6          RBIT     r6,r6                 ;1735
000ae2  fab6f686          CLZ      r6,r6                 ;1735
000ae6  4374              MULS     r4,r6,r4              ;1735
000ae8  680d              LDR      r5,[r1,#0]            ;1735
000aea  40a5              LSLS     r5,r5,r4              ;1735
000aec  4328              ORRS     r0,r0,r5              ;1735
000aee  6814              LDR      r4,[r2,#0]            ;1735
000af0  62e0              STR      r0,[r4,#0x2c]         ;1735
                  |L1.2802|
000af2  6808              LDR      r0,[r1,#0]            ;1743
000af4  280a              CMP      r0,#0xa               ;1743
000af6  d31b              BCC      |L1.2864|
000af8  6810              LDR      r0,[r2,#0]            ;1745
000afa  68c4              LDR      r4,[r0,#0xc]          ;1745
000afc  7808              LDRB     r0,[r1,#0]            ;1745
000afe  380a              SUBS     r0,r0,#0xa            ;1745
000b00  2538              MOVS     r5,#0x38              ;1745
000b02  fa95f5a5          RBIT     r5,r5                 ;1745
000b06  fab5f585          CLZ      r5,r5                 ;1745
000b0a  4368              MULS     r0,r5,r0              ;1745
000b0c  2507              MOVS     r5,#7                 ;1745
000b0e  4085              LSLS     r5,r5,r0              ;1745
000b10  ea240005          BIC      r0,r4,r5              ;1745
000b14  780c              LDRB     r4,[r1,#0]            ;1745
000b16  3c0a              SUBS     r4,r4,#0xa            ;1745
000b18  2638              MOVS     r6,#0x38              ;1745
000b1a  fa96f6a6          RBIT     r6,r6                 ;1745
000b1e  fab6f686          CLZ      r6,r6                 ;1745
000b22  4374              MULS     r4,r6,r4              ;1745
000b24  688d              LDR      r5,[r1,#8]            ;1745
000b26  40a5              LSLS     r5,r5,r4              ;1745
000b28  4328              ORRS     r0,r0,r5              ;1745
000b2a  6814              LDR      r4,[r2,#0]            ;1745
000b2c  60e0              STR      r0,[r4,#0xc]          ;1745
000b2e  e017              B        |L1.2912|
                  |L1.2864|
000b30  6810              LDR      r0,[r2,#0]            ;1751
000b32  6900              LDR      r0,[r0,#0x10]         ;1751
000b34  780c              LDRB     r4,[r1,#0]            ;1751
000b36  2538              MOVS     r5,#0x38              ;1751
000b38  fa95f5a5          RBIT     r5,r5                 ;1751
000b3c  fab5f585          CLZ      r5,r5                 ;1751
000b40  436c              MULS     r4,r5,r4              ;1751
000b42  2507              MOVS     r5,#7                 ;1751
000b44  40a5              LSLS     r5,r5,r4              ;1751
000b46  43a8              BICS     r0,r0,r5              ;1751
000b48  780d              LDRB     r5,[r1,#0]            ;1751
000b4a  2638              MOVS     r6,#0x38              ;1751
000b4c  fa96f6a6          RBIT     r6,r6                 ;1751
000b50  fab6f686          CLZ      r6,r6                 ;1751
000b54  4375              MULS     r5,r6,r5              ;1751
000b56  688c              LDR      r4,[r1,#8]            ;1751
000b58  40ac              LSLS     r4,r4,r5              ;1751
000b5a  4320              ORRS     r0,r0,r4              ;1751
000b5c  6814              LDR      r4,[r2,#0]            ;1751
000b5e  6120              STR      r0,[r4,#0x10]         ;1751
                  |L1.2912|
000b60  6808              LDR      r0,[r1,#0]            ;1758
000b62  2810              CMP      r0,#0x10              ;1758
000b64  d002              BEQ      |L1.2924|
000b66  6808              LDR      r0,[r1,#0]            ;1759
000b68  2811              CMP      r0,#0x11              ;1759
000b6a  d127              BNE      |L1.3004|
                  |L1.2924|
000b6c  4c3a              LDR      r4,|L1.3160|
000b6e  6810              LDR      r0,[r2,#0]            ;1764
000b70  42a0              CMP      r0,r4                 ;1764
000b72  d11e              BNE      |L1.2994|
000b74  6810              LDR      r0,[r2,#0]            ;1766
000b76  6880              LDR      r0,[r0,#8]            ;1766
000b78  f4000000          AND      r0,r0,#0x800000       ;1766
000b7c  b9f0              CBNZ     r0,|L1.3004|
000b7e  6810              LDR      r0,[r2,#0]            ;1768
000b80  6880              LDR      r0,[r0,#8]            ;1768
000b82  f4400000          ORR      r0,r0,#0x800000       ;1768
000b86  6814              LDR      r4,[r2,#0]            ;1768
000b88  60a0              STR      r0,[r4,#8]            ;1768
000b8a  6808              LDR      r0,[r1,#0]            ;1770
000b8c  2810              CMP      r0,#0x10              ;1770
000b8e  d115              BNE      |L1.3004|
000b90  4832              LDR      r0,|L1.3164|
000b92  6800              LDR      r0,[r0,#0]            ;1774  ; SystemCoreClock
000b94  4c32              LDR      r4,|L1.3168|
000b96  fbb0f0f4          UDIV     r0,r0,r4              ;1774
000b9a  eb000080          ADD      r0,r0,r0,LSL #2       ;1774
000b9e  0040              LSLS     r0,r0,#1              ;1774
000ba0  9000              STR      r0,[sp,#0]            ;1774
000ba2  e002              B        |L1.2986|
                  |L1.2980|
000ba4  9800              LDR      r0,[sp,#0]            ;1777
000ba6  1e40              SUBS     r0,r0,#1              ;1777
000ba8  9000              STR      r0,[sp,#0]            ;1777
                  |L1.2986|
000baa  9800              LDR      r0,[sp,#0]            ;1775
000bac  2800              CMP      r0,#0                 ;1775
000bae  d1f9              BNE      |L1.2980|
000bb0  e004              B        |L1.3004|
                  |L1.2994|
000bb2  6a90              LDR      r0,[r2,#0x28]         ;1785
000bb4  f0400020          ORR      r0,r0,#0x20           ;1785
000bb8  6290              STR      r0,[r2,#0x28]         ;1785
000bba  2301              MOVS     r3,#1                 ;1787
                  |L1.3004|
000bbc  bf00              NOP                            ;1792
000bbe  2000              MOVS     r0,#0                 ;1792
000bc0  f8820024          STRB     r0,[r2,#0x24]         ;1792
000bc4  bf00              NOP                            ;1792
000bc6  4618              MOV      r0,r3                 ;1795
000bc8  e72f              B        |L1.2602|
;;;1797   
                          ENDP

                  HAL_ADC_AnalogWDGConfig PROC
;;;1811     */
;;;1812   HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
000bca  b510              PUSH     {r4,lr}
;;;1813   {
000bcc  4602              MOV      r2,r0
;;;1814     /* Check the parameters */
;;;1815     assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
;;;1816     assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
;;;1817     assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
;;;1818     assert_param(IS_ADC_RANGE(AnalogWDGConfig->HighThreshold));
;;;1819     assert_param(IS_ADC_RANGE(AnalogWDGConfig->LowThreshold));
;;;1820     
;;;1821     if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
000bce  4b25              LDR      r3,|L1.3172|
000bd0  6808              LDR      r0,[r1,#0]
000bd2  4298              CMP      r0,r3
000bd4  d007              BEQ      |L1.3046|
;;;1822        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
000bd6  4b24              LDR      r3,|L1.3176|
000bd8  6808              LDR      r0,[r1,#0]
000bda  4298              CMP      r0,r3
000bdc  d003              BEQ      |L1.3046|
;;;1823        (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
000bde  4b23              LDR      r3,|L1.3180|
000be0  6808              LDR      r0,[r1,#0]
000be2  4298              CMP      r0,r3
000be4  d100              BNE      |L1.3048|
                  |L1.3046|
;;;1824     {
;;;1825       assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
000be6  bf00              NOP      
                  |L1.3048|
;;;1826     }
;;;1827     
;;;1828     /* Process locked */
;;;1829     __HAL_LOCK(hadc);
000be8  bf00              NOP      
000bea  f8920024          LDRB     r0,[r2,#0x24]
000bee  2801              CMP      r0,#1
000bf0  d101              BNE      |L1.3062|
000bf2  2002              MOVS     r0,#2
                  |L1.3060|
;;;1830     
;;;1831     /* Analog watchdog configuration */
;;;1832   
;;;1833     /* Configure ADC Analog watchdog interrupt */
;;;1834     if(AnalogWDGConfig->ITMode == ENABLE)
;;;1835     {
;;;1836       /* Enable the ADC Analog watchdog interrupt */
;;;1837       __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
;;;1838     }
;;;1839     else
;;;1840     {
;;;1841       /* Disable the ADC Analog watchdog interrupt */
;;;1842       __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
;;;1843     }
;;;1844     
;;;1845     /* Configuration of analog watchdog:                                        */
;;;1846     /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
;;;1847     /*    one or all channels.                                                  */
;;;1848     /*  - Set the Analog watchdog channel (is not used if watchdog              */
;;;1849     /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
;;;1850     MODIFY_REG(hadc->Instance->CR1            ,
;;;1851                ADC_CR1_AWDSGL |
;;;1852                ADC_CR1_JAWDEN |
;;;1853                ADC_CR1_AWDEN  |
;;;1854                ADC_CR1_AWDCH                  ,
;;;1855                AnalogWDGConfig->WatchdogMode |
;;;1856                AnalogWDGConfig->Channel        );
;;;1857     
;;;1858     /* Set the high threshold */
;;;1859     WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
;;;1860     
;;;1861     /* Set the low threshold */
;;;1862     WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
;;;1863   
;;;1864     /* Process unlocked */
;;;1865     __HAL_UNLOCK(hadc);
;;;1866     
;;;1867     /* Return function status */
;;;1868     return HAL_OK;
;;;1869   }
000bf4  bd10              POP      {r4,pc}
                  |L1.3062|
000bf6  2001              MOVS     r0,#1                 ;1829
000bf8  f8820024          STRB     r0,[r2,#0x24]         ;1829
000bfc  bf00              NOP                            ;1829
000bfe  6888              LDR      r0,[r1,#8]            ;1834
000c00  2801              CMP      r0,#1                 ;1834
000c02  d106              BNE      |L1.3090|
000c04  6810              LDR      r0,[r2,#0]            ;1837
000c06  6840              LDR      r0,[r0,#4]            ;1837
000c08  f0400040          ORR      r0,r0,#0x40           ;1837
000c0c  6813              LDR      r3,[r2,#0]            ;1837
000c0e  6058              STR      r0,[r3,#4]            ;1837
000c10  e005              B        |L1.3102|
                  |L1.3090|
000c12  6810              LDR      r0,[r2,#0]            ;1842
000c14  6840              LDR      r0,[r0,#4]            ;1842
000c16  f0200040          BIC      r0,r0,#0x40           ;1842
000c1a  6813              LDR      r3,[r2,#0]            ;1842
000c1c  6058              STR      r0,[r3,#4]            ;1842
                  |L1.3102|
000c1e  e9d10300          LDRD     r0,r3,[r1,#0]         ;1850
000c22  4318              ORRS     r0,r0,r3              ;1850
000c24  6813              LDR      r3,[r2,#0]            ;1850
000c26  685b              LDR      r3,[r3,#4]            ;1850
000c28  4c11              LDR      r4,|L1.3184|
000c2a  4023              ANDS     r3,r3,r4              ;1850
000c2c  4318              ORRS     r0,r0,r3              ;1850
000c2e  6813              LDR      r3,[r2,#0]            ;1850
000c30  6058              STR      r0,[r3,#4]            ;1850
000c32  68c8              LDR      r0,[r1,#0xc]          ;1859
000c34  6813              LDR      r3,[r2,#0]            ;1859
000c36  6258              STR      r0,[r3,#0x24]         ;1859
000c38  6908              LDR      r0,[r1,#0x10]         ;1862
000c3a  6813              LDR      r3,[r2,#0]            ;1862
000c3c  6298              STR      r0,[r3,#0x28]         ;1862
000c3e  bf00              NOP                            ;1865
000c40  2000              MOVS     r0,#0                 ;1865
000c42  f8820024          STRB     r0,[r2,#0x24]         ;1865
000c46  bf00              NOP                            ;1865
000c48  bf00              NOP                            ;1868
000c4a  e7d3              B        |L1.3060|
;;;1870   
                          ENDP

                  HAL_ADC_GetState PROC
;;;1898     */
;;;1899   uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
000c4c  4601              MOV      r1,r0
;;;1900   {
;;;1901     /* Return ADC state */
;;;1902     return hadc->State;
000c4e  6a88              LDR      r0,[r1,#0x28]
;;;1903   }
000c50  4770              BX       lr
;;;1904   
                          ENDP

                  HAL_ADC_GetError PROC
;;;1909     */
;;;1910   uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
000c52  4601              MOV      r1,r0
;;;1911   {
;;;1912     return hadc->ErrorCode;
000c54  6ac8              LDR      r0,[r1,#0x2c]
;;;1913   }
000c56  4770              BX       lr
;;;1914   
                          ENDP

                  |L1.3160|
                          DCD      0x40012400
                  |L1.3164|
                          DCD      SystemCoreClock
                  |L1.3168|
                          DCD      0x000f4240
                  |L1.3172|
                          DCD      0x00800200
                  |L1.3176|
                          DCD      0x00400200
                  |L1.3180|
                          DCD      0x00c00200
                  |L1.3184|
                          DCD      0xff3ffde0

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX|
#line 587
|__asm___19_stm32f1xx_hal_adc_c_52ef8f50____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
