; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_pwr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_pwr.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_pwr.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_pwr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWR_OverloadWfe PROC
                  ||__tagsym$$noinline||
;;;134    __NOINLINE
;;;135    static void PWR_OverloadWfe(void)
000000  bf20              WFE      
;;;136    {
;;;137      __asm volatile( "wfe" );
;;;138      __asm volatile( "nop" );
000002  bf00              NOP      
;;;139    }
000004  4770              BX       lr
;;;140    
                          ENDP

                  HAL_PWR_DeInit PROC
;;;173      */
;;;174    void HAL_PWR_DeInit(void)
000006  4888              LDR      r0,|L1.552|
;;;175    {
;;;176      __HAL_RCC_PWR_FORCE_RESET();
000008  6900              LDR      r0,[r0,#0x10]
00000a  f0405080          ORR      r0,r0,#0x10000000
00000e  4986              LDR      r1,|L1.552|
000010  6108              STR      r0,[r1,#0x10]
;;;177      __HAL_RCC_PWR_RELEASE_RESET();
000012  4608              MOV      r0,r1
000014  6900              LDR      r0,[r0,#0x10]
000016  f0205080          BIC      r0,r0,#0x10000000
00001a  6108              STR      r0,[r1,#0x10]
;;;178    }
00001c  4770              BX       lr
;;;179    
                          ENDP

                  HAL_PWR_EnableBkUpAccess PROC
;;;186      */
;;;187    void HAL_PWR_EnableBkUpAccess(void)
00001e  2001              MOVS     r0,#1
;;;188    {
;;;189      /* Enable access to RTC and backup registers */
;;;190      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
000020  0201              LSLS     r1,r0,#8
000022  fa91f1a1          RBIT     r1,r1
000026  fab1f181          CLZ      r1,r1
00002a  4a80              LDR      r2,|L1.556|
00002c  f8420021          STR      r0,[r2,r1,LSL #2]
;;;191    }
000030  4770              BX       lr
;;;192    
                          ENDP

                  HAL_PWR_DisableBkUpAccess PROC
;;;199      */
;;;200    void HAL_PWR_DisableBkUpAccess(void)
000032  2000              MOVS     r0,#0
;;;201    {
;;;202      /* Disable access to RTC and backup registers */
;;;203      *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
000034  f44f7180          MOV      r1,#0x100
000038  fa91f1a1          RBIT     r1,r1
00003c  fab1f181          CLZ      r1,r1
000040  4a7a              LDR      r2,|L1.556|
000042  f8420021          STR      r0,[r2,r1,LSL #2]
;;;204    }
000046  4770              BX       lr
;;;205    
                          ENDP

                  HAL_PWR_ConfigPVD PROC
;;;333      */
;;;334    void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
000048  4979              LDR      r1,|L1.560|
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
;;;338      assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
;;;339    
;;;340      /* Set PLS[7:5] bits according to PVDLevel value */
;;;341      MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
00004a  6809              LDR      r1,[r1,#0]
00004c  f02101e0          BIC      r1,r1,#0xe0
000050  6802              LDR      r2,[r0,#0]
000052  4311              ORRS     r1,r1,r2
000054  4a76              LDR      r2,|L1.560|
000056  6011              STR      r1,[r2,#0]
;;;342      
;;;343      /* Clear any previous config. Keep it clear if no event or IT mode is selected */
;;;344      __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
000058  4976              LDR      r1,|L1.564|
00005a  6809              LDR      r1,[r1,#0]
00005c  f4213180          BIC      r1,r1,#0x10000
000060  4a74              LDR      r2,|L1.564|
000062  6011              STR      r1,[r2,#0]
;;;345      __HAL_PWR_PVD_EXTI_DISABLE_IT();
000064  1f11              SUBS     r1,r2,#4
000066  6809              LDR      r1,[r1,#0]
000068  f4213180          BIC      r1,r1,#0x10000
00006c  1f12              SUBS     r2,r2,#4
00006e  6011              STR      r1,[r2,#0]
;;;346      __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
000070  4970              LDR      r1,|L1.564|
000072  3108              ADDS     r1,r1,#8
000074  6809              LDR      r1,[r1,#0]
000076  f4213180          BIC      r1,r1,#0x10000
00007a  4a6e              LDR      r2,|L1.564|
00007c  3208              ADDS     r2,r2,#8
00007e  6011              STR      r1,[r2,#0]
;;;347      __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
000080  1f11              SUBS     r1,r2,#4
000082  6809              LDR      r1,[r1,#0]
000084  f4213180          BIC      r1,r1,#0x10000
000088  1f12              SUBS     r2,r2,#4
00008a  6011              STR      r1,[r2,#0]
;;;348    
;;;349      /* Configure interrupt mode */
;;;350      if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
00008c  6841              LDR      r1,[r0,#4]
00008e  f4013180          AND      r1,r1,#0x10000
000092  f5b13f80          CMP      r1,#0x10000
000096  d107              BNE      |L1.168|
;;;351      {
;;;352        __HAL_PWR_PVD_EXTI_ENABLE_IT();
000098  4966              LDR      r1,|L1.564|
00009a  1f09              SUBS     r1,r1,#4
00009c  6809              LDR      r1,[r1,#0]
00009e  f4413180          ORR      r1,r1,#0x10000
0000a2  4a64              LDR      r2,|L1.564|
0000a4  1f12              SUBS     r2,r2,#4
0000a6  6011              STR      r1,[r2,#0]
                  |L1.168|
;;;353      }
;;;354      
;;;355      /* Configure event mode */
;;;356      if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
0000a8  6841              LDR      r1,[r0,#4]
0000aa  f4013100          AND      r1,r1,#0x20000
0000ae  f5b13f00          CMP      r1,#0x20000
0000b2  d105              BNE      |L1.192|
;;;357      {
;;;358        __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
0000b4  495f              LDR      r1,|L1.564|
0000b6  6809              LDR      r1,[r1,#0]
0000b8  f4413180          ORR      r1,r1,#0x10000
0000bc  4a5d              LDR      r2,|L1.564|
0000be  6011              STR      r1,[r2,#0]
                  |L1.192|
;;;359      }
;;;360      
;;;361      /* Configure the edge */
;;;362      if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
0000c0  7901              LDRB     r1,[r0,#4]
0000c2  f0010101          AND      r1,r1,#1
0000c6  b139              CBZ      r1,|L1.216|
;;;363      {
;;;364        __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
0000c8  495a              LDR      r1,|L1.564|
0000ca  1d09              ADDS     r1,r1,#4
0000cc  6809              LDR      r1,[r1,#0]
0000ce  f4413180          ORR      r1,r1,#0x10000
0000d2  4a58              LDR      r2,|L1.564|
0000d4  1d12              ADDS     r2,r2,#4
0000d6  6011              STR      r1,[r2,#0]
                  |L1.216|
;;;365      }
;;;366      
;;;367      if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
0000d8  7901              LDRB     r1,[r0,#4]
0000da  f0010102          AND      r1,r1,#2
0000de  2902              CMP      r1,#2
0000e0  d107              BNE      |L1.242|
;;;368      {
;;;369        __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
0000e2  4954              LDR      r1,|L1.564|
0000e4  3108              ADDS     r1,r1,#8
0000e6  6809              LDR      r1,[r1,#0]
0000e8  f4413180          ORR      r1,r1,#0x10000
0000ec  4a51              LDR      r2,|L1.564|
0000ee  3208              ADDS     r2,r2,#8
0000f0  6011              STR      r1,[r2,#0]
                  |L1.242|
;;;370      }
;;;371    }
0000f2  4770              BX       lr
;;;372    
                          ENDP

                  HAL_PWR_EnablePVD PROC
;;;376      */
;;;377    void HAL_PWR_EnablePVD(void)
0000f4  2001              MOVS     r0,#1
;;;378    {
;;;379      /* Enable the power voltage detector */
;;;380      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
0000f6  2110              MOVS     r1,#0x10
0000f8  fa91f1a1          RBIT     r1,r1
0000fc  fab1f181          CLZ      r1,r1
000100  4a4a              LDR      r2,|L1.556|
000102  f8420021          STR      r0,[r2,r1,LSL #2]
;;;381    }
000106  4770              BX       lr
;;;382    
                          ENDP

                  HAL_PWR_DisablePVD PROC
;;;386      */
;;;387    void HAL_PWR_DisablePVD(void)
000108  2000              MOVS     r0,#0
;;;388    {
;;;389      /* Disable the power voltage detector */
;;;390      *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
00010a  2110              MOVS     r1,#0x10
00010c  fa91f1a1          RBIT     r1,r1
000110  fab1f181          CLZ      r1,r1
000114  4a45              LDR      r2,|L1.556|
000116  f8420021          STR      r0,[r2,r1,LSL #2]
;;;391    }
00011a  4770              BX       lr
;;;392    
                          ENDP

                  HAL_PWR_EnableWakeUpPin PROC
;;;399      */
;;;400    void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
00011c  2101              MOVS     r1,#1
;;;401    {
;;;402      /* Check the parameter */
;;;403      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
;;;404      /* Enable the EWUPx pin */
;;;405      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
00011e  fa90f2a0          RBIT     r2,r0
000122  fab2f282          CLZ      r2,r2
000126  4b41              LDR      r3,|L1.556|
000128  eb030282          ADD      r2,r3,r2,LSL #2
00012c  f8c21080          STR      r1,[r2,#0x80]
;;;406    }
000130  4770              BX       lr
;;;407    
                          ENDP

                  HAL_PWR_DisableWakeUpPin PROC
;;;414      */
;;;415    void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
000132  2100              MOVS     r1,#0
;;;416    {
;;;417      /* Check the parameter */
;;;418      assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
;;;419      /* Disable the EWUPx pin */
;;;420      *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
000134  fa90f2a0          RBIT     r2,r0
000138  fab2f282          CLZ      r2,r2
00013c  4b3b              LDR      r3,|L1.556|
00013e  eb030282          ADD      r2,r3,r2,LSL #2
000142  f8c21080          STR      r1,[r2,#0x80]
;;;421    }
000146  4770              BX       lr
;;;422    
                          ENDP

                  HAL_PWR_EnterSLEEPMode PROC
;;;434      */
;;;435    void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
000148  4a3b              LDR      r2,|L1.568|
;;;436    {
;;;437      /* Check the parameters */
;;;438      /* No check on Regulator because parameter not used in SLEEP mode */
;;;439      assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
;;;440    
;;;441      /* Clear SLEEPDEEP bit of Cortex System Control Register */
;;;442      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
00014a  6812              LDR      r2,[r2,#0]
00014c  f0220204          BIC      r2,r2,#4
000150  4b39              LDR      r3,|L1.568|
000152  601a              STR      r2,[r3,#0]
;;;443    
;;;444      /* Select SLEEP mode entry -------------------------------------------------*/
;;;445      if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
000154  2901              CMP      r1,#1
000156  d101              BNE      |L1.348|
;;;446      {
;;;447        /* Request Wait For Interrupt */
;;;448        __WFI();
000158  bf30              WFI      
00015a  e002              B        |L1.354|
                  |L1.348|
;;;449      }
;;;450      else
;;;451      {
;;;452        /* Request Wait For Event */
;;;453        __SEV();
00015c  bf40              SEV      
;;;454        __WFE();
00015e  bf20              WFE      
;;;455        __WFE();
000160  bf20              WFE      
                  |L1.354|
;;;456      }
;;;457    }
000162  4770              BX       lr
;;;458    
                          ENDP

                  HAL_PWR_EnterSTOPMode PROC
;;;477      */
;;;478    void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000164  b570              PUSH     {r4-r6,lr}
;;;479    {
000166  4604              MOV      r4,r0
000168  460d              MOV      r5,r1
;;;480      /* Check the parameters */
;;;481      assert_param(IS_PWR_REGULATOR(Regulator));
;;;482      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;483    
;;;484      /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */ 
;;;485      CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
00016a  4831              LDR      r0,|L1.560|
00016c  6800              LDR      r0,[r0,#0]
00016e  f0200002          BIC      r0,r0,#2
000172  492f              LDR      r1,|L1.560|
000174  6008              STR      r0,[r1,#0]
;;;486    
;;;487      /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator parameter value */
;;;488      MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
000176  4608              MOV      r0,r1
000178  6800              LDR      r0,[r0,#0]
00017a  f0200001          BIC      r0,r0,#1
00017e  4320              ORRS     r0,r0,r4
000180  6008              STR      r0,[r1,#0]
;;;489    
;;;490      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;491      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
000182  482d              LDR      r0,|L1.568|
000184  6800              LDR      r0,[r0,#0]
000186  f0400004          ORR      r0,r0,#4
00018a  492b              LDR      r1,|L1.568|
00018c  6008              STR      r0,[r1,#0]
;;;492    
;;;493      /* Select Stop mode entry --------------------------------------------------*/
;;;494      if(STOPEntry == PWR_STOPENTRY_WFI)
00018e  2d01              CMP      r5,#1
000190  d101              BNE      |L1.406|
;;;495      {
;;;496        /* Request Wait For Interrupt */
;;;497        __WFI();
000192  bf30              WFI      
000194  e004              B        |L1.416|
                  |L1.406|
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Request Wait For Event */
;;;502        __SEV();
000196  bf40              SEV      
;;;503        PWR_OverloadWfe(); /* WFE redefine locally */
000198  f7fffffe          BL       PWR_OverloadWfe
;;;504        PWR_OverloadWfe(); /* WFE redefine locally */
00019c  f7fffffe          BL       PWR_OverloadWfe
                  |L1.416|
;;;505      }
;;;506      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;507      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
0001a0  4825              LDR      r0,|L1.568|
0001a2  6800              LDR      r0,[r0,#0]
0001a4  f0200004          BIC      r0,r0,#4
0001a8  4923              LDR      r1,|L1.568|
0001aa  6008              STR      r0,[r1,#0]
;;;508    }
0001ac  bd70              POP      {r4-r6,pc}
;;;509    
                          ENDP

                  HAL_PWR_EnterSTANDBYMode PROC
;;;517      */
;;;518    void HAL_PWR_EnterSTANDBYMode(void)
0001ae  4820              LDR      r0,|L1.560|
;;;519    {
;;;520      /* Select Standby mode */
;;;521      SET_BIT(PWR->CR, PWR_CR_PDDS);
0001b0  6800              LDR      r0,[r0,#0]
0001b2  f0400002          ORR      r0,r0,#2
0001b6  491e              LDR      r1,|L1.560|
0001b8  6008              STR      r0,[r1,#0]
;;;522    
;;;523      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;524      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
0001ba  481f              LDR      r0,|L1.568|
0001bc  6800              LDR      r0,[r0,#0]
0001be  f0400004          ORR      r0,r0,#4
0001c2  491d              LDR      r1,|L1.568|
0001c4  6008              STR      r0,[r1,#0]
;;;525    
;;;526      /* This option is used to ensure that store operations are completed */
;;;527    #if defined ( __CC_ARM)
;;;528      __force_stores();
0001c6  bf00              NOP      
0001c8  bf00              NOP      
;;;529    #endif
;;;530      /* Request Wait For Interrupt */
;;;531      __WFI();
0001ca  bf30              WFI      
;;;532    }
0001cc  4770              BX       lr
;;;533    
                          ENDP

                  HAL_PWR_EnableSleepOnExit PROC
;;;542      */
;;;543    void HAL_PWR_EnableSleepOnExit(void)
0001ce  481a              LDR      r0,|L1.568|
;;;544    {
;;;545      /* Set SLEEPONEXIT bit of Cortex System Control Register */
;;;546      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
0001d0  6800              LDR      r0,[r0,#0]
0001d2  f0400002          ORR      r0,r0,#2
0001d6  4918              LDR      r1,|L1.568|
0001d8  6008              STR      r0,[r1,#0]
;;;547    }
0001da  4770              BX       lr
;;;548    
                          ENDP

                  HAL_PWR_DisableSleepOnExit PROC
;;;555      */
;;;556    void HAL_PWR_DisableSleepOnExit(void)
0001dc  4816              LDR      r0,|L1.568|
;;;557    {
;;;558      /* Clear SLEEPONEXIT bit of Cortex System Control Register */
;;;559      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
0001de  6800              LDR      r0,[r0,#0]
0001e0  f0200002          BIC      r0,r0,#2
0001e4  4914              LDR      r1,|L1.568|
0001e6  6008              STR      r0,[r1,#0]
;;;560    }
0001e8  4770              BX       lr
;;;561    
                          ENDP

                  HAL_PWR_EnableSEVOnPend PROC
;;;568      */
;;;569    void HAL_PWR_EnableSEVOnPend(void)
0001ea  4813              LDR      r0,|L1.568|
;;;570    {
;;;571      /* Set SEVONPEND bit of Cortex System Control Register */
;;;572      SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
0001ec  6800              LDR      r0,[r0,#0]
0001ee  f0400010          ORR      r0,r0,#0x10
0001f2  4911              LDR      r1,|L1.568|
0001f4  6008              STR      r0,[r1,#0]
;;;573    }
0001f6  4770              BX       lr
;;;574    
                          ENDP

                  HAL_PWR_DisableSEVOnPend PROC
;;;581      */
;;;582    void HAL_PWR_DisableSEVOnPend(void)
0001f8  480f              LDR      r0,|L1.568|
;;;583    {
;;;584      /* Clear SEVONPEND bit of Cortex System Control Register */
;;;585      CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
0001fa  6800              LDR      r0,[r0,#0]
0001fc  f0200010          BIC      r0,r0,#0x10
000200  490d              LDR      r1,|L1.568|
000202  6008              STR      r0,[r1,#0]
;;;586    }
000204  4770              BX       lr
;;;587    
                          ENDP

                  HAL_PWR_PVDCallback PROC
;;;611      */
;;;612    __weak void HAL_PWR_PVDCallback(void)
000206  4770              BX       lr
;;;613    {
;;;614      /* NOTE : This function Should not be modified, when the callback is needed,
;;;615                the HAL_PWR_PVDCallback could be implemented in the user file
;;;616       */ 
;;;617    }
;;;618    
                          ENDP

                  HAL_PWR_PVD_IRQHandler PROC
;;;594      */
;;;595    void HAL_PWR_PVD_IRQHandler(void)
000208  b510              PUSH     {r4,lr}
;;;596    {
;;;597      /* Check PWR exti flag */
;;;598      if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
00020a  480a              LDR      r0,|L1.564|
00020c  3010              ADDS     r0,r0,#0x10
00020e  6800              LDR      r0,[r0,#0]
000210  f4003080          AND      r0,r0,#0x10000
000214  b130              CBZ      r0,|L1.548|
;;;599      {
;;;600        /* PWR PVD interrupt user callback */
;;;601        HAL_PWR_PVDCallback();
000216  f7fffffe          BL       HAL_PWR_PVDCallback
;;;602    
;;;603        /* Clear PWR Exti pending bit */
;;;604        __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
00021a  f44f3080          MOV      r0,#0x10000
00021e  4905              LDR      r1,|L1.564|
000220  3110              ADDS     r1,r1,#0x10
000222  6008              STR      r0,[r1,#0]
                  |L1.548|
;;;605      }
;;;606    }
000224  bd10              POP      {r4,pc}
;;;607    
                          ENDP

000226  0000              DCW      0x0000
                  |L1.552|
                          DCD      0x40021000
                  |L1.556|
                          DCD      0x420e0000
                  |L1.560|
                          DCD      0x40007000
                  |L1.564|
                          DCD      0x40010404
                  |L1.568|
                          DCD      0xe000ed10

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX|
#line 587
|__asm___19_stm32f1xx_hal_pwr_c_f2cfe8be____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
