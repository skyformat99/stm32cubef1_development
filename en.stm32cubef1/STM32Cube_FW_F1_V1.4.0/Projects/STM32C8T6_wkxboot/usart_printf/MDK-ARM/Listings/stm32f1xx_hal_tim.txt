; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_tim.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_tim.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_tim.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TIM_Base_SetConfig PROC
;;;4552     */
;;;4553   void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
000000  2200              MOVS     r2,#0
;;;4554   {
;;;4555     uint32_t tmpcr1 = 0;
;;;4556     tmpcr1 = TIMx->CR1;
000002  6802              LDR      r2,[r0,#0]
;;;4557   
;;;4558     /* Set TIM Time Base Unit parameters ---------------------------------------*/
;;;4559     if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000004  f1b04f80          CMP      r0,#0x40000000
000008  d005              BEQ      |L1.22|
00000a  4bf8              LDR      r3,|L1.1004|
00000c  4298              CMP      r0,r3
00000e  d002              BEQ      |L1.22|
000010  4bf7              LDR      r3,|L1.1008|
000012  4298              CMP      r0,r3
000014  d103              BNE      |L1.30|
                  |L1.22|
;;;4560     {
;;;4561       /* Select the Counter Mode */
;;;4562       tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000016  f0220270          BIC      r2,r2,#0x70
;;;4563       tmpcr1 |= Structure->CounterMode;
00001a  684b              LDR      r3,[r1,#4]
00001c  431a              ORRS     r2,r2,r3
                  |L1.30|
;;;4564     }
;;;4565   
;;;4566     if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
00001e  f1b04f80          CMP      r0,#0x40000000
000022  d005              BEQ      |L1.48|
000024  4bf1              LDR      r3,|L1.1004|
000026  4298              CMP      r0,r3
000028  d002              BEQ      |L1.48|
00002a  4bf1              LDR      r3,|L1.1008|
00002c  4298              CMP      r0,r3
00002e  d103              BNE      |L1.56|
                  |L1.48|
;;;4567     {
;;;4568       /* Set the clock division */
;;;4569       tmpcr1 &= ~TIM_CR1_CKD;
000030  f4227240          BIC      r2,r2,#0x300
;;;4570       tmpcr1 |= (uint32_t)Structure->ClockDivision;
000034  68cb              LDR      r3,[r1,#0xc]
000036  431a              ORRS     r2,r2,r3
                  |L1.56|
;;;4571     }
;;;4572   
;;;4573     TIMx->CR1 = tmpcr1;
000038  6002              STR      r2,[r0,#0]
;;;4574   
;;;4575     /* Set the Autoreload value */
;;;4576     TIMx->ARR = (uint32_t)Structure->Period ;
00003a  688b              LDR      r3,[r1,#8]
00003c  62c3              STR      r3,[r0,#0x2c]
;;;4577   
;;;4578     /* Set the Prescaler value */
;;;4579     TIMx->PSC = (uint32_t)Structure->Prescaler;
00003e  680b              LDR      r3,[r1,#0]
000040  6283              STR      r3,[r0,#0x28]
;;;4580   
;;;4581     if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
;;;4582     {
;;;4583       /* Set the Repetition Counter value */
;;;4584       TIMx->RCR = Structure->RepetitionCounter;
;;;4585     }
;;;4586   
;;;4587     /* Generate an update event to reload the Prescaler 
;;;4588        and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;4589     TIMx->EGR = TIM_EGR_UG;
000042  2301              MOVS     r3,#1
000044  6143              STR      r3,[r0,#0x14]
;;;4590   }
000046  4770              BX       lr
;;;4591   
                          ENDP

                  HAL_TIM_Base_MspInit PROC
;;;271      */
;;;272    __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
000048  4770              BX       lr
;;;273    {
;;;274      /* Prevent unused argument(s) compilation warning */
;;;275      UNUSED(htim);
;;;276      /* NOTE : This function Should not be modified, when the callback is needed,
;;;277                the HAL_TIM_Base_MspInit could be implemented in the user file
;;;278       */
;;;279    }
;;;280    
                          ENDP

                  HAL_TIM_Base_Init PROC
;;;205      */
;;;206    HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
00004a  b510              PUSH     {r4,lr}
;;;207    {
00004c  4604              MOV      r4,r0
;;;208      /* Check the TIM handle allocation */
;;;209      if(htim == NULL)
00004e  b90c              CBNZ     r4,|L1.84|
;;;210      {
;;;211        return HAL_ERROR;
000050  2001              MOVS     r0,#1
                  |L1.82|
;;;212      }
;;;213    
;;;214      /* Check the parameters */
;;;215      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;216      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;217      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;218    
;;;219      if(htim->State == HAL_TIM_STATE_RESET)
;;;220      {
;;;221        /* Allocate lock resource and initialize it */
;;;222        htim->Lock = HAL_UNLOCKED;
;;;223        
;;;224        /* Init the low level hardware : GPIO, CLOCK, NVIC */
;;;225        HAL_TIM_Base_MspInit(htim);
;;;226      }
;;;227    
;;;228      /* Set the TIM state */
;;;229      htim->State= HAL_TIM_STATE_BUSY;
;;;230    
;;;231      /* Set the Time Base configuration */
;;;232      TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;233    
;;;234      /* Initialize the TIM state*/
;;;235      htim->State= HAL_TIM_STATE_READY;
;;;236    
;;;237      return HAL_OK;
;;;238    }
000052  bd10              POP      {r4,pc}
                  |L1.84|
000054  f8940039          LDRB     r0,[r4,#0x39]         ;219
000058  b928              CBNZ     r0,|L1.102|
00005a  2000              MOVS     r0,#0                 ;222
00005c  f8840038          STRB     r0,[r4,#0x38]         ;222
000060  4620              MOV      r0,r4                 ;225
000062  f7fffffe          BL       HAL_TIM_Base_MspInit
                  |L1.102|
000066  2002              MOVS     r0,#2                 ;229
000068  f8840039          STRB     r0,[r4,#0x39]         ;229
00006c  1d21              ADDS     r1,r4,#4              ;232
00006e  6820              LDR      r0,[r4,#0]            ;232
000070  f7fffffe          BL       TIM_Base_SetConfig
000074  2001              MOVS     r0,#1                 ;235
000076  f8840039          STRB     r0,[r4,#0x39]         ;235
00007a  2000              MOVS     r0,#0                 ;237
00007c  e7e9              B        |L1.82|
;;;239    
                          ENDP

                  HAL_TIM_Base_MspDeInit PROC
;;;285      */
;;;286    __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
00007e  4770              BX       lr
;;;287    {
;;;288      /* Prevent unused argument(s) compilation warning */
;;;289      UNUSED(htim);
;;;290      /* NOTE : This function Should not be modified, when the callback is needed,
;;;291                the HAL_TIM_Base_MspDeInit could be implemented in the user file
;;;292       */
;;;293    }
;;;294    
                          ENDP

                  HAL_TIM_Base_DeInit PROC
;;;244      */
;;;245    HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
000080  b510              PUSH     {r4,lr}
;;;246    {
000082  4604              MOV      r4,r0
;;;247      /* Check the parameters */
;;;248      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;249    
;;;250      htim->State = HAL_TIM_STATE_BUSY;
000084  2002              MOVS     r0,#2
000086  f8840039          STRB     r0,[r4,#0x39]
;;;251    
;;;252      /* Disable the TIM Peripheral Clock */
;;;253      __HAL_TIM_DISABLE(htim);
00008a  bf00              NOP      
00008c  6820              LDR      r0,[r4,#0]
00008e  6a00              LDR      r0,[r0,#0x20]
000090  f2411111          MOV      r1,#0x1111
000094  4008              ANDS     r0,r0,r1
000096  b950              CBNZ     r0,|L1.174|
000098  6820              LDR      r0,[r4,#0]
00009a  6a00              LDR      r0,[r0,#0x20]
00009c  1089              ASRS     r1,r1,#2
00009e  4008              ANDS     r0,r0,r1
0000a0  b928              CBNZ     r0,|L1.174|
0000a2  6820              LDR      r0,[r4,#0]
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f0200001          BIC      r0,r0,#1
0000aa  6821              LDR      r1,[r4,#0]
0000ac  6008              STR      r0,[r1,#0]
                  |L1.174|
0000ae  bf00              NOP      
;;;254    
;;;255      /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;256      HAL_TIM_Base_MspDeInit(htim);
0000b0  4620              MOV      r0,r4
0000b2  f7fffffe          BL       HAL_TIM_Base_MspDeInit
;;;257    
;;;258      /* Change TIM state */
;;;259      htim->State = HAL_TIM_STATE_RESET;
0000b6  2000              MOVS     r0,#0
0000b8  f8840039          STRB     r0,[r4,#0x39]
;;;260    
;;;261      /* Release Lock */
;;;262      __HAL_UNLOCK(htim);
0000bc  bf00              NOP      
0000be  f8840038          STRB     r0,[r4,#0x38]
0000c2  bf00              NOP      
;;;263    
;;;264      return HAL_OK;
;;;265    }
0000c4  bd10              POP      {r4,pc}
;;;266    
                          ENDP

                  HAL_TIM_Base_Start PROC
;;;300    */
;;;301    HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
0000c6  4601              MOV      r1,r0
;;;302    {
;;;303      /* Check the parameters */
;;;304      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;305    
;;;306      /* Set the TIM state */
;;;307      htim->State= HAL_TIM_STATE_BUSY;
0000c8  2002              MOVS     r0,#2
0000ca  f8810039          STRB     r0,[r1,#0x39]
;;;308    
;;;309      /* Enable the Peripheral */
;;;310      __HAL_TIM_ENABLE(htim);
0000ce  6808              LDR      r0,[r1,#0]
0000d0  6800              LDR      r0,[r0,#0]
0000d2  f0400001          ORR      r0,r0,#1
0000d6  680a              LDR      r2,[r1,#0]
0000d8  6010              STR      r0,[r2,#0]
;;;311    
;;;312      /* Change the TIM state*/
;;;313      htim->State= HAL_TIM_STATE_READY;
0000da  2001              MOVS     r0,#1
0000dc  f8810039          STRB     r0,[r1,#0x39]
;;;314    
;;;315      /* Return function status */
;;;316      return HAL_OK;
0000e0  2000              MOVS     r0,#0
;;;317    }
0000e2  4770              BX       lr
;;;318    
                          ENDP

                  HAL_TIM_Base_Stop PROC
;;;323    */
;;;324    HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
0000e4  4601              MOV      r1,r0
;;;325    {
;;;326      /* Check the parameters */
;;;327      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;328    
;;;329      /* Set the TIM state */
;;;330      htim->State= HAL_TIM_STATE_BUSY;
0000e6  2002              MOVS     r0,#2
0000e8  f8810039          STRB     r0,[r1,#0x39]
;;;331    
;;;332      /* Disable the Peripheral */
;;;333      __HAL_TIM_DISABLE(htim);
0000ec  bf00              NOP      
0000ee  6808              LDR      r0,[r1,#0]
0000f0  6a00              LDR      r0,[r0,#0x20]
0000f2  f2411211          MOV      r2,#0x1111
0000f6  4010              ANDS     r0,r0,r2
0000f8  b950              CBNZ     r0,|L1.272|
0000fa  6808              LDR      r0,[r1,#0]
0000fc  6a00              LDR      r0,[r0,#0x20]
0000fe  1092              ASRS     r2,r2,#2
000100  4010              ANDS     r0,r0,r2
000102  b928              CBNZ     r0,|L1.272|
000104  6808              LDR      r0,[r1,#0]
000106  6800              LDR      r0,[r0,#0]
000108  f0200001          BIC      r0,r0,#1
00010c  680a              LDR      r2,[r1,#0]
00010e  6010              STR      r0,[r2,#0]
                  |L1.272|
000110  bf00              NOP      
;;;334    
;;;335      /* Change the TIM state*/
;;;336      htim->State= HAL_TIM_STATE_READY;
000112  2001              MOVS     r0,#1
000114  f8810039          STRB     r0,[r1,#0x39]
;;;337    
;;;338      /* Return function status */
;;;339      return HAL_OK;
000118  2000              MOVS     r0,#0
;;;340    }
00011a  4770              BX       lr
;;;341    
                          ENDP

                  HAL_TIM_Base_Start_IT PROC
;;;346    */
;;;347    HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
00011c  4601              MOV      r1,r0
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;351    
;;;352       /* Enable the TIM Update interrupt */
;;;353       __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
00011e  6808              LDR      r0,[r1,#0]
000120  68c0              LDR      r0,[r0,#0xc]
000122  f0400001          ORR      r0,r0,#1
000126  680a              LDR      r2,[r1,#0]
000128  60d0              STR      r0,[r2,#0xc]
;;;354    
;;;355       /* Enable the Peripheral */
;;;356      __HAL_TIM_ENABLE(htim);
00012a  6808              LDR      r0,[r1,#0]
00012c  6800              LDR      r0,[r0,#0]
00012e  f0400001          ORR      r0,r0,#1
000132  680a              LDR      r2,[r1,#0]
000134  6010              STR      r0,[r2,#0]
;;;357    
;;;358      /* Return function status */
;;;359      return HAL_OK;
000136  2000              MOVS     r0,#0
;;;360    }
000138  4770              BX       lr
;;;361    
                          ENDP

                  HAL_TIM_Base_Stop_IT PROC
;;;366    */
;;;367    HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
00013a  4601              MOV      r1,r0
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;371      /* Disable the TIM Update interrupt */
;;;372      __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
00013c  6808              LDR      r0,[r1,#0]
00013e  68c0              LDR      r0,[r0,#0xc]
000140  f0200001          BIC      r0,r0,#1
000144  680a              LDR      r2,[r1,#0]
000146  60d0              STR      r0,[r2,#0xc]
;;;373    
;;;374      /* Disable the Peripheral */
;;;375      __HAL_TIM_DISABLE(htim);
000148  bf00              NOP      
00014a  6808              LDR      r0,[r1,#0]
00014c  6a00              LDR      r0,[r0,#0x20]
00014e  f2411211          MOV      r2,#0x1111
000152  4010              ANDS     r0,r0,r2
000154  b950              CBNZ     r0,|L1.364|
000156  6808              LDR      r0,[r1,#0]
000158  6a00              LDR      r0,[r0,#0x20]
00015a  1092              ASRS     r2,r2,#2
00015c  4010              ANDS     r0,r0,r2
00015e  b928              CBNZ     r0,|L1.364|
000160  6808              LDR      r0,[r1,#0]
000162  6800              LDR      r0,[r0,#0]
000164  f0200001          BIC      r0,r0,#1
000168  680a              LDR      r2,[r1,#0]
00016a  6010              STR      r0,[r2,#0]
                  |L1.364|
00016c  bf00              NOP      
;;;376    
;;;377      /* Return function status */
;;;378      return HAL_OK;
00016e  2000              MOVS     r0,#0
;;;379    }
000170  4770              BX       lr
;;;380    
                          ENDP

                  HAL_TIM_ErrorCallback PROC
;;;4339     */
;;;4340   __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
000172  4770              BX       lr
;;;4341   {
;;;4342     /* Prevent unused argument(s) compilation warning */
;;;4343     UNUSED(htim);
;;;4344     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4345               the HAL_TIM_ErrorCallback could be implemented in the user file
;;;4346      */
;;;4347   }
;;;4348   
                          ENDP

                  TIM_DMAError PROC
;;;4444     */
;;;4445   void TIM_DMAError(DMA_HandleTypeDef *hdma)
000174  b570              PUSH     {r4-r6,lr}
;;;4446   {
000176  4604              MOV      r4,r0
;;;4447     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000178  6a65              LDR      r5,[r4,#0x24]
;;;4448   
;;;4449     htim->State= HAL_TIM_STATE_READY;
00017a  2001              MOVS     r0,#1
00017c  f8850039          STRB     r0,[r5,#0x39]
;;;4450   
;;;4451     HAL_TIM_ErrorCallback(htim);
000180  4628              MOV      r0,r5
000182  f7fffffe          BL       HAL_TIM_ErrorCallback
;;;4452   }
000186  bd70              POP      {r4-r6,pc}
;;;4453   
                          ENDP

                  HAL_TIM_PeriodElapsedCallback PROC
;;;4270     */
;;;4271   __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
000188  4770              BX       lr
;;;4272   {
;;;4273     /* Prevent unused argument(s) compilation warning */
;;;4274     UNUSED(htim);
;;;4275     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4276               the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
;;;4277      */
;;;4278   
;;;4279   }
;;;4280   /**
                          ENDP

                  TIM_DMAPeriodElapsedCplt PROC
;;;4523     */
;;;4524   static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
00018a  b570              PUSH     {r4-r6,lr}
;;;4525   {
00018c  4604              MOV      r4,r0
;;;4526     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00018e  6a65              LDR      r5,[r4,#0x24]
;;;4527   
;;;4528     htim->State= HAL_TIM_STATE_READY;
000190  2001              MOVS     r0,#1
000192  f8850039          STRB     r0,[r5,#0x39]
;;;4529   
;;;4530     HAL_TIM_PeriodElapsedCallback(htim);
000196  4628              MOV      r0,r5
000198  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
;;;4531   }
00019c  bd70              POP      {r4-r6,pc}
;;;4532   
                          ENDP

                  HAL_TIM_Base_Start_DMA PROC
;;;387    */
;;;388    HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
00019e  b570              PUSH     {r4-r6,lr}
;;;389    {
0001a0  4604              MOV      r4,r0
0001a2  460e              MOV      r6,r1
0001a4  4615              MOV      r5,r2
;;;390      /* Check the parameters */
;;;391      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;392    
;;;393      if((htim->State == HAL_TIM_STATE_BUSY))
0001a6  f8940039          LDRB     r0,[r4,#0x39]
0001aa  2802              CMP      r0,#2
0001ac  d100              BNE      |L1.432|
                  |L1.430|
;;;394      {
;;;395         return HAL_BUSY;
;;;396      }
;;;397      else if((htim->State == HAL_TIM_STATE_READY))
;;;398      {
;;;399        if((pData == 0 ) && (Length > 0))
;;;400        {
;;;401          return HAL_ERROR;
;;;402        }
;;;403        else
;;;404        {
;;;405          htim->State = HAL_TIM_STATE_BUSY;
;;;406        }
;;;407      }
;;;408      /* Set the DMA Period elapsed callback */
;;;409      htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;410    
;;;411      /* Set the DMA error callback */
;;;412      htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;413    
;;;414      /* Enable the DMA channel */
;;;415      HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
;;;416    
;;;417      /* Enable the TIM Update DMA request */
;;;418      __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
;;;419    
;;;420      /* Enable the Peripheral */
;;;421      __HAL_TIM_ENABLE(htim);
;;;422    
;;;423      /* Return function status */
;;;424      return HAL_OK;
;;;425    }
0001ae  bd70              POP      {r4-r6,pc}
                  |L1.432|
0001b0  f8940039          LDRB     r0,[r4,#0x39]         ;397
0001b4  2801              CMP      r0,#1                 ;397
0001b6  d106              BNE      |L1.454|
0001b8  b916              CBNZ     r6,|L1.448|
0001ba  2d00              CMP      r5,#0                 ;399
0001bc  dd00              BLE      |L1.448|
0001be  e7f6              B        |L1.430|
                  |L1.448|
0001c0  2002              MOVS     r0,#2                 ;405
0001c2  f8840039          STRB     r0,[r4,#0x39]         ;405
                  |L1.454|
0001c6  488b              LDR      r0,|L1.1012|
0001c8  69e1              LDR      r1,[r4,#0x1c]         ;409
0001ca  6288              STR      r0,[r1,#0x28]         ;409
0001cc  f2af005b          ADR      r0,TIM_DMAError + 1
0001d0  69e1              LDR      r1,[r4,#0x1c]         ;412
0001d2  6308              STR      r0,[r1,#0x30]         ;412
0001d4  6821              LDR      r1,[r4,#0]            ;415
0001d6  f101022c          ADD      r2,r1,#0x2c           ;415
0001da  462b              MOV      r3,r5                 ;415
0001dc  4631              MOV      r1,r6                 ;415
0001de  69e0              LDR      r0,[r4,#0x1c]         ;415
0001e0  f7fffffe          BL       HAL_DMA_Start_IT
0001e4  6820              LDR      r0,[r4,#0]            ;418
0001e6  68c0              LDR      r0,[r0,#0xc]          ;418
0001e8  f4407080          ORR      r0,r0,#0x100          ;418
0001ec  6821              LDR      r1,[r4,#0]            ;418
0001ee  60c8              STR      r0,[r1,#0xc]          ;418
0001f0  6820              LDR      r0,[r4,#0]            ;421
0001f2  6800              LDR      r0,[r0,#0]            ;421
0001f4  f0400001          ORR      r0,r0,#1              ;421
0001f8  6821              LDR      r1,[r4,#0]            ;421
0001fa  6008              STR      r0,[r1,#0]            ;421
0001fc  2000              MOVS     r0,#0                 ;424
0001fe  e7d6              B        |L1.430|
;;;426    
                          ENDP

                  HAL_TIM_Base_Stop_DMA PROC
;;;431    */
;;;432    HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
000200  4601              MOV      r1,r0
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
;;;436    
;;;437      /* Disable the TIM Update DMA request */
;;;438      __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
000202  6808              LDR      r0,[r1,#0]
000204  68c0              LDR      r0,[r0,#0xc]
000206  f4207080          BIC      r0,r0,#0x100
00020a  680a              LDR      r2,[r1,#0]
00020c  60d0              STR      r0,[r2,#0xc]
;;;439    
;;;440      /* Disable the Peripheral */
;;;441      __HAL_TIM_DISABLE(htim);
00020e  bf00              NOP      
000210  6808              LDR      r0,[r1,#0]
000212  6a00              LDR      r0,[r0,#0x20]
000214  f2411211          MOV      r2,#0x1111
000218  4010              ANDS     r0,r0,r2
00021a  b950              CBNZ     r0,|L1.562|
00021c  6808              LDR      r0,[r1,#0]
00021e  6a00              LDR      r0,[r0,#0x20]
000220  1092              ASRS     r2,r2,#2
000222  4010              ANDS     r0,r0,r2
000224  b928              CBNZ     r0,|L1.562|
000226  6808              LDR      r0,[r1,#0]
000228  6800              LDR      r0,[r0,#0]
00022a  f0200001          BIC      r0,r0,#1
00022e  680a              LDR      r2,[r1,#0]
000230  6010              STR      r0,[r2,#0]
                  |L1.562|
000232  bf00              NOP      
;;;442    
;;;443      /* Change the htim state */
;;;444      htim->State = HAL_TIM_STATE_READY;
000234  2001              MOVS     r0,#1
000236  f8810039          STRB     r0,[r1,#0x39]
;;;445    
;;;446      /* Return function status */
;;;447      return HAL_OK;
00023a  2000              MOVS     r0,#0
;;;448    }
00023c  4770              BX       lr
;;;449    
                          ENDP

                  HAL_TIM_OC_MspInit PROC
;;;546      */
;;;547    __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
00023e  4770              BX       lr
;;;548    {
;;;549      /* Prevent unused argument(s) compilation warning */
;;;550      UNUSED(htim);
;;;551      /* NOTE : This function Should not be modified, when the callback is needed,
;;;552                the HAL_TIM_OC_MspInit could be implemented in the user file
;;;553       */
;;;554    }
;;;555    
                          ENDP

                  HAL_TIM_OC_Init PROC
;;;480      */
;;;481    HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
000240  b510              PUSH     {r4,lr}
;;;482    {
000242  4604              MOV      r4,r0
;;;483      /* Check the TIM handle allocation */
;;;484      if(htim == NULL)
000244  b90c              CBNZ     r4,|L1.586|
;;;485      {
;;;486        return HAL_ERROR;
000246  2001              MOVS     r0,#1
                  |L1.584|
;;;487      }
;;;488    
;;;489      /* Check the parameters */
;;;490      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;491      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;492      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;493    
;;;494      if(htim->State == HAL_TIM_STATE_RESET)
;;;495      {
;;;496        /* Allocate lock resource and initialize it */
;;;497        htim->Lock = HAL_UNLOCKED;
;;;498        
;;;499        /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;500        HAL_TIM_OC_MspInit(htim);
;;;501      }
;;;502    
;;;503      /* Set the TIM state */
;;;504      htim->State= HAL_TIM_STATE_BUSY;
;;;505    
;;;506      /* Init the base time for the Output Compare */
;;;507      TIM_Base_SetConfig(htim->Instance,  &htim->Init);
;;;508    
;;;509      /* Initialize the TIM state*/
;;;510      htim->State= HAL_TIM_STATE_READY;
;;;511    
;;;512      return HAL_OK;
;;;513    }
000248  bd10              POP      {r4,pc}
                  |L1.586|
00024a  f8940039          LDRB     r0,[r4,#0x39]         ;494
00024e  b928              CBNZ     r0,|L1.604|
000250  2000              MOVS     r0,#0                 ;497
000252  f8840038          STRB     r0,[r4,#0x38]         ;497
000256  4620              MOV      r0,r4                 ;500
000258  f7fffffe          BL       HAL_TIM_OC_MspInit
                  |L1.604|
00025c  2002              MOVS     r0,#2                 ;504
00025e  f8840039          STRB     r0,[r4,#0x39]         ;504
000262  1d21              ADDS     r1,r4,#4              ;507
000264  6820              LDR      r0,[r4,#0]            ;507
000266  f7fffffe          BL       TIM_Base_SetConfig
00026a  2001              MOVS     r0,#1                 ;510
00026c  f8840039          STRB     r0,[r4,#0x39]         ;510
000270  2000              MOVS     r0,#0                 ;512
000272  e7e9              B        |L1.584|
;;;514    
                          ENDP

                  HAL_TIM_OC_MspDeInit PROC
;;;560      */
;;;561    __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
000274  4770              BX       lr
;;;562    {
;;;563      /* Prevent unused argument(s) compilation warning */
;;;564      UNUSED(htim);
;;;565      /* NOTE : This function Should not be modified, when the callback is needed,
;;;566                the HAL_TIM_OC_MspDeInit could be implemented in the user file
;;;567       */
;;;568    }
;;;569    
                          ENDP

                  HAL_TIM_OC_DeInit PROC
;;;519      */
;;;520    HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
000276  b510              PUSH     {r4,lr}
;;;521    {
000278  4604              MOV      r4,r0
;;;522      /* Check the parameters */
;;;523      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;524    
;;;525       htim->State = HAL_TIM_STATE_BUSY;
00027a  2002              MOVS     r0,#2
00027c  f8840039          STRB     r0,[r4,#0x39]
;;;526    
;;;527      /* Disable the TIM Peripheral Clock */
;;;528      __HAL_TIM_DISABLE(htim);
000280  bf00              NOP      
000282  6820              LDR      r0,[r4,#0]
000284  6a00              LDR      r0,[r0,#0x20]
000286  f2411111          MOV      r1,#0x1111
00028a  4008              ANDS     r0,r0,r1
00028c  b950              CBNZ     r0,|L1.676|
00028e  6820              LDR      r0,[r4,#0]
000290  6a00              LDR      r0,[r0,#0x20]
000292  1089              ASRS     r1,r1,#2
000294  4008              ANDS     r0,r0,r1
000296  b928              CBNZ     r0,|L1.676|
000298  6820              LDR      r0,[r4,#0]
00029a  6800              LDR      r0,[r0,#0]
00029c  f0200001          BIC      r0,r0,#1
0002a0  6821              LDR      r1,[r4,#0]
0002a2  6008              STR      r0,[r1,#0]
                  |L1.676|
0002a4  bf00              NOP      
;;;529    
;;;530      /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;531      HAL_TIM_OC_MspDeInit(htim);
0002a6  4620              MOV      r0,r4
0002a8  f7fffffe          BL       HAL_TIM_OC_MspDeInit
;;;532    
;;;533      /* Change TIM state */
;;;534      htim->State = HAL_TIM_STATE_RESET;
0002ac  2000              MOVS     r0,#0
0002ae  f8840039          STRB     r0,[r4,#0x39]
;;;535    
;;;536      /* Release Lock */
;;;537      __HAL_UNLOCK(htim);
0002b2  bf00              NOP      
0002b4  f8840038          STRB     r0,[r4,#0x38]
0002b8  bf00              NOP      
;;;538    
;;;539      return HAL_OK;
;;;540    }
0002ba  bd10              POP      {r4,pc}
;;;541    
                          ENDP

                  TIM_CCxChannelCmd PROC
;;;5349     */
;;;5350   void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
0002bc  b530              PUSH     {r4,r5,lr}
;;;5351   {
;;;5352     uint32_t tmp = 0;
0002be  2300              MOVS     r3,#0
;;;5353   
;;;5354     /* Check the parameters */
;;;5355     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;5356     assert_param(IS_TIM_CHANNELS(Channel));
;;;5357   
;;;5358     tmp = TIM_CCER_CC1E << Channel;
0002c0  2401              MOVS     r4,#1
0002c2  fa04f301          LSL      r3,r4,r1
;;;5359   
;;;5360     /* Reset the CCxE Bit */
;;;5361     TIMx->CCER &= ~tmp;
0002c6  6a04              LDR      r4,[r0,#0x20]
0002c8  439c              BICS     r4,r4,r3
0002ca  6204              STR      r4,[r0,#0x20]
;;;5362   
;;;5363     /* Set or reset the CCxE Bit */
;;;5364     TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
0002cc  6a04              LDR      r4,[r0,#0x20]
0002ce  fa02f501          LSL      r5,r2,r1
0002d2  432c              ORRS     r4,r4,r5
0002d4  6204              STR      r4,[r0,#0x20]
;;;5365   }
0002d6  bd30              POP      {r4,r5,pc}
;;;5366   
                          ENDP

                  HAL_TIM_OC_Start PROC
;;;580    */
;;;581    HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
0002d8  b530              PUSH     {r4,r5,lr}
;;;582    {
0002da  4604              MOV      r4,r0
0002dc  460d              MOV      r5,r1
;;;583      /* Check the parameters */
;;;584      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;585    
;;;586      /* Enable the Output compare channel */
;;;587      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
0002de  2201              MOVS     r2,#1
0002e0  4629              MOV      r1,r5
0002e2  6820              LDR      r0,[r4,#0]
0002e4  f7fffffe          BL       TIM_CCxChannelCmd
;;;588    
;;;589      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;590      {
;;;591        /* Enable the main output */
;;;592        __HAL_TIM_MOE_ENABLE(htim);
;;;593      }
;;;594    
;;;595      /* Enable the Peripheral */
;;;596      __HAL_TIM_ENABLE(htim);
0002e8  6820              LDR      r0,[r4,#0]
0002ea  6800              LDR      r0,[r0,#0]
0002ec  f0400001          ORR      r0,r0,#1
0002f0  6821              LDR      r1,[r4,#0]
0002f2  6008              STR      r0,[r1,#0]
;;;597    
;;;598      /* Return function status */
;;;599      return HAL_OK;
0002f4  2000              MOVS     r0,#0
;;;600    }
0002f6  bd30              POP      {r4,r5,pc}
;;;601    
                          ENDP

                  HAL_TIM_OC_Stop PROC
;;;612    */
;;;613    HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
0002f8  b530              PUSH     {r4,r5,lr}
;;;614    {
0002fa  4604              MOV      r4,r0
0002fc  460d              MOV      r5,r1
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;617    
;;;618      /* Disable the Output compare channel */
;;;619      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0002fe  2200              MOVS     r2,#0
000300  4629              MOV      r1,r5
000302  6820              LDR      r0,[r4,#0]
000304  f7fffffe          BL       TIM_CCxChannelCmd
;;;620    
;;;621      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;622      {
;;;623        /* Disable the Main Ouput */
;;;624        __HAL_TIM_MOE_DISABLE(htim);
;;;625      }
;;;626    
;;;627      /* Disable the Peripheral */
;;;628      __HAL_TIM_DISABLE(htim);
000308  bf00              NOP      
00030a  6820              LDR      r0,[r4,#0]
00030c  6a00              LDR      r0,[r0,#0x20]
00030e  f2411111          MOV      r1,#0x1111
000312  4008              ANDS     r0,r0,r1
000314  b950              CBNZ     r0,|L1.812|
000316  6820              LDR      r0,[r4,#0]
000318  6a00              LDR      r0,[r0,#0x20]
00031a  1089              ASRS     r1,r1,#2
00031c  4008              ANDS     r0,r0,r1
00031e  b928              CBNZ     r0,|L1.812|
000320  6820              LDR      r0,[r4,#0]
000322  6800              LDR      r0,[r0,#0]
000324  f0200001          BIC      r0,r0,#1
000328  6821              LDR      r1,[r4,#0]
00032a  6008              STR      r0,[r1,#0]
                  |L1.812|
00032c  bf00              NOP      
;;;629    
;;;630      /* Return function status */
;;;631      return HAL_OK;
00032e  2000              MOVS     r0,#0
;;;632    }
000330  bd30              POP      {r4,r5,pc}
;;;633    
                          ENDP

                  HAL_TIM_OC_Start_IT PROC
;;;644    */
;;;645    HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000332  b530              PUSH     {r4,r5,lr}
;;;646    {
000334  4604              MOV      r4,r0
000336  460d              MOV      r5,r1
;;;647      /* Check the parameters */
;;;648      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;649    
;;;650      switch (Channel)
000338  b135              CBZ      r5,|L1.840|
00033a  2d04              CMP      r5,#4
00033c  d00b              BEQ      |L1.854|
00033e  2d08              CMP      r5,#8
000340  d010              BEQ      |L1.868|
000342  2d0c              CMP      r5,#0xc
000344  d11c              BNE      |L1.896|
000346  e014              B        |L1.882|
                  |L1.840|
;;;651      {
;;;652        case TIM_CHANNEL_1:
;;;653        {
;;;654          /* Enable the TIM Capture/Compare 1 interrupt */
;;;655          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000348  6820              LDR      r0,[r4,#0]
00034a  68c0              LDR      r0,[r0,#0xc]
00034c  f0400002          ORR      r0,r0,#2
000350  6821              LDR      r1,[r4,#0]
000352  60c8              STR      r0,[r1,#0xc]
;;;656        }
;;;657        break;
000354  e015              B        |L1.898|
                  |L1.854|
;;;658    
;;;659        case TIM_CHANNEL_2:
;;;660        {
;;;661          /* Enable the TIM Capture/Compare 2 interrupt */
;;;662          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000356  6820              LDR      r0,[r4,#0]
000358  68c0              LDR      r0,[r0,#0xc]
00035a  f0400004          ORR      r0,r0,#4
00035e  6821              LDR      r1,[r4,#0]
000360  60c8              STR      r0,[r1,#0xc]
;;;663        }
;;;664        break;
000362  e00e              B        |L1.898|
                  |L1.868|
;;;665    
;;;666        case TIM_CHANNEL_3:
;;;667        {
;;;668          /* Enable the TIM Capture/Compare 3 interrupt */
;;;669          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000364  6820              LDR      r0,[r4,#0]
000366  68c0              LDR      r0,[r0,#0xc]
000368  f0400008          ORR      r0,r0,#8
00036c  6821              LDR      r1,[r4,#0]
00036e  60c8              STR      r0,[r1,#0xc]
;;;670        }
;;;671        break;
000370  e007              B        |L1.898|
                  |L1.882|
;;;672    
;;;673        case TIM_CHANNEL_4:
;;;674        {
;;;675          /* Enable the TIM Capture/Compare 4 interrupt */
;;;676          __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000372  6820              LDR      r0,[r4,#0]
000374  68c0              LDR      r0,[r0,#0xc]
000376  f0400010          ORR      r0,r0,#0x10
00037a  6821              LDR      r1,[r4,#0]
00037c  60c8              STR      r0,[r1,#0xc]
;;;677        }
;;;678        break;
00037e  e000              B        |L1.898|
                  |L1.896|
;;;679    
;;;680        default:
;;;681        break;
000380  bf00              NOP      
                  |L1.898|
000382  bf00              NOP                            ;657
;;;682      }
;;;683    
;;;684      /* Enable the Output compare channel */
;;;685      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000384  2201              MOVS     r2,#1
000386  4629              MOV      r1,r5
000388  6820              LDR      r0,[r4,#0]
00038a  f7fffffe          BL       TIM_CCxChannelCmd
;;;686    
;;;687      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;688      {
;;;689        /* Enable the main output */
;;;690        __HAL_TIM_MOE_ENABLE(htim);
;;;691      }
;;;692    
;;;693      /* Enable the Peripheral */
;;;694      __HAL_TIM_ENABLE(htim);
00038e  6820              LDR      r0,[r4,#0]
000390  6800              LDR      r0,[r0,#0]
000392  f0400001          ORR      r0,r0,#1
000396  6821              LDR      r1,[r4,#0]
000398  6008              STR      r0,[r1,#0]
;;;695    
;;;696      /* Return function status */
;;;697      return HAL_OK;
00039a  2000              MOVS     r0,#0
;;;698    }
00039c  bd30              POP      {r4,r5,pc}
;;;699    
                          ENDP

                  HAL_TIM_OC_Stop_IT PROC
;;;710    */
;;;711    HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
00039e  b530              PUSH     {r4,r5,lr}
;;;712    {
0003a0  4604              MOV      r4,r0
0003a2  460d              MOV      r5,r1
;;;713      /* Check the parameters */
;;;714      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;715    
;;;716      switch (Channel)
0003a4  b135              CBZ      r5,|L1.948|
0003a6  2d04              CMP      r5,#4
0003a8  d00b              BEQ      |L1.962|
0003aa  2d08              CMP      r5,#8
0003ac  d010              BEQ      |L1.976|
0003ae  2d0c              CMP      r5,#0xc
0003b0  d122              BNE      |L1.1016|
0003b2  e014              B        |L1.990|
                  |L1.948|
;;;717      {
;;;718        case TIM_CHANNEL_1:
;;;719        {
;;;720          /* Disable the TIM Capture/Compare 1 interrupt */
;;;721          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
0003b4  6820              LDR      r0,[r4,#0]
0003b6  68c0              LDR      r0,[r0,#0xc]
0003b8  f0200002          BIC      r0,r0,#2
0003bc  6821              LDR      r1,[r4,#0]
0003be  60c8              STR      r0,[r1,#0xc]
;;;722        }
;;;723        break;
0003c0  e01b              B        |L1.1018|
                  |L1.962|
;;;724    
;;;725        case TIM_CHANNEL_2:
;;;726        {
;;;727          /* Disable the TIM Capture/Compare 2 interrupt */
;;;728          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
0003c2  6820              LDR      r0,[r4,#0]
0003c4  68c0              LDR      r0,[r0,#0xc]
0003c6  f0200004          BIC      r0,r0,#4
0003ca  6821              LDR      r1,[r4,#0]
0003cc  60c8              STR      r0,[r1,#0xc]
;;;729        }
;;;730        break;
0003ce  e014              B        |L1.1018|
                  |L1.976|
;;;731    
;;;732        case TIM_CHANNEL_3:
;;;733        {
;;;734          /* Disable the TIM Capture/Compare 3 interrupt */
;;;735          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
0003d0  6820              LDR      r0,[r4,#0]
0003d2  68c0              LDR      r0,[r0,#0xc]
0003d4  f0200008          BIC      r0,r0,#8
0003d8  6821              LDR      r1,[r4,#0]
0003da  60c8              STR      r0,[r1,#0xc]
;;;736        }
;;;737        break;
0003dc  e00d              B        |L1.1018|
                  |L1.990|
;;;738    
;;;739        case TIM_CHANNEL_4:
;;;740        {
;;;741          /* Disable the TIM Capture/Compare 4 interrupt */
;;;742          __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
0003de  6820              LDR      r0,[r4,#0]
0003e0  68c0              LDR      r0,[r0,#0xc]
0003e2  f0200010          BIC      r0,r0,#0x10
0003e6  6821              LDR      r1,[r4,#0]
0003e8  60c8              STR      r0,[r1,#0xc]
;;;743        }
;;;744        break;
0003ea  e006              B        |L1.1018|
                  |L1.1004|
                          DCD      0x40000400
                  |L1.1008|
                          DCD      0x40000800
                  |L1.1012|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L1.1016|
;;;745    
;;;746        default:
;;;747        break;
0003f8  bf00              NOP      
                  |L1.1018|
0003fa  bf00              NOP                            ;723
;;;748      }
;;;749    
;;;750      /* Disable the Output compare channel */
;;;751      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0003fc  2200              MOVS     r2,#0
0003fe  4629              MOV      r1,r5
000400  6820              LDR      r0,[r4,#0]
000402  f7fffffe          BL       TIM_CCxChannelCmd
;;;752    
;;;753      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;754      {
;;;755        /* Disable the Main Ouput */
;;;756        __HAL_TIM_MOE_DISABLE(htim);
;;;757      }
;;;758    
;;;759      /* Disable the Peripheral */
;;;760      __HAL_TIM_DISABLE(htim);
000406  bf00              NOP      
000408  6820              LDR      r0,[r4,#0]
00040a  6a00              LDR      r0,[r0,#0x20]
00040c  f2411111          MOV      r1,#0x1111
000410  4008              ANDS     r0,r0,r1
000412  b950              CBNZ     r0,|L1.1066|
000414  6820              LDR      r0,[r4,#0]
000416  6a00              LDR      r0,[r0,#0x20]
000418  1089              ASRS     r1,r1,#2
00041a  4008              ANDS     r0,r0,r1
00041c  b928              CBNZ     r0,|L1.1066|
00041e  6820              LDR      r0,[r4,#0]
000420  6800              LDR      r0,[r0,#0]
000422  f0200001          BIC      r0,r0,#1
000426  6821              LDR      r1,[r4,#0]
000428  6008              STR      r0,[r1,#0]
                  |L1.1066|
00042a  bf00              NOP      
;;;761    
;;;762      /* Return function status */
;;;763      return HAL_OK;
00042c  2000              MOVS     r0,#0
;;;764    }
00042e  bd30              POP      {r4,r5,pc}
;;;765    
                          ENDP

                  HAL_TIM_PWM_PulseFinishedCallback PROC
;;;4311     */
;;;4312   __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
000430  4770              BX       lr
;;;4313   {
;;;4314     /* Prevent unused argument(s) compilation warning */
;;;4315     UNUSED(htim);
;;;4316     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4317               the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
;;;4318      */
;;;4319   }
;;;4320   
                          ENDP

                  TIM_DMADelayPulseCplt PROC
;;;4458     */
;;;4459   void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
000432  b570              PUSH     {r4-r6,lr}
;;;4460   {
000434  4605              MOV      r5,r0
;;;4461     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000436  6a6c              LDR      r4,[r5,#0x24]
;;;4462   
;;;4463     htim->State= HAL_TIM_STATE_READY;
000438  2001              MOVS     r0,#1
00043a  f8840039          STRB     r0,[r4,#0x39]
;;;4464   
;;;4465     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
00043e  6a20              LDR      r0,[r4,#0x20]
000440  42a8              CMP      r0,r5
000442  d102              BNE      |L1.1098|
;;;4466     {
;;;4467       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000444  2001              MOVS     r0,#1
000446  7620              STRB     r0,[r4,#0x18]
000448  e010              B        |L1.1132|
                  |L1.1098|
;;;4468     }
;;;4469     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
00044a  6a60              LDR      r0,[r4,#0x24]
00044c  42a8              CMP      r0,r5
00044e  d102              BNE      |L1.1110|
;;;4470     {
;;;4471       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000450  2002              MOVS     r0,#2
000452  7620              STRB     r0,[r4,#0x18]
000454  e00a              B        |L1.1132|
                  |L1.1110|
;;;4472     }
;;;4473     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000456  6aa0              LDR      r0,[r4,#0x28]
000458  42a8              CMP      r0,r5
00045a  d102              BNE      |L1.1122|
;;;4474     {
;;;4475       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
00045c  2004              MOVS     r0,#4
00045e  7620              STRB     r0,[r4,#0x18]
000460  e004              B        |L1.1132|
                  |L1.1122|
;;;4476     }
;;;4477     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000462  6ae0              LDR      r0,[r4,#0x2c]
000464  42a8              CMP      r0,r5
000466  d101              BNE      |L1.1132|
;;;4478     {
;;;4479       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000468  2008              MOVS     r0,#8
00046a  7620              STRB     r0,[r4,#0x18]
                  |L1.1132|
;;;4480     }
;;;4481   
;;;4482     HAL_TIM_PWM_PulseFinishedCallback(htim);
00046c  4620              MOV      r0,r4
00046e  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
;;;4483   
;;;4484     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000472  2000              MOVS     r0,#0
000474  7620              STRB     r0,[r4,#0x18]
;;;4485   }
000476  bd70              POP      {r4-r6,pc}
;;;4486   /**
                          ENDP

                  HAL_TIM_OC_Start_DMA PROC
;;;778    */
;;;779    HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000478  e92d41f0          PUSH     {r4-r8,lr}
;;;780    {
00047c  4604              MOV      r4,r0
00047e  460e              MOV      r6,r1
000480  4615              MOV      r5,r2
000482  461f              MOV      r7,r3
;;;781      /* Check the parameters */
;;;782      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;783    
;;;784      if((htim->State == HAL_TIM_STATE_BUSY))
000484  f8940039          LDRB     r0,[r4,#0x39]
000488  2802              CMP      r0,#2
00048a  d101              BNE      |L1.1168|
                  |L1.1164|
;;;785      {
;;;786         return HAL_BUSY;
;;;787      }
;;;788      else if((htim->State == HAL_TIM_STATE_READY))
;;;789      {
;;;790        if(((uint32_t)pData == 0 ) && (Length > 0))
;;;791        {
;;;792          return HAL_ERROR;
;;;793        }
;;;794        else
;;;795        {
;;;796          htim->State = HAL_TIM_STATE_BUSY;
;;;797        }
;;;798      }
;;;799      switch (Channel)
;;;800      {
;;;801        case TIM_CHANNEL_1:
;;;802        {
;;;803          /* Set the DMA Period elapsed callback */
;;;804          htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;805    
;;;806          /* Set the DMA error callback */
;;;807          htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;808    
;;;809          /* Enable the DMA channel */
;;;810          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;811    
;;;812          /* Enable the TIM Capture/Compare 1 DMA request */
;;;813          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;814        }
;;;815        break;
;;;816    
;;;817        case TIM_CHANNEL_2:
;;;818        {
;;;819          /* Set the DMA Period elapsed callback */
;;;820          htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;821    
;;;822          /* Set the DMA error callback */
;;;823          htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;824    
;;;825          /* Enable the DMA channel */
;;;826          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;827    
;;;828          /* Enable the TIM Capture/Compare 2 DMA request */
;;;829          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;830        }
;;;831        break;
;;;832    
;;;833        case TIM_CHANNEL_3:
;;;834        {
;;;835          /* Set the DMA Period elapsed callback */
;;;836          htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;837    
;;;838          /* Set the DMA error callback */
;;;839          htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;840    
;;;841          /* Enable the DMA channel */
;;;842          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;843    
;;;844          /* Enable the TIM Capture/Compare 3 DMA request */
;;;845          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;846        }
;;;847        break;
;;;848    
;;;849        case TIM_CHANNEL_4:
;;;850        {
;;;851         /* Set the DMA Period elapsed callback */
;;;852          htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;853    
;;;854          /* Set the DMA error callback */
;;;855          htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;856    
;;;857          /* Enable the DMA channel */
;;;858          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;859    
;;;860          /* Enable the TIM Capture/Compare 4 DMA request */
;;;861          __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;862        }
;;;863        break;
;;;864    
;;;865        default:
;;;866        break;
;;;867      }
;;;868    
;;;869      /* Enable the Output compare channel */
;;;870      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;871    
;;;872      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;873      {
;;;874        /* Enable the main output */
;;;875        __HAL_TIM_MOE_ENABLE(htim);
;;;876      }
;;;877    
;;;878      /* Enable the Peripheral */
;;;879      __HAL_TIM_ENABLE(htim);
;;;880    
;;;881      /* Return function status */
;;;882      return HAL_OK;
;;;883    }
00048c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1168|
000490  f8940039          LDRB     r0,[r4,#0x39]         ;788
000494  2801              CMP      r0,#1                 ;788
000496  d106              BNE      |L1.1190|
000498  b915              CBNZ     r5,|L1.1184|
00049a  2f00              CMP      r7,#0                 ;790
00049c  dd00              BLE      |L1.1184|
00049e  e7f5              B        |L1.1164|
                  |L1.1184|
0004a0  2002              MOVS     r0,#2                 ;796
0004a2  f8840039          STRB     r0,[r4,#0x39]         ;796
                  |L1.1190|
0004a6  b136              CBZ      r6,|L1.1206|
0004a8  2e04              CMP      r6,#4                 ;799
0004aa  d01b              BEQ      |L1.1252|
0004ac  2e08              CMP      r6,#8                 ;799
0004ae  d030              BEQ      |L1.1298|
0004b0  2e0c              CMP      r6,#0xc               ;799
0004b2  d15c              BNE      |L1.1390|
0004b4  e044              B        |L1.1344|
                  |L1.1206|
0004b6  f2af0185          ADR      r1,TIM_DMADelayPulseCplt + 1
0004ba  6a20              LDR      r0,[r4,#0x20]         ;804
0004bc  6281              STR      r1,[r0,#0x28]         ;804
0004be  f2af314b          ADR      r1,TIM_DMAError + 1
0004c2  6a20              LDR      r0,[r4,#0x20]         ;807
0004c4  6301              STR      r1,[r0,#0x30]         ;807
0004c6  6821              LDR      r1,[r4,#0]            ;810
0004c8  f1010234          ADD      r2,r1,#0x34           ;810
0004cc  463b              MOV      r3,r7                 ;810
0004ce  4629              MOV      r1,r5                 ;810
0004d0  6a20              LDR      r0,[r4,#0x20]         ;810
0004d2  f7fffffe          BL       HAL_DMA_Start_IT
0004d6  6820              LDR      r0,[r4,#0]            ;813
0004d8  68c0              LDR      r0,[r0,#0xc]          ;813
0004da  f4407000          ORR      r0,r0,#0x200          ;813
0004de  6821              LDR      r1,[r4,#0]            ;813
0004e0  60c8              STR      r0,[r1,#0xc]          ;813
0004e2  e045              B        |L1.1392|
                  |L1.1252|
0004e4  f2af01b5          ADR      r1,TIM_DMADelayPulseCplt + 1
0004e8  6a60              LDR      r0,[r4,#0x24]         ;820
0004ea  6281              STR      r1,[r0,#0x28]         ;820
0004ec  f2af317b          ADR      r1,TIM_DMAError + 1
0004f0  6a60              LDR      r0,[r4,#0x24]         ;823
0004f2  6301              STR      r1,[r0,#0x30]         ;823
0004f4  6821              LDR      r1,[r4,#0]            ;826
0004f6  f1010238          ADD      r2,r1,#0x38           ;826
0004fa  463b              MOV      r3,r7                 ;826
0004fc  4629              MOV      r1,r5                 ;826
0004fe  6a60              LDR      r0,[r4,#0x24]         ;826
000500  f7fffffe          BL       HAL_DMA_Start_IT
000504  6820              LDR      r0,[r4,#0]            ;829
000506  68c0              LDR      r0,[r0,#0xc]          ;829
000508  f4406080          ORR      r0,r0,#0x400          ;829
00050c  6821              LDR      r1,[r4,#0]            ;829
00050e  60c8              STR      r0,[r1,#0xc]          ;829
000510  e02e              B        |L1.1392|
                  |L1.1298|
000512  f2af01e1          ADR      r1,TIM_DMADelayPulseCplt + 1
000516  6aa0              LDR      r0,[r4,#0x28]         ;836
000518  6281              STR      r1,[r0,#0x28]         ;836
00051a  f2af31a7          ADR      r1,TIM_DMAError + 1
00051e  6aa0              LDR      r0,[r4,#0x28]         ;839
000520  6301              STR      r1,[r0,#0x30]         ;839
000522  6821              LDR      r1,[r4,#0]            ;842
000524  f101023c          ADD      r2,r1,#0x3c           ;842
000528  463b              MOV      r3,r7                 ;842
00052a  4629              MOV      r1,r5                 ;842
00052c  6aa0              LDR      r0,[r4,#0x28]         ;842
00052e  f7fffffe          BL       HAL_DMA_Start_IT
000532  6820              LDR      r0,[r4,#0]            ;845
000534  68c0              LDR      r0,[r0,#0xc]          ;845
000536  f4406000          ORR      r0,r0,#0x800          ;845
00053a  6821              LDR      r1,[r4,#0]            ;845
00053c  60c8              STR      r0,[r1,#0xc]          ;845
00053e  e017              B        |L1.1392|
                  |L1.1344|
000540  f2af1111          ADR      r1,TIM_DMADelayPulseCplt + 1
000544  6ae0              LDR      r0,[r4,#0x2c]         ;852
000546  6281              STR      r1,[r0,#0x28]         ;852
000548  f2af31d7          ADR      r1,TIM_DMAError + 1
00054c  6ae0              LDR      r0,[r4,#0x2c]         ;855
00054e  6301              STR      r1,[r0,#0x30]         ;855
000550  6821              LDR      r1,[r4,#0]            ;858
000552  f1010240          ADD      r2,r1,#0x40           ;858
000556  463b              MOV      r3,r7                 ;858
000558  4629              MOV      r1,r5                 ;858
00055a  6ae0              LDR      r0,[r4,#0x2c]         ;858
00055c  f7fffffe          BL       HAL_DMA_Start_IT
000560  6820              LDR      r0,[r4,#0]            ;861
000562  68c0              LDR      r0,[r0,#0xc]          ;861
000564  f4405080          ORR      r0,r0,#0x1000         ;861
000568  6821              LDR      r1,[r4,#0]            ;861
00056a  60c8              STR      r0,[r1,#0xc]          ;861
00056c  e000              B        |L1.1392|
                  |L1.1390|
00056e  bf00              NOP                            ;866
                  |L1.1392|
000570  bf00              NOP                            ;815
000572  2201              MOVS     r2,#1                 ;870
000574  4631              MOV      r1,r6                 ;870
000576  6820              LDR      r0,[r4,#0]            ;870
000578  f7fffffe          BL       TIM_CCxChannelCmd
00057c  6820              LDR      r0,[r4,#0]            ;879
00057e  6800              LDR      r0,[r0,#0]            ;879
000580  f0400001          ORR      r0,r0,#1              ;879
000584  6821              LDR      r1,[r4,#0]            ;879
000586  6008              STR      r0,[r1,#0]            ;879
000588  2000              MOVS     r0,#0                 ;882
00058a  e77f              B        |L1.1164|
;;;884    
                          ENDP

                  HAL_TIM_OC_Stop_DMA PROC
;;;895    */
;;;896    HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
00058c  b530              PUSH     {r4,r5,lr}
;;;897    {
00058e  4604              MOV      r4,r0
000590  460d              MOV      r5,r1
;;;898      /* Check the parameters */
;;;899      assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;900    
;;;901      switch (Channel)
000592  b135              CBZ      r5,|L1.1442|
000594  2d04              CMP      r5,#4
000596  d00b              BEQ      |L1.1456|
000598  2d08              CMP      r5,#8
00059a  d010              BEQ      |L1.1470|
00059c  2d0c              CMP      r5,#0xc
00059e  d11c              BNE      |L1.1498|
0005a0  e014              B        |L1.1484|
                  |L1.1442|
;;;902      {
;;;903        case TIM_CHANNEL_1:
;;;904        {
;;;905          /* Disable the TIM Capture/Compare 1 DMA request */
;;;906          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
0005a2  6820              LDR      r0,[r4,#0]
0005a4  68c0              LDR      r0,[r0,#0xc]
0005a6  f4207000          BIC      r0,r0,#0x200
0005aa  6821              LDR      r1,[r4,#0]
0005ac  60c8              STR      r0,[r1,#0xc]
;;;907        }
;;;908        break;
0005ae  e015              B        |L1.1500|
                  |L1.1456|
;;;909    
;;;910        case TIM_CHANNEL_2:
;;;911        {
;;;912          /* Disable the TIM Capture/Compare 2 DMA request */
;;;913          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
0005b0  6820              LDR      r0,[r4,#0]
0005b2  68c0              LDR      r0,[r0,#0xc]
0005b4  f4206080          BIC      r0,r0,#0x400
0005b8  6821              LDR      r1,[r4,#0]
0005ba  60c8              STR      r0,[r1,#0xc]
;;;914        }
;;;915        break;
0005bc  e00e              B        |L1.1500|
                  |L1.1470|
;;;916    
;;;917        case TIM_CHANNEL_3:
;;;918        {
;;;919          /* Disable the TIM Capture/Compare 3 DMA request */
;;;920          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
0005be  6820              LDR      r0,[r4,#0]
0005c0  68c0              LDR      r0,[r0,#0xc]
0005c2  f4206000          BIC      r0,r0,#0x800
0005c6  6821              LDR      r1,[r4,#0]
0005c8  60c8              STR      r0,[r1,#0xc]
;;;921        }
;;;922        break;
0005ca  e007              B        |L1.1500|
                  |L1.1484|
;;;923    
;;;924        case TIM_CHANNEL_4:
;;;925        {
;;;926          /* Disable the TIM Capture/Compare 4 interrupt */
;;;927          __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
0005cc  6820              LDR      r0,[r4,#0]
0005ce  68c0              LDR      r0,[r0,#0xc]
0005d0  f4205080          BIC      r0,r0,#0x1000
0005d4  6821              LDR      r1,[r4,#0]
0005d6  60c8              STR      r0,[r1,#0xc]
;;;928        }
;;;929        break;
0005d8  e000              B        |L1.1500|
                  |L1.1498|
;;;930    
;;;931        default:
;;;932        break;
0005da  bf00              NOP      
                  |L1.1500|
0005dc  bf00              NOP                            ;908
;;;933      }
;;;934    
;;;935      /* Disable the Output compare channel */
;;;936      TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0005de  2200              MOVS     r2,#0
0005e0  4629              MOV      r1,r5
0005e2  6820              LDR      r0,[r4,#0]
0005e4  f7fffffe          BL       TIM_CCxChannelCmd
;;;937    
;;;938      if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;939      {
;;;940        /* Disable the Main Ouput */
;;;941        __HAL_TIM_MOE_DISABLE(htim);
;;;942      }
;;;943    
;;;944      /* Disable the Peripheral */
;;;945      __HAL_TIM_DISABLE(htim);
0005e8  bf00              NOP      
0005ea  6820              LDR      r0,[r4,#0]
0005ec  6a00              LDR      r0,[r0,#0x20]
0005ee  f2411111          MOV      r1,#0x1111
0005f2  4008              ANDS     r0,r0,r1
0005f4  b950              CBNZ     r0,|L1.1548|
0005f6  6820              LDR      r0,[r4,#0]
0005f8  6a00              LDR      r0,[r0,#0x20]
0005fa  1089              ASRS     r1,r1,#2
0005fc  4008              ANDS     r0,r0,r1
0005fe  b928              CBNZ     r0,|L1.1548|
000600  6820              LDR      r0,[r4,#0]
000602  6800              LDR      r0,[r0,#0]
000604  f0200001          BIC      r0,r0,#1
000608  6821              LDR      r1,[r4,#0]
00060a  6008              STR      r0,[r1,#0]
                  |L1.1548|
00060c  bf00              NOP      
;;;946    
;;;947      /* Change the htim state */
;;;948      htim->State = HAL_TIM_STATE_READY;
00060e  2001              MOVS     r0,#1
000610  f8840039          STRB     r0,[r4,#0x39]
;;;949    
;;;950      /* Return function status */
;;;951      return HAL_OK;
000614  2000              MOVS     r0,#0
;;;952    }
000616  bd30              POP      {r4,r5,pc}
;;;953    
                          ENDP

                  HAL_TIM_PWM_MspInit PROC
;;;1050     */
;;;1051   __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
000618  4770              BX       lr
;;;1052   {
;;;1053     /* Prevent unused argument(s) compilation warning */
;;;1054     UNUSED(htim);
;;;1055     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1056               the HAL_TIM_PWM_MspInit could be implemented in the user file
;;;1057      */
;;;1058   }
;;;1059   
                          ENDP

                  HAL_TIM_PWM_Init PROC
;;;984      */
;;;985    HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
00061a  b510              PUSH     {r4,lr}
;;;986    {
00061c  4604              MOV      r4,r0
;;;987      /* Check the TIM handle allocation */
;;;988      if(htim == NULL)
00061e  b90c              CBNZ     r4,|L1.1572|
;;;989      {
;;;990        return HAL_ERROR;
000620  2001              MOVS     r0,#1
                  |L1.1570|
;;;991      }
;;;992    
;;;993      /* Check the parameters */
;;;994      assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;995      assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;996      assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;997    
;;;998      if(htim->State == HAL_TIM_STATE_RESET)
;;;999      {
;;;1000       /* Allocate lock resource and initialize it */
;;;1001       htim->Lock = HAL_UNLOCKED;
;;;1002       
;;;1003       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1004       HAL_TIM_PWM_MspInit(htim);
;;;1005     }
;;;1006   
;;;1007     /* Set the TIM state */
;;;1008     htim->State= HAL_TIM_STATE_BUSY;
;;;1009   
;;;1010     /* Init the base time for the PWM */
;;;1011     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1012   
;;;1013     /* Initialize the TIM state*/
;;;1014     htim->State= HAL_TIM_STATE_READY;
;;;1015   
;;;1016     return HAL_OK;
;;;1017   }
000622  bd10              POP      {r4,pc}
                  |L1.1572|
000624  f8940039          LDRB     r0,[r4,#0x39]         ;998
000628  b928              CBNZ     r0,|L1.1590|
00062a  2000              MOVS     r0,#0                 ;1001
00062c  f8840038          STRB     r0,[r4,#0x38]         ;1001
000630  4620              MOV      r0,r4                 ;1004
000632  f7fffffe          BL       HAL_TIM_PWM_MspInit
                  |L1.1590|
000636  2002              MOVS     r0,#2                 ;1008
000638  f8840039          STRB     r0,[r4,#0x39]         ;1008
00063c  1d21              ADDS     r1,r4,#4              ;1011
00063e  6820              LDR      r0,[r4,#0]            ;1011
000640  f7fffffe          BL       TIM_Base_SetConfig
000644  2001              MOVS     r0,#1                 ;1014
000646  f8840039          STRB     r0,[r4,#0x39]         ;1014
00064a  2000              MOVS     r0,#0                 ;1016
00064c  e7e9              B        |L1.1570|
;;;1018   
                          ENDP

                  HAL_TIM_PWM_MspDeInit PROC
;;;1064     */
;;;1065   __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
00064e  4770              BX       lr
;;;1066   {
;;;1067     /* Prevent unused argument(s) compilation warning */
;;;1068     UNUSED(htim);
;;;1069     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1070               the HAL_TIM_PWM_MspDeInit could be implemented in the user file
;;;1071      */
;;;1072   }
;;;1073   
                          ENDP

                  HAL_TIM_PWM_DeInit PROC
;;;1023     */
;;;1024   HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
000650  b510              PUSH     {r4,lr}
;;;1025   {
000652  4604              MOV      r4,r0
;;;1026     /* Check the parameters */
;;;1027     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1028   
;;;1029     htim->State = HAL_TIM_STATE_BUSY;
000654  2002              MOVS     r0,#2
000656  f8840039          STRB     r0,[r4,#0x39]
;;;1030   
;;;1031     /* Disable the TIM Peripheral Clock */
;;;1032     __HAL_TIM_DISABLE(htim);
00065a  bf00              NOP      
00065c  6820              LDR      r0,[r4,#0]
00065e  6a00              LDR      r0,[r0,#0x20]
000660  f2411111          MOV      r1,#0x1111
000664  4008              ANDS     r0,r0,r1
000666  b950              CBNZ     r0,|L1.1662|
000668  6820              LDR      r0,[r4,#0]
00066a  6a00              LDR      r0,[r0,#0x20]
00066c  1089              ASRS     r1,r1,#2
00066e  4008              ANDS     r0,r0,r1
000670  b928              CBNZ     r0,|L1.1662|
000672  6820              LDR      r0,[r4,#0]
000674  6800              LDR      r0,[r0,#0]
000676  f0200001          BIC      r0,r0,#1
00067a  6821              LDR      r1,[r4,#0]
00067c  6008              STR      r0,[r1,#0]
                  |L1.1662|
00067e  bf00              NOP      
;;;1033   
;;;1034     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1035     HAL_TIM_PWM_MspDeInit(htim);
000680  4620              MOV      r0,r4
000682  f7fffffe          BL       HAL_TIM_PWM_MspDeInit
;;;1036   
;;;1037     /* Change TIM state */
;;;1038     htim->State = HAL_TIM_STATE_RESET;
000686  2000              MOVS     r0,#0
000688  f8840039          STRB     r0,[r4,#0x39]
;;;1039   
;;;1040     /* Release Lock */
;;;1041     __HAL_UNLOCK(htim);
00068c  bf00              NOP      
00068e  f8840038          STRB     r0,[r4,#0x38]
000692  bf00              NOP      
;;;1042   
;;;1043     return HAL_OK;
;;;1044   }
000694  bd10              POP      {r4,pc}
;;;1045   
                          ENDP

                  HAL_TIM_PWM_Start PROC
;;;1084   */
;;;1085   HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000696  b530              PUSH     {r4,r5,lr}
;;;1086   {
000698  4604              MOV      r4,r0
00069a  460d              MOV      r5,r1
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1089   
;;;1090     /* Enable the Capture compare channel */
;;;1091     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
00069c  2201              MOVS     r2,#1
00069e  4629              MOV      r1,r5
0006a0  6820              LDR      r0,[r4,#0]
0006a2  f7fffffe          BL       TIM_CCxChannelCmd
;;;1092   
;;;1093     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1094     {
;;;1095       /* Enable the main output */
;;;1096       __HAL_TIM_MOE_ENABLE(htim);
;;;1097     }
;;;1098   
;;;1099     /* Enable the Peripheral */
;;;1100     __HAL_TIM_ENABLE(htim);
0006a6  6820              LDR      r0,[r4,#0]
0006a8  6800              LDR      r0,[r0,#0]
0006aa  f0400001          ORR      r0,r0,#1
0006ae  6821              LDR      r1,[r4,#0]
0006b0  6008              STR      r0,[r1,#0]
;;;1101   
;;;1102     /* Return function status */
;;;1103     return HAL_OK;
0006b2  2000              MOVS     r0,#0
;;;1104   }
0006b4  bd30              POP      {r4,r5,pc}
;;;1105   
                          ENDP

                  HAL_TIM_PWM_Stop PROC
;;;1116   */
;;;1117   HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
0006b6  b530              PUSH     {r4,r5,lr}
;;;1118   {
0006b8  4604              MOV      r4,r0
0006ba  460d              MOV      r5,r1
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1121   
;;;1122     /* Disable the Capture compare channel */
;;;1123     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0006bc  2200              MOVS     r2,#0
0006be  4629              MOV      r1,r5
0006c0  6820              LDR      r0,[r4,#0]
0006c2  f7fffffe          BL       TIM_CCxChannelCmd
;;;1124   
;;;1125     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1126     {
;;;1127       /* Disable the Main Ouput */
;;;1128       __HAL_TIM_MOE_DISABLE(htim);
;;;1129     }
;;;1130   
;;;1131     /* Disable the Peripheral */
;;;1132     __HAL_TIM_DISABLE(htim);
0006c6  bf00              NOP      
0006c8  6820              LDR      r0,[r4,#0]
0006ca  6a00              LDR      r0,[r0,#0x20]
0006cc  f2411111          MOV      r1,#0x1111
0006d0  4008              ANDS     r0,r0,r1
0006d2  b950              CBNZ     r0,|L1.1770|
0006d4  6820              LDR      r0,[r4,#0]
0006d6  6a00              LDR      r0,[r0,#0x20]
0006d8  1089              ASRS     r1,r1,#2
0006da  4008              ANDS     r0,r0,r1
0006dc  b928              CBNZ     r0,|L1.1770|
0006de  6820              LDR      r0,[r4,#0]
0006e0  6800              LDR      r0,[r0,#0]
0006e2  f0200001          BIC      r0,r0,#1
0006e6  6821              LDR      r1,[r4,#0]
0006e8  6008              STR      r0,[r1,#0]
                  |L1.1770|
0006ea  bf00              NOP      
;;;1133   
;;;1134     /* Change the htim state */
;;;1135     htim->State = HAL_TIM_STATE_READY;
0006ec  2001              MOVS     r0,#1
0006ee  f8840039          STRB     r0,[r4,#0x39]
;;;1136   
;;;1137     /* Return function status */
;;;1138     return HAL_OK;
0006f2  2000              MOVS     r0,#0
;;;1139   }
0006f4  bd30              POP      {r4,r5,pc}
;;;1140   
                          ENDP

                  HAL_TIM_PWM_Start_IT PROC
;;;1151   */
;;;1152   HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
0006f6  b530              PUSH     {r4,r5,lr}
;;;1153   {
0006f8  4604              MOV      r4,r0
0006fa  460d              MOV      r5,r1
;;;1154     /* Check the parameters */
;;;1155     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1156   
;;;1157     switch (Channel)
0006fc  b135              CBZ      r5,|L1.1804|
0006fe  2d04              CMP      r5,#4
000700  d00b              BEQ      |L1.1818|
000702  2d08              CMP      r5,#8
000704  d010              BEQ      |L1.1832|
000706  2d0c              CMP      r5,#0xc
000708  d11c              BNE      |L1.1860|
00070a  e014              B        |L1.1846|
                  |L1.1804|
;;;1158     {
;;;1159       case TIM_CHANNEL_1:
;;;1160       {
;;;1161         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1162         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
00070c  6820              LDR      r0,[r4,#0]
00070e  68c0              LDR      r0,[r0,#0xc]
000710  f0400002          ORR      r0,r0,#2
000714  6821              LDR      r1,[r4,#0]
000716  60c8              STR      r0,[r1,#0xc]
;;;1163       }
;;;1164       break;
000718  e015              B        |L1.1862|
                  |L1.1818|
;;;1165   
;;;1166       case TIM_CHANNEL_2:
;;;1167       {
;;;1168         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1169         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
00071a  6820              LDR      r0,[r4,#0]
00071c  68c0              LDR      r0,[r0,#0xc]
00071e  f0400004          ORR      r0,r0,#4
000722  6821              LDR      r1,[r4,#0]
000724  60c8              STR      r0,[r1,#0xc]
;;;1170       }
;;;1171       break;
000726  e00e              B        |L1.1862|
                  |L1.1832|
;;;1172   
;;;1173       case TIM_CHANNEL_3:
;;;1174       {
;;;1175         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1176         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000728  6820              LDR      r0,[r4,#0]
00072a  68c0              LDR      r0,[r0,#0xc]
00072c  f0400008          ORR      r0,r0,#8
000730  6821              LDR      r1,[r4,#0]
000732  60c8              STR      r0,[r1,#0xc]
;;;1177       }
;;;1178       break;
000734  e007              B        |L1.1862|
                  |L1.1846|
;;;1179   
;;;1180       case TIM_CHANNEL_4:
;;;1181       {
;;;1182         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1183         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000736  6820              LDR      r0,[r4,#0]
000738  68c0              LDR      r0,[r0,#0xc]
00073a  f0400010          ORR      r0,r0,#0x10
00073e  6821              LDR      r1,[r4,#0]
000740  60c8              STR      r0,[r1,#0xc]
;;;1184       }
;;;1185       break;
000742  e000              B        |L1.1862|
                  |L1.1860|
;;;1186   
;;;1187       default:
;;;1188       break;
000744  bf00              NOP      
                  |L1.1862|
000746  bf00              NOP                            ;1164
;;;1189     }
;;;1190   
;;;1191     /* Enable the Capture compare channel */
;;;1192     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000748  2201              MOVS     r2,#1
00074a  4629              MOV      r1,r5
00074c  6820              LDR      r0,[r4,#0]
00074e  f7fffffe          BL       TIM_CCxChannelCmd
;;;1193   
;;;1194     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1195     {
;;;1196       /* Enable the main output */
;;;1197       __HAL_TIM_MOE_ENABLE(htim);
;;;1198     }
;;;1199   
;;;1200     /* Enable the Peripheral */
;;;1201     __HAL_TIM_ENABLE(htim);
000752  6820              LDR      r0,[r4,#0]
000754  6800              LDR      r0,[r0,#0]
000756  f0400001          ORR      r0,r0,#1
00075a  6821              LDR      r1,[r4,#0]
00075c  6008              STR      r0,[r1,#0]
;;;1202   
;;;1203     /* Return function status */
;;;1204     return HAL_OK;
00075e  2000              MOVS     r0,#0
;;;1205   }
000760  bd30              POP      {r4,r5,pc}
;;;1206   
                          ENDP

                  HAL_TIM_PWM_Stop_IT PROC
;;;1217   */
;;;1218   HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000762  b530              PUSH     {r4,r5,lr}
;;;1219   {
000764  4604              MOV      r4,r0
000766  460d              MOV      r5,r1
;;;1220     /* Check the parameters */
;;;1221     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1222   
;;;1223     switch (Channel)
000768  b135              CBZ      r5,|L1.1912|
00076a  2d04              CMP      r5,#4
00076c  d00b              BEQ      |L1.1926|
00076e  2d08              CMP      r5,#8
000770  d010              BEQ      |L1.1940|
000772  2d0c              CMP      r5,#0xc
000774  d11c              BNE      |L1.1968|
000776  e014              B        |L1.1954|
                  |L1.1912|
;;;1224     {
;;;1225       case TIM_CHANNEL_1:
;;;1226       {
;;;1227         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1228         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000778  6820              LDR      r0,[r4,#0]
00077a  68c0              LDR      r0,[r0,#0xc]
00077c  f0200002          BIC      r0,r0,#2
000780  6821              LDR      r1,[r4,#0]
000782  60c8              STR      r0,[r1,#0xc]
;;;1229       }
;;;1230       break;
000784  e015              B        |L1.1970|
                  |L1.1926|
;;;1231   
;;;1232       case TIM_CHANNEL_2:
;;;1233       {
;;;1234         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1235         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000786  6820              LDR      r0,[r4,#0]
000788  68c0              LDR      r0,[r0,#0xc]
00078a  f0200004          BIC      r0,r0,#4
00078e  6821              LDR      r1,[r4,#0]
000790  60c8              STR      r0,[r1,#0xc]
;;;1236       }
;;;1237       break;
000792  e00e              B        |L1.1970|
                  |L1.1940|
;;;1238   
;;;1239       case TIM_CHANNEL_3:
;;;1240       {
;;;1241         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1242         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000794  6820              LDR      r0,[r4,#0]
000796  68c0              LDR      r0,[r0,#0xc]
000798  f0200008          BIC      r0,r0,#8
00079c  6821              LDR      r1,[r4,#0]
00079e  60c8              STR      r0,[r1,#0xc]
;;;1243       }
;;;1244       break;
0007a0  e007              B        |L1.1970|
                  |L1.1954|
;;;1245   
;;;1246       case TIM_CHANNEL_4:
;;;1247       {
;;;1248         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1249         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
0007a2  6820              LDR      r0,[r4,#0]
0007a4  68c0              LDR      r0,[r0,#0xc]
0007a6  f0200010          BIC      r0,r0,#0x10
0007aa  6821              LDR      r1,[r4,#0]
0007ac  60c8              STR      r0,[r1,#0xc]
;;;1250       }
;;;1251       break;
0007ae  e000              B        |L1.1970|
                  |L1.1968|
;;;1252   
;;;1253       default:
;;;1254       break;
0007b0  bf00              NOP      
                  |L1.1970|
0007b2  bf00              NOP                            ;1230
;;;1255     }
;;;1256   
;;;1257     /* Disable the Capture compare channel */
;;;1258     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
0007b4  2200              MOVS     r2,#0
0007b6  4629              MOV      r1,r5
0007b8  6820              LDR      r0,[r4,#0]
0007ba  f7fffffe          BL       TIM_CCxChannelCmd
;;;1259   
;;;1260     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1261     {
;;;1262       /* Disable the Main Ouput */
;;;1263       __HAL_TIM_MOE_DISABLE(htim);
;;;1264     }
;;;1265   
;;;1266     /* Disable the Peripheral */
;;;1267     __HAL_TIM_DISABLE(htim);
0007be  bf00              NOP      
0007c0  6820              LDR      r0,[r4,#0]
0007c2  6a00              LDR      r0,[r0,#0x20]
0007c4  f2411111          MOV      r1,#0x1111
0007c8  4008              ANDS     r0,r0,r1
0007ca  b950              CBNZ     r0,|L1.2018|
0007cc  6820              LDR      r0,[r4,#0]
0007ce  6a00              LDR      r0,[r0,#0x20]
0007d0  1089              ASRS     r1,r1,#2
0007d2  4008              ANDS     r0,r0,r1
0007d4  b928              CBNZ     r0,|L1.2018|
0007d6  6820              LDR      r0,[r4,#0]
0007d8  6800              LDR      r0,[r0,#0]
0007da  f0200001          BIC      r0,r0,#1
0007de  6821              LDR      r1,[r4,#0]
0007e0  6008              STR      r0,[r1,#0]
                  |L1.2018|
0007e2  bf00              NOP      
;;;1268   
;;;1269     /* Return function status */
;;;1270     return HAL_OK;
0007e4  2000              MOVS     r0,#0
;;;1271   }
0007e6  bd30              POP      {r4,r5,pc}
;;;1272   
                          ENDP

                  HAL_TIM_PWM_Start_DMA PROC
;;;1285   */
;;;1286   HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
0007e8  e92d41f0          PUSH     {r4-r8,lr}
;;;1287   {
0007ec  4604              MOV      r4,r0
0007ee  460e              MOV      r6,r1
0007f0  4615              MOV      r5,r2
0007f2  461f              MOV      r7,r3
;;;1288     /* Check the parameters */
;;;1289     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1290   
;;;1291     if((htim->State == HAL_TIM_STATE_BUSY))
0007f4  f8940039          LDRB     r0,[r4,#0x39]
0007f8  2802              CMP      r0,#2
0007fa  d101              BNE      |L1.2048|
                  |L1.2044|
;;;1292     {
;;;1293        return HAL_BUSY;
;;;1294     }
;;;1295     else if((htim->State == HAL_TIM_STATE_READY))
;;;1296     {
;;;1297       if(((uint32_t)pData == 0 ) && (Length > 0))
;;;1298       {
;;;1299         return HAL_ERROR;
;;;1300       }
;;;1301       else
;;;1302       {
;;;1303         htim->State = HAL_TIM_STATE_BUSY;
;;;1304       }
;;;1305     }
;;;1306     switch (Channel)
;;;1307     {
;;;1308       case TIM_CHANNEL_1:
;;;1309       {
;;;1310         /* Set the DMA Period elapsed callback */
;;;1311         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1312   
;;;1313         /* Set the DMA error callback */
;;;1314         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1315   
;;;1316         /* Enable the DMA channel */
;;;1317         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
;;;1318   
;;;1319         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1320         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1321       }
;;;1322       break;
;;;1323   
;;;1324       case TIM_CHANNEL_2:
;;;1325       {
;;;1326         /* Set the DMA Period elapsed callback */
;;;1327         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1328   
;;;1329         /* Set the DMA error callback */
;;;1330         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1331   
;;;1332         /* Enable the DMA channel */
;;;1333         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
;;;1334   
;;;1335         /* Enable the TIM Capture/Compare 2 DMA request */
;;;1336         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1337       }
;;;1338       break;
;;;1339   
;;;1340       case TIM_CHANNEL_3:
;;;1341       {
;;;1342         /* Set the DMA Period elapsed callback */
;;;1343         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1344   
;;;1345         /* Set the DMA error callback */
;;;1346         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1347   
;;;1348         /* Enable the DMA channel */
;;;1349         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
;;;1350   
;;;1351         /* Enable the TIM Output Capture/Compare 3 request */
;;;1352         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1353       }
;;;1354       break;
;;;1355   
;;;1356       case TIM_CHANNEL_4:
;;;1357       {
;;;1358        /* Set the DMA Period elapsed callback */
;;;1359         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
;;;1360   
;;;1361         /* Set the DMA error callback */
;;;1362         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1363   
;;;1364         /* Enable the DMA channel */
;;;1365         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
;;;1366   
;;;1367         /* Enable the TIM Capture/Compare 4 DMA request */
;;;1368         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1369       }
;;;1370       break;
;;;1371   
;;;1372       default:
;;;1373       break;
;;;1374     }
;;;1375   
;;;1376     /* Enable the Capture compare channel */
;;;1377     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1378   
;;;1379     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1380     {
;;;1381       /* Enable the main output */
;;;1382       __HAL_TIM_MOE_ENABLE(htim);
;;;1383     }
;;;1384   
;;;1385     /* Enable the Peripheral */
;;;1386     __HAL_TIM_ENABLE(htim);
;;;1387   
;;;1388     /* Return function status */
;;;1389     return HAL_OK;
;;;1390   }
0007fc  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2048|
000800  f8940039          LDRB     r0,[r4,#0x39]         ;1295
000804  2801              CMP      r0,#1                 ;1295
000806  d106              BNE      |L1.2070|
000808  b915              CBNZ     r5,|L1.2064|
00080a  2f00              CMP      r7,#0                 ;1297
00080c  dd00              BLE      |L1.2064|
00080e  e7f5              B        |L1.2044|
                  |L1.2064|
000810  2002              MOVS     r0,#2                 ;1303
000812  f8840039          STRB     r0,[r4,#0x39]         ;1303
                  |L1.2070|
000816  b136              CBZ      r6,|L1.2086|
000818  2e04              CMP      r6,#4                 ;1306
00081a  d01b              BEQ      |L1.2132|
00081c  2e08              CMP      r6,#8                 ;1306
00081e  d030              BEQ      |L1.2178|
000820  2e0c              CMP      r6,#0xc               ;1306
000822  d15c              BNE      |L1.2270|
000824  e044              B        |L1.2224|
                  |L1.2086|
000826  f2af31f5          ADR      r1,TIM_DMADelayPulseCplt + 1
00082a  6a20              LDR      r0,[r4,#0x20]         ;1311
00082c  6281              STR      r1,[r0,#0x28]         ;1311
00082e  f2af61bb          ADR      r1,TIM_DMAError + 1
000832  6a20              LDR      r0,[r4,#0x20]         ;1314
000834  6301              STR      r1,[r0,#0x30]         ;1314
000836  6821              LDR      r1,[r4,#0]            ;1317
000838  f1010234          ADD      r2,r1,#0x34           ;1317
00083c  463b              MOV      r3,r7                 ;1317
00083e  4629              MOV      r1,r5                 ;1317
000840  6a20              LDR      r0,[r4,#0x20]         ;1317
000842  f7fffffe          BL       HAL_DMA_Start_IT
000846  6820              LDR      r0,[r4,#0]            ;1320
000848  68c0              LDR      r0,[r0,#0xc]          ;1320
00084a  f4407000          ORR      r0,r0,#0x200          ;1320
00084e  6821              LDR      r1,[r4,#0]            ;1320
000850  60c8              STR      r0,[r1,#0xc]          ;1320
000852  e045              B        |L1.2272|
                  |L1.2132|
000854  f2af4125          ADR      r1,TIM_DMADelayPulseCplt + 1
000858  6a60              LDR      r0,[r4,#0x24]         ;1327
00085a  6281              STR      r1,[r0,#0x28]         ;1327
00085c  f2af61eb          ADR      r1,TIM_DMAError + 1
000860  6a60              LDR      r0,[r4,#0x24]         ;1330
000862  6301              STR      r1,[r0,#0x30]         ;1330
000864  6821              LDR      r1,[r4,#0]            ;1333
000866  f1010238          ADD      r2,r1,#0x38           ;1333
00086a  463b              MOV      r3,r7                 ;1333
00086c  4629              MOV      r1,r5                 ;1333
00086e  6a60              LDR      r0,[r4,#0x24]         ;1333
000870  f7fffffe          BL       HAL_DMA_Start_IT
000874  6820              LDR      r0,[r4,#0]            ;1336
000876  68c0              LDR      r0,[r0,#0xc]          ;1336
000878  f4406080          ORR      r0,r0,#0x400          ;1336
00087c  6821              LDR      r1,[r4,#0]            ;1336
00087e  60c8              STR      r0,[r1,#0xc]          ;1336
000880  e02e              B        |L1.2272|
                  |L1.2178|
000882  f2af4151          ADR      r1,TIM_DMADelayPulseCplt + 1
000886  6aa0              LDR      r0,[r4,#0x28]         ;1343
000888  6281              STR      r1,[r0,#0x28]         ;1343
00088a  f2af7117          ADR      r1,TIM_DMAError + 1
00088e  6aa0              LDR      r0,[r4,#0x28]         ;1346
000890  6301              STR      r1,[r0,#0x30]         ;1346
000892  6821              LDR      r1,[r4,#0]            ;1349
000894  f101023c          ADD      r2,r1,#0x3c           ;1349
000898  463b              MOV      r3,r7                 ;1349
00089a  4629              MOV      r1,r5                 ;1349
00089c  6aa0              LDR      r0,[r4,#0x28]         ;1349
00089e  f7fffffe          BL       HAL_DMA_Start_IT
0008a2  6820              LDR      r0,[r4,#0]            ;1352
0008a4  68c0              LDR      r0,[r0,#0xc]          ;1352
0008a6  f4406000          ORR      r0,r0,#0x800          ;1352
0008aa  6821              LDR      r1,[r4,#0]            ;1352
0008ac  60c8              STR      r0,[r1,#0xc]          ;1352
0008ae  e017              B        |L1.2272|
                  |L1.2224|
0008b0  f2af4181          ADR      r1,TIM_DMADelayPulseCplt + 1
0008b4  6ae0              LDR      r0,[r4,#0x2c]         ;1359
0008b6  6281              STR      r1,[r0,#0x28]         ;1359
0008b8  f2af7147          ADR      r1,TIM_DMAError + 1
0008bc  6ae0              LDR      r0,[r4,#0x2c]         ;1362
0008be  6301              STR      r1,[r0,#0x30]         ;1362
0008c0  6821              LDR      r1,[r4,#0]            ;1365
0008c2  f1010240          ADD      r2,r1,#0x40           ;1365
0008c6  463b              MOV      r3,r7                 ;1365
0008c8  4629              MOV      r1,r5                 ;1365
0008ca  6ae0              LDR      r0,[r4,#0x2c]         ;1365
0008cc  f7fffffe          BL       HAL_DMA_Start_IT
0008d0  6820              LDR      r0,[r4,#0]            ;1368
0008d2  68c0              LDR      r0,[r0,#0xc]          ;1368
0008d4  f4405080          ORR      r0,r0,#0x1000         ;1368
0008d8  6821              LDR      r1,[r4,#0]            ;1368
0008da  60c8              STR      r0,[r1,#0xc]          ;1368
0008dc  e000              B        |L1.2272|
                  |L1.2270|
0008de  bf00              NOP                            ;1373
                  |L1.2272|
0008e0  bf00              NOP                            ;1322
0008e2  2201              MOVS     r2,#1                 ;1377
0008e4  4631              MOV      r1,r6                 ;1377
0008e6  6820              LDR      r0,[r4,#0]            ;1377
0008e8  f7fffffe          BL       TIM_CCxChannelCmd
0008ec  6820              LDR      r0,[r4,#0]            ;1386
0008ee  6800              LDR      r0,[r0,#0]            ;1386
0008f0  f0400001          ORR      r0,r0,#1              ;1386
0008f4  6821              LDR      r1,[r4,#0]            ;1386
0008f6  6008              STR      r0,[r1,#0]            ;1386
0008f8  2000              MOVS     r0,#0                 ;1389
0008fa  e77f              B        |L1.2044|
;;;1391   
                          ENDP

                  HAL_TIM_PWM_Stop_DMA PROC
;;;1402   */
;;;1403   HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
0008fc  b530              PUSH     {r4,r5,lr}
;;;1404   {
0008fe  4604              MOV      r4,r0
000900  460d              MOV      r5,r1
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1407   
;;;1408     switch (Channel)
000902  b135              CBZ      r5,|L1.2322|
000904  2d04              CMP      r5,#4
000906  d00b              BEQ      |L1.2336|
000908  2d08              CMP      r5,#8
00090a  d010              BEQ      |L1.2350|
00090c  2d0c              CMP      r5,#0xc
00090e  d11c              BNE      |L1.2378|
000910  e014              B        |L1.2364|
                  |L1.2322|
;;;1409     {
;;;1410       case TIM_CHANNEL_1:
;;;1411       {
;;;1412         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1413         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000912  6820              LDR      r0,[r4,#0]
000914  68c0              LDR      r0,[r0,#0xc]
000916  f4207000          BIC      r0,r0,#0x200
00091a  6821              LDR      r1,[r4,#0]
00091c  60c8              STR      r0,[r1,#0xc]
;;;1414       }
;;;1415       break;
00091e  e015              B        |L1.2380|
                  |L1.2336|
;;;1416   
;;;1417       case TIM_CHANNEL_2:
;;;1418       {
;;;1419         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1420         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000920  6820              LDR      r0,[r4,#0]
000922  68c0              LDR      r0,[r0,#0xc]
000924  f4206080          BIC      r0,r0,#0x400
000928  6821              LDR      r1,[r4,#0]
00092a  60c8              STR      r0,[r1,#0xc]
;;;1421       }
;;;1422       break;
00092c  e00e              B        |L1.2380|
                  |L1.2350|
;;;1423   
;;;1424       case TIM_CHANNEL_3:
;;;1425       {
;;;1426         /* Disable the TIM Capture/Compare 3 DMA request */
;;;1427         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
00092e  6820              LDR      r0,[r4,#0]
000930  68c0              LDR      r0,[r0,#0xc]
000932  f4206000          BIC      r0,r0,#0x800
000936  6821              LDR      r1,[r4,#0]
000938  60c8              STR      r0,[r1,#0xc]
;;;1428       }
;;;1429       break;
00093a  e007              B        |L1.2380|
                  |L1.2364|
;;;1430   
;;;1431       case TIM_CHANNEL_4:
;;;1432       {
;;;1433         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1434         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
00093c  6820              LDR      r0,[r4,#0]
00093e  68c0              LDR      r0,[r0,#0xc]
000940  f4205080          BIC      r0,r0,#0x1000
000944  6821              LDR      r1,[r4,#0]
000946  60c8              STR      r0,[r1,#0xc]
;;;1435       }
;;;1436       break;
000948  e000              B        |L1.2380|
                  |L1.2378|
;;;1437   
;;;1438       default:
;;;1439       break;
00094a  bf00              NOP      
                  |L1.2380|
00094c  bf00              NOP                            ;1415
;;;1440     }
;;;1441   
;;;1442     /* Disable the Capture compare channel */
;;;1443     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
00094e  2200              MOVS     r2,#0
000950  4629              MOV      r1,r5
000952  6820              LDR      r0,[r4,#0]
000954  f7fffffe          BL       TIM_CCxChannelCmd
;;;1444   
;;;1445     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;1446     {
;;;1447       /* Disable the Main Ouput */
;;;1448       __HAL_TIM_MOE_DISABLE(htim);
;;;1449     }
;;;1450   
;;;1451     /* Disable the Peripheral */
;;;1452     __HAL_TIM_DISABLE(htim);
000958  bf00              NOP      
00095a  6820              LDR      r0,[r4,#0]
00095c  6a00              LDR      r0,[r0,#0x20]
00095e  f2411111          MOV      r1,#0x1111
000962  4008              ANDS     r0,r0,r1
000964  b950              CBNZ     r0,|L1.2428|
000966  6820              LDR      r0,[r4,#0]
000968  6a00              LDR      r0,[r0,#0x20]
00096a  1089              ASRS     r1,r1,#2
00096c  4008              ANDS     r0,r0,r1
00096e  b928              CBNZ     r0,|L1.2428|
000970  6820              LDR      r0,[r4,#0]
000972  6800              LDR      r0,[r0,#0]
000974  f0200001          BIC      r0,r0,#1
000978  6821              LDR      r1,[r4,#0]
00097a  6008              STR      r0,[r1,#0]
                  |L1.2428|
00097c  bf00              NOP      
;;;1453   
;;;1454     /* Change the htim state */
;;;1455     htim->State = HAL_TIM_STATE_READY;
00097e  2001              MOVS     r0,#1
000980  f8840039          STRB     r0,[r4,#0x39]
;;;1456   
;;;1457     /* Return function status */
;;;1458     return HAL_OK;
000984  2000              MOVS     r0,#0
;;;1459   }
000986  bd30              POP      {r4,r5,pc}
;;;1460   
                          ENDP

                  HAL_TIM_IC_MspInit PROC
;;;1557     */
;;;1558   __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
000988  4770              BX       lr
;;;1559   {
;;;1560     /* Prevent unused argument(s) compilation warning */
;;;1561     UNUSED(htim);
;;;1562     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1563               the HAL_TIM_IC_MspInit could be implemented in the user file
;;;1564      */
;;;1565   }
;;;1566   
                          ENDP

                  HAL_TIM_IC_Init PROC
;;;1491     */
;;;1492   HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
00098a  b510              PUSH     {r4,lr}
;;;1493   {
00098c  4604              MOV      r4,r0
;;;1494     /* Check the TIM handle allocation */
;;;1495     if(htim == NULL)
00098e  b90c              CBNZ     r4,|L1.2452|
;;;1496     {
;;;1497       return HAL_ERROR;
000990  2001              MOVS     r0,#1
                  |L1.2450|
;;;1498     }
;;;1499   
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1502     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1503     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1504   
;;;1505     if(htim->State == HAL_TIM_STATE_RESET)
;;;1506     {
;;;1507       /* Allocate lock resource and initialize it */
;;;1508       htim->Lock = HAL_UNLOCKED;
;;;1509       
;;;1510       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1511       HAL_TIM_IC_MspInit(htim);
;;;1512     }
;;;1513   
;;;1514     /* Set the TIM state */
;;;1515     htim->State= HAL_TIM_STATE_BUSY;
;;;1516   
;;;1517     /* Init the base time for the input capture */
;;;1518     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1519   
;;;1520     /* Initialize the TIM state*/
;;;1521     htim->State= HAL_TIM_STATE_READY;
;;;1522   
;;;1523     return HAL_OK;
;;;1524   }
000992  bd10              POP      {r4,pc}
                  |L1.2452|
000994  f8940039          LDRB     r0,[r4,#0x39]         ;1505
000998  b928              CBNZ     r0,|L1.2470|
00099a  2000              MOVS     r0,#0                 ;1508
00099c  f8840038          STRB     r0,[r4,#0x38]         ;1508
0009a0  4620              MOV      r0,r4                 ;1511
0009a2  f7fffffe          BL       HAL_TIM_IC_MspInit
                  |L1.2470|
0009a6  2002              MOVS     r0,#2                 ;1515
0009a8  f8840039          STRB     r0,[r4,#0x39]         ;1515
0009ac  1d21              ADDS     r1,r4,#4              ;1518
0009ae  6820              LDR      r0,[r4,#0]            ;1518
0009b0  f7fffffe          BL       TIM_Base_SetConfig
0009b4  2001              MOVS     r0,#1                 ;1521
0009b6  f8840039          STRB     r0,[r4,#0x39]         ;1521
0009ba  2000              MOVS     r0,#0                 ;1523
0009bc  e7e9              B        |L1.2450|
;;;1525   
                          ENDP

                  HAL_TIM_IC_MspDeInit PROC
;;;1571     */
;;;1572   __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
0009be  4770              BX       lr
;;;1573   {
;;;1574     /* Prevent unused argument(s) compilation warning */
;;;1575     UNUSED(htim);
;;;1576     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1577               the HAL_TIM_IC_MspDeInit could be implemented in the user file
;;;1578      */
;;;1579   }
;;;1580   
                          ENDP

                  HAL_TIM_IC_DeInit PROC
;;;1530     */
;;;1531   HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
0009c0  b510              PUSH     {r4,lr}
;;;1532   {
0009c2  4604              MOV      r4,r0
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1535   
;;;1536     htim->State = HAL_TIM_STATE_BUSY;
0009c4  2002              MOVS     r0,#2
0009c6  f8840039          STRB     r0,[r4,#0x39]
;;;1537   
;;;1538     /* Disable the TIM Peripheral Clock */
;;;1539     __HAL_TIM_DISABLE(htim);
0009ca  bf00              NOP      
0009cc  6820              LDR      r0,[r4,#0]
0009ce  6a00              LDR      r0,[r0,#0x20]
0009d0  f2411111          MOV      r1,#0x1111
0009d4  4008              ANDS     r0,r0,r1
0009d6  b950              CBNZ     r0,|L1.2542|
0009d8  6820              LDR      r0,[r4,#0]
0009da  6a00              LDR      r0,[r0,#0x20]
0009dc  1089              ASRS     r1,r1,#2
0009de  4008              ANDS     r0,r0,r1
0009e0  b928              CBNZ     r0,|L1.2542|
0009e2  6820              LDR      r0,[r4,#0]
0009e4  6800              LDR      r0,[r0,#0]
0009e6  f0200001          BIC      r0,r0,#1
0009ea  6821              LDR      r1,[r4,#0]
0009ec  6008              STR      r0,[r1,#0]
                  |L1.2542|
0009ee  bf00              NOP      
;;;1540   
;;;1541     /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
;;;1542     HAL_TIM_IC_MspDeInit(htim);
0009f0  4620              MOV      r0,r4
0009f2  f7fffffe          BL       HAL_TIM_IC_MspDeInit
;;;1543   
;;;1544     /* Change TIM state */
;;;1545     htim->State = HAL_TIM_STATE_RESET;
0009f6  2000              MOVS     r0,#0
0009f8  f8840039          STRB     r0,[r4,#0x39]
;;;1546   
;;;1547     /* Release Lock */
;;;1548     __HAL_UNLOCK(htim);
0009fc  bf00              NOP      
0009fe  f8840038          STRB     r0,[r4,#0x38]
000a02  bf00              NOP      
;;;1549   
;;;1550     return HAL_OK;
;;;1551   }
000a04  bd10              POP      {r4,pc}
;;;1552   
                          ENDP

                  HAL_TIM_IC_Start PROC
;;;1591   */
;;;1592   HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
000a06  b530              PUSH     {r4,r5,lr}
;;;1593   {
000a08  4604              MOV      r4,r0
000a0a  460d              MOV      r5,r1
;;;1594     /* Check the parameters */
;;;1595     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1596   
;;;1597     /* Enable the Input Capture channel */
;;;1598     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000a0c  2201              MOVS     r2,#1
000a0e  4629              MOV      r1,r5
000a10  6820              LDR      r0,[r4,#0]
000a12  f7fffffe          BL       TIM_CCxChannelCmd
;;;1599   
;;;1600     /* Enable the Peripheral */
;;;1601     __HAL_TIM_ENABLE(htim);
000a16  6820              LDR      r0,[r4,#0]
000a18  6800              LDR      r0,[r0,#0]
000a1a  f0400001          ORR      r0,r0,#1
000a1e  6821              LDR      r1,[r4,#0]
000a20  6008              STR      r0,[r1,#0]
;;;1602   
;;;1603     /* Return function status */
;;;1604     return HAL_OK;
000a22  2000              MOVS     r0,#0
;;;1605   }
000a24  bd30              POP      {r4,r5,pc}
;;;1606   
                          ENDP

                  HAL_TIM_IC_Stop PROC
;;;1617   */
;;;1618   HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
000a26  b530              PUSH     {r4,r5,lr}
;;;1619   {
000a28  4604              MOV      r4,r0
000a2a  460d              MOV      r5,r1
;;;1620     /* Check the parameters */
;;;1621     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1622   
;;;1623     /* Disable the Input Capture channel */
;;;1624     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000a2c  2200              MOVS     r2,#0
000a2e  4629              MOV      r1,r5
000a30  6820              LDR      r0,[r4,#0]
000a32  f7fffffe          BL       TIM_CCxChannelCmd
;;;1625   
;;;1626     /* Disable the Peripheral */
;;;1627     __HAL_TIM_DISABLE(htim);
000a36  bf00              NOP      
000a38  6820              LDR      r0,[r4,#0]
000a3a  6a00              LDR      r0,[r0,#0x20]
000a3c  f2411111          MOV      r1,#0x1111
000a40  4008              ANDS     r0,r0,r1
000a42  b950              CBNZ     r0,|L1.2650|
000a44  6820              LDR      r0,[r4,#0]
000a46  6a00              LDR      r0,[r0,#0x20]
000a48  1089              ASRS     r1,r1,#2
000a4a  4008              ANDS     r0,r0,r1
000a4c  b928              CBNZ     r0,|L1.2650|
000a4e  6820              LDR      r0,[r4,#0]
000a50  6800              LDR      r0,[r0,#0]
000a52  f0200001          BIC      r0,r0,#1
000a56  6821              LDR      r1,[r4,#0]
000a58  6008              STR      r0,[r1,#0]
                  |L1.2650|
000a5a  bf00              NOP      
;;;1628   
;;;1629     /* Return function status */
;;;1630     return HAL_OK;
000a5c  2000              MOVS     r0,#0
;;;1631   }
000a5e  bd30              POP      {r4,r5,pc}
;;;1632   
                          ENDP

                  HAL_TIM_IC_Start_IT PROC
;;;1643   */
;;;1644   HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
000a60  b530              PUSH     {r4,r5,lr}
;;;1645   {
000a62  4604              MOV      r4,r0
000a64  460d              MOV      r5,r1
;;;1646     /* Check the parameters */
;;;1647     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1648   
;;;1649     switch (Channel)
000a66  b135              CBZ      r5,|L1.2678|
000a68  2d04              CMP      r5,#4
000a6a  d00b              BEQ      |L1.2692|
000a6c  2d08              CMP      r5,#8
000a6e  d010              BEQ      |L1.2706|
000a70  2d0c              CMP      r5,#0xc
000a72  d11c              BNE      |L1.2734|
000a74  e014              B        |L1.2720|
                  |L1.2678|
;;;1650     {
;;;1651       case TIM_CHANNEL_1:
;;;1652       {
;;;1653         /* Enable the TIM Capture/Compare 1 interrupt */
;;;1654         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000a76  6820              LDR      r0,[r4,#0]
000a78  68c0              LDR      r0,[r0,#0xc]
000a7a  f0400002          ORR      r0,r0,#2
000a7e  6821              LDR      r1,[r4,#0]
000a80  60c8              STR      r0,[r1,#0xc]
;;;1655       }
;;;1656       break;
000a82  e015              B        |L1.2736|
                  |L1.2692|
;;;1657   
;;;1658       case TIM_CHANNEL_2:
;;;1659       {
;;;1660         /* Enable the TIM Capture/Compare 2 interrupt */
;;;1661         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000a84  6820              LDR      r0,[r4,#0]
000a86  68c0              LDR      r0,[r0,#0xc]
000a88  f0400004          ORR      r0,r0,#4
000a8c  6821              LDR      r1,[r4,#0]
000a8e  60c8              STR      r0,[r1,#0xc]
;;;1662       }
;;;1663       break;
000a90  e00e              B        |L1.2736|
                  |L1.2706|
;;;1664   
;;;1665       case TIM_CHANNEL_3:
;;;1666       {
;;;1667         /* Enable the TIM Capture/Compare 3 interrupt */
;;;1668         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
000a92  6820              LDR      r0,[r4,#0]
000a94  68c0              LDR      r0,[r0,#0xc]
000a96  f0400008          ORR      r0,r0,#8
000a9a  6821              LDR      r1,[r4,#0]
000a9c  60c8              STR      r0,[r1,#0xc]
;;;1669       }
;;;1670       break;
000a9e  e007              B        |L1.2736|
                  |L1.2720|
;;;1671   
;;;1672       case TIM_CHANNEL_4:
;;;1673       {
;;;1674         /* Enable the TIM Capture/Compare 4 interrupt */
;;;1675         __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
000aa0  6820              LDR      r0,[r4,#0]
000aa2  68c0              LDR      r0,[r0,#0xc]
000aa4  f0400010          ORR      r0,r0,#0x10
000aa8  6821              LDR      r1,[r4,#0]
000aaa  60c8              STR      r0,[r1,#0xc]
;;;1676       }
;;;1677       break;
000aac  e000              B        |L1.2736|
                  |L1.2734|
;;;1678   
;;;1679       default:
;;;1680       break;
000aae  bf00              NOP      
                  |L1.2736|
000ab0  bf00              NOP                            ;1656
;;;1681     }
;;;1682     /* Enable the Input Capture channel */
;;;1683     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
000ab2  2201              MOVS     r2,#1
000ab4  4629              MOV      r1,r5
000ab6  6820              LDR      r0,[r4,#0]
000ab8  f7fffffe          BL       TIM_CCxChannelCmd
;;;1684   
;;;1685     /* Enable the Peripheral */
;;;1686     __HAL_TIM_ENABLE(htim);
000abc  6820              LDR      r0,[r4,#0]
000abe  6800              LDR      r0,[r0,#0]
000ac0  f0400001          ORR      r0,r0,#1
000ac4  6821              LDR      r1,[r4,#0]
000ac6  6008              STR      r0,[r1,#0]
;;;1687   
;;;1688     /* Return function status */
;;;1689     return HAL_OK;
000ac8  2000              MOVS     r0,#0
;;;1690   }
000aca  bd30              POP      {r4,r5,pc}
;;;1691   
                          ENDP

                  HAL_TIM_IC_Stop_IT PROC
;;;1702   */
;;;1703   HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
000acc  b530              PUSH     {r4,r5,lr}
;;;1704   {
000ace  4604              MOV      r4,r0
000ad0  460d              MOV      r5,r1
;;;1705     /* Check the parameters */
;;;1706     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1707   
;;;1708     switch (Channel)
000ad2  b135              CBZ      r5,|L1.2786|
000ad4  2d04              CMP      r5,#4
000ad6  d00b              BEQ      |L1.2800|
000ad8  2d08              CMP      r5,#8
000ada  d010              BEQ      |L1.2814|
000adc  2d0c              CMP      r5,#0xc
000ade  d11c              BNE      |L1.2842|
000ae0  e014              B        |L1.2828|
                  |L1.2786|
;;;1709     {
;;;1710       case TIM_CHANNEL_1:
;;;1711       {
;;;1712         /* Disable the TIM Capture/Compare 1 interrupt */
;;;1713         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000ae2  6820              LDR      r0,[r4,#0]
000ae4  68c0              LDR      r0,[r0,#0xc]
000ae6  f0200002          BIC      r0,r0,#2
000aea  6821              LDR      r1,[r4,#0]
000aec  60c8              STR      r0,[r1,#0xc]
;;;1714       }
;;;1715       break;
000aee  e015              B        |L1.2844|
                  |L1.2800|
;;;1716   
;;;1717       case TIM_CHANNEL_2:
;;;1718       {
;;;1719         /* Disable the TIM Capture/Compare 2 interrupt */
;;;1720         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000af0  6820              LDR      r0,[r4,#0]
000af2  68c0              LDR      r0,[r0,#0xc]
000af4  f0200004          BIC      r0,r0,#4
000af8  6821              LDR      r1,[r4,#0]
000afa  60c8              STR      r0,[r1,#0xc]
;;;1721       }
;;;1722       break;
000afc  e00e              B        |L1.2844|
                  |L1.2814|
;;;1723   
;;;1724       case TIM_CHANNEL_3:
;;;1725       {
;;;1726         /* Disable the TIM Capture/Compare 3 interrupt */
;;;1727         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
000afe  6820              LDR      r0,[r4,#0]
000b00  68c0              LDR      r0,[r0,#0xc]
000b02  f0200008          BIC      r0,r0,#8
000b06  6821              LDR      r1,[r4,#0]
000b08  60c8              STR      r0,[r1,#0xc]
;;;1728       }
;;;1729       break;
000b0a  e007              B        |L1.2844|
                  |L1.2828|
;;;1730   
;;;1731       case TIM_CHANNEL_4:
;;;1732       {
;;;1733         /* Disable the TIM Capture/Compare 4 interrupt */
;;;1734         __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
000b0c  6820              LDR      r0,[r4,#0]
000b0e  68c0              LDR      r0,[r0,#0xc]
000b10  f0200010          BIC      r0,r0,#0x10
000b14  6821              LDR      r1,[r4,#0]
000b16  60c8              STR      r0,[r1,#0xc]
;;;1735       }
;;;1736       break;
000b18  e000              B        |L1.2844|
                  |L1.2842|
;;;1737   
;;;1738       default:
;;;1739       break;
000b1a  bf00              NOP      
                  |L1.2844|
000b1c  bf00              NOP                            ;1715
;;;1740     }
;;;1741   
;;;1742     /* Disable the Input Capture channel */
;;;1743     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000b1e  2200              MOVS     r2,#0
000b20  4629              MOV      r1,r5
000b22  6820              LDR      r0,[r4,#0]
000b24  f7fffffe          BL       TIM_CCxChannelCmd
;;;1744   
;;;1745     /* Disable the Peripheral */
;;;1746     __HAL_TIM_DISABLE(htim);
000b28  bf00              NOP      
000b2a  6820              LDR      r0,[r4,#0]
000b2c  6a00              LDR      r0,[r0,#0x20]
000b2e  f2411111          MOV      r1,#0x1111
000b32  4008              ANDS     r0,r0,r1
000b34  b950              CBNZ     r0,|L1.2892|
000b36  6820              LDR      r0,[r4,#0]
000b38  6a00              LDR      r0,[r0,#0x20]
000b3a  1089              ASRS     r1,r1,#2
000b3c  4008              ANDS     r0,r0,r1
000b3e  b928              CBNZ     r0,|L1.2892|
000b40  6820              LDR      r0,[r4,#0]
000b42  6800              LDR      r0,[r0,#0]
000b44  f0200001          BIC      r0,r0,#1
000b48  6821              LDR      r1,[r4,#0]
000b4a  6008              STR      r0,[r1,#0]
                  |L1.2892|
000b4c  bf00              NOP      
;;;1747   
;;;1748     /* Return function status */
;;;1749     return HAL_OK;
000b4e  2000              MOVS     r0,#0
;;;1750   }
000b50  bd30              POP      {r4,r5,pc}
;;;1751   
                          ENDP

                  HAL_TIM_IC_CaptureCallback PROC
;;;4297     */
;;;4298   __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
000b52  4770              BX       lr
;;;4299   {
;;;4300     /* Prevent unused argument(s) compilation warning */
;;;4301     UNUSED(htim);
;;;4302     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4303               the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
;;;4304      */
;;;4305   }
;;;4306   
                          ENDP

                  TIM_DMACaptureCplt PROC
;;;4490     */
;;;4491   void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
000b54  b570              PUSH     {r4-r6,lr}
;;;4492   {
000b56  4605              MOV      r5,r0
;;;4493     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000b58  6a6c              LDR      r4,[r5,#0x24]
;;;4494   
;;;4495     htim->State= HAL_TIM_STATE_READY;
000b5a  2001              MOVS     r0,#1
000b5c  f8840039          STRB     r0,[r4,#0x39]
;;;4496   
;;;4497     if (hdma == htim->hdma[TIM_DMA_ID_CC1])
000b60  6a20              LDR      r0,[r4,#0x20]
000b62  42a8              CMP      r0,r5
000b64  d102              BNE      |L1.2924|
;;;4498     {
;;;4499       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
000b66  2001              MOVS     r0,#1
000b68  7620              STRB     r0,[r4,#0x18]
000b6a  e010              B        |L1.2958|
                  |L1.2924|
;;;4500     }
;;;4501     else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
000b6c  6a60              LDR      r0,[r4,#0x24]
000b6e  42a8              CMP      r0,r5
000b70  d102              BNE      |L1.2936|
;;;4502     {
;;;4503       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
000b72  2002              MOVS     r0,#2
000b74  7620              STRB     r0,[r4,#0x18]
000b76  e00a              B        |L1.2958|
                  |L1.2936|
;;;4504     }
;;;4505     else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
000b78  6aa0              LDR      r0,[r4,#0x28]
000b7a  42a8              CMP      r0,r5
000b7c  d102              BNE      |L1.2948|
;;;4506     {
;;;4507       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
000b7e  2004              MOVS     r0,#4
000b80  7620              STRB     r0,[r4,#0x18]
000b82  e004              B        |L1.2958|
                  |L1.2948|
;;;4508     }
;;;4509     else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
000b84  6ae0              LDR      r0,[r4,#0x2c]
000b86  42a8              CMP      r0,r5
000b88  d101              BNE      |L1.2958|
;;;4510     {
;;;4511       htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
000b8a  2008              MOVS     r0,#8
000b8c  7620              STRB     r0,[r4,#0x18]
                  |L1.2958|
;;;4512     }
;;;4513   
;;;4514     HAL_TIM_IC_CaptureCallback(htim);
000b8e  4620              MOV      r0,r4
000b90  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
;;;4515   
;;;4516     htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
000b94  2000              MOVS     r0,#0
000b96  7620              STRB     r0,[r4,#0x18]
;;;4517   }
000b98  bd70              POP      {r4-r6,pc}
;;;4518   
                          ENDP

                  HAL_TIM_IC_Start_DMA PROC
;;;1764   */
;;;1765   HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
000b9a  e92d41f0          PUSH     {r4-r8,lr}
;;;1766   {
000b9e  4604              MOV      r4,r0
000ba0  460d              MOV      r5,r1
000ba2  4616              MOV      r6,r2
000ba4  461f              MOV      r7,r3
;;;1767     /* Check the parameters */
;;;1768     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1769     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1770   
;;;1771     if((htim->State == HAL_TIM_STATE_BUSY))
000ba6  f8940039          LDRB     r0,[r4,#0x39]
000baa  2802              CMP      r0,#2
000bac  d101              BNE      |L1.2994|
                  |L1.2990|
;;;1772     {
;;;1773        return HAL_BUSY;
;;;1774     }
;;;1775     else if((htim->State == HAL_TIM_STATE_READY))
;;;1776     {
;;;1777       if((pData == 0 ) && (Length > 0))
;;;1778       {
;;;1779         return HAL_ERROR;
;;;1780       }
;;;1781       else
;;;1782       {
;;;1783         htim->State = HAL_TIM_STATE_BUSY;
;;;1784       }
;;;1785     }
;;;1786   
;;;1787     switch (Channel)
;;;1788     {
;;;1789       case TIM_CHANNEL_1:
;;;1790       {
;;;1791         /* Set the DMA Period elapsed callback */
;;;1792         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1793   
;;;1794         /* Set the DMA error callback */
;;;1795         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;1796   
;;;1797         /* Enable the DMA channel */
;;;1798         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
;;;1799   
;;;1800         /* Enable the TIM Capture/Compare 1 DMA request */
;;;1801         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;1802       }
;;;1803       break;
;;;1804   
;;;1805       case TIM_CHANNEL_2:
;;;1806       {
;;;1807         /* Set the DMA Period elapsed callback */
;;;1808         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1809   
;;;1810         /* Set the DMA error callback */
;;;1811         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;1812   
;;;1813         /* Enable the DMA channel */
;;;1814         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
;;;1815   
;;;1816         /* Enable the TIM Capture/Compare 2  DMA request */
;;;1817         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;1818       }
;;;1819       break;
;;;1820   
;;;1821       case TIM_CHANNEL_3:
;;;1822       {
;;;1823         /* Set the DMA Period elapsed callback */
;;;1824         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1825   
;;;1826         /* Set the DMA error callback */
;;;1827         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;1828   
;;;1829         /* Enable the DMA channel */
;;;1830         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
;;;1831   
;;;1832         /* Enable the TIM Capture/Compare 3  DMA request */
;;;1833         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
;;;1834       }
;;;1835       break;
;;;1836   
;;;1837       case TIM_CHANNEL_4:
;;;1838       {
;;;1839         /* Set the DMA Period elapsed callback */
;;;1840         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
;;;1841   
;;;1842         /* Set the DMA error callback */
;;;1843         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;1844   
;;;1845         /* Enable the DMA channel */
;;;1846         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
;;;1847   
;;;1848         /* Enable the TIM Capture/Compare 4  DMA request */
;;;1849         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
;;;1850       }
;;;1851       break;
;;;1852   
;;;1853       default:
;;;1854       break;
;;;1855     }
;;;1856   
;;;1857     /* Enable the Input Capture channel */
;;;1858     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
;;;1859   
;;;1860     /* Enable the Peripheral */
;;;1861     __HAL_TIM_ENABLE(htim);
;;;1862   
;;;1863     /* Return function status */
;;;1864     return HAL_OK;
;;;1865   }
000bae  e8bd81f0          POP      {r4-r8,pc}
                  |L1.2994|
000bb2  f8940039          LDRB     r0,[r4,#0x39]         ;1775
000bb6  2801              CMP      r0,#1                 ;1775
000bb8  d106              BNE      |L1.3016|
000bba  b916              CBNZ     r6,|L1.3010|
000bbc  2f00              CMP      r7,#0                 ;1777
000bbe  dd00              BLE      |L1.3010|
000bc0  e7f5              B        |L1.2990|
                  |L1.3010|
000bc2  2002              MOVS     r0,#2                 ;1783
000bc4  f8840039          STRB     r0,[r4,#0x39]         ;1783
                  |L1.3016|
000bc8  b135              CBZ      r5,|L1.3032|
000bca  2d04              CMP      r5,#4                 ;1787
000bcc  d01b              BEQ      |L1.3078|
000bce  2d08              CMP      r5,#8                 ;1787
000bd0  d030              BEQ      |L1.3124|
000bd2  2d0c              CMP      r5,#0xc               ;1787
000bd4  d15c              BNE      |L1.3216|
000bd6  e044              B        |L1.3170|
                  |L1.3032|
000bd8  f2af0187          ADR      r1,TIM_DMACaptureCplt + 1
000bdc  6a20              LDR      r0,[r4,#0x20]         ;1792
000bde  6281              STR      r1,[r0,#0x28]         ;1792
000be0  f6af216f          ADR      r1,TIM_DMAError + 1
000be4  6a20              LDR      r0,[r4,#0x20]         ;1795
000be6  6301              STR      r1,[r0,#0x30]         ;1795
000be8  6822              LDR      r2,[r4,#0]            ;1798
000bea  f1020134          ADD      r1,r2,#0x34           ;1798
000bee  463b              MOV      r3,r7                 ;1798
000bf0  4632              MOV      r2,r6                 ;1798
000bf2  6a20              LDR      r0,[r4,#0x20]         ;1798
000bf4  f7fffffe          BL       HAL_DMA_Start_IT
000bf8  6820              LDR      r0,[r4,#0]            ;1801
000bfa  68c0              LDR      r0,[r0,#0xc]          ;1801
000bfc  f4407000          ORR      r0,r0,#0x200          ;1801
000c00  6821              LDR      r1,[r4,#0]            ;1801
000c02  60c8              STR      r0,[r1,#0xc]          ;1801
000c04  e045              B        |L1.3218|
                  |L1.3078|
000c06  f2af01b3          ADR      r1,TIM_DMACaptureCplt + 1
000c0a  6a60              LDR      r0,[r4,#0x24]         ;1808
000c0c  6281              STR      r1,[r0,#0x28]         ;1808
000c0e  f6af219b          ADR      r1,TIM_DMAError + 1
000c12  6a60              LDR      r0,[r4,#0x24]         ;1811
000c14  6301              STR      r1,[r0,#0x30]         ;1811
000c16  6822              LDR      r2,[r4,#0]            ;1814
000c18  f1020138          ADD      r1,r2,#0x38           ;1814
000c1c  463b              MOV      r3,r7                 ;1814
000c1e  4632              MOV      r2,r6                 ;1814
000c20  6a60              LDR      r0,[r4,#0x24]         ;1814
000c22  f7fffffe          BL       HAL_DMA_Start_IT
000c26  6820              LDR      r0,[r4,#0]            ;1817
000c28  68c0              LDR      r0,[r0,#0xc]          ;1817
000c2a  f4406080          ORR      r0,r0,#0x400          ;1817
000c2e  6821              LDR      r1,[r4,#0]            ;1817
000c30  60c8              STR      r0,[r1,#0xc]          ;1817
000c32  e02e              B        |L1.3218|
                  |L1.3124|
000c34  f2af01e3          ADR      r1,TIM_DMACaptureCplt + 1
000c38  6aa0              LDR      r0,[r4,#0x28]         ;1824
000c3a  6281              STR      r1,[r0,#0x28]         ;1824
000c3c  f6af21cb          ADR      r1,TIM_DMAError + 1
000c40  6aa0              LDR      r0,[r4,#0x28]         ;1827
000c42  6301              STR      r1,[r0,#0x30]         ;1827
000c44  6822              LDR      r2,[r4,#0]            ;1830
000c46  f102013c          ADD      r1,r2,#0x3c           ;1830
000c4a  463b              MOV      r3,r7                 ;1830
000c4c  4632              MOV      r2,r6                 ;1830
000c4e  6aa0              LDR      r0,[r4,#0x28]         ;1830
000c50  f7fffffe          BL       HAL_DMA_Start_IT
000c54  6820              LDR      r0,[r4,#0]            ;1833
000c56  68c0              LDR      r0,[r0,#0xc]          ;1833
000c58  f4406000          ORR      r0,r0,#0x800          ;1833
000c5c  6821              LDR      r1,[r4,#0]            ;1833
000c5e  60c8              STR      r0,[r1,#0xc]          ;1833
000c60  e017              B        |L1.3218|
                  |L1.3170|
000c62  f2af110f          ADR      r1,TIM_DMACaptureCplt + 1
000c66  6ae0              LDR      r0,[r4,#0x2c]         ;1840
000c68  6281              STR      r1,[r0,#0x28]         ;1840
000c6a  f6af21f7          ADR      r1,TIM_DMAError + 1
000c6e  6ae0              LDR      r0,[r4,#0x2c]         ;1843
000c70  6301              STR      r1,[r0,#0x30]         ;1843
000c72  6822              LDR      r2,[r4,#0]            ;1846
000c74  f1020140          ADD      r1,r2,#0x40           ;1846
000c78  463b              MOV      r3,r7                 ;1846
000c7a  4632              MOV      r2,r6                 ;1846
000c7c  6ae0              LDR      r0,[r4,#0x2c]         ;1846
000c7e  f7fffffe          BL       HAL_DMA_Start_IT
000c82  6820              LDR      r0,[r4,#0]            ;1849
000c84  68c0              LDR      r0,[r0,#0xc]          ;1849
000c86  f4405080          ORR      r0,r0,#0x1000         ;1849
000c8a  6821              LDR      r1,[r4,#0]            ;1849
000c8c  60c8              STR      r0,[r1,#0xc]          ;1849
000c8e  e000              B        |L1.3218|
                  |L1.3216|
000c90  bf00              NOP                            ;1854
                  |L1.3218|
000c92  bf00              NOP                            ;1803
000c94  2201              MOVS     r2,#1                 ;1858
000c96  4629              MOV      r1,r5                 ;1858
000c98  6820              LDR      r0,[r4,#0]            ;1858
000c9a  f7fffffe          BL       TIM_CCxChannelCmd
000c9e  6820              LDR      r0,[r4,#0]            ;1861
000ca0  6800              LDR      r0,[r0,#0]            ;1861
000ca2  f0400001          ORR      r0,r0,#1              ;1861
000ca6  6821              LDR      r1,[r4,#0]            ;1861
000ca8  6008              STR      r0,[r1,#0]            ;1861
000caa  2000              MOVS     r0,#0                 ;1864
000cac  e77f              B        |L1.2990|
;;;1866   
                          ENDP

                  HAL_TIM_IC_Stop_DMA PROC
;;;1877   */
;;;1878   HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
000cae  b530              PUSH     {r4,r5,lr}
;;;1879   {
000cb0  4604              MOV      r4,r0
000cb2  460d              MOV      r5,r1
;;;1880     /* Check the parameters */
;;;1881     assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
;;;1882     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;1883   
;;;1884     switch (Channel)
000cb4  b135              CBZ      r5,|L1.3268|
000cb6  2d04              CMP      r5,#4
000cb8  d00b              BEQ      |L1.3282|
000cba  2d08              CMP      r5,#8
000cbc  d010              BEQ      |L1.3296|
000cbe  2d0c              CMP      r5,#0xc
000cc0  d11c              BNE      |L1.3324|
000cc2  e014              B        |L1.3310|
                  |L1.3268|
;;;1885     {
;;;1886       case TIM_CHANNEL_1:
;;;1887       {
;;;1888         /* Disable the TIM Capture/Compare 1 DMA request */
;;;1889         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
000cc4  6820              LDR      r0,[r4,#0]
000cc6  68c0              LDR      r0,[r0,#0xc]
000cc8  f4207000          BIC      r0,r0,#0x200
000ccc  6821              LDR      r1,[r4,#0]
000cce  60c8              STR      r0,[r1,#0xc]
;;;1890       }
;;;1891       break;
000cd0  e015              B        |L1.3326|
                  |L1.3282|
;;;1892   
;;;1893       case TIM_CHANNEL_2:
;;;1894       {
;;;1895         /* Disable the TIM Capture/Compare 2 DMA request */
;;;1896         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
000cd2  6820              LDR      r0,[r4,#0]
000cd4  68c0              LDR      r0,[r0,#0xc]
000cd6  f4206080          BIC      r0,r0,#0x400
000cda  6821              LDR      r1,[r4,#0]
000cdc  60c8              STR      r0,[r1,#0xc]
;;;1897       }
;;;1898       break;
000cde  e00e              B        |L1.3326|
                  |L1.3296|
;;;1899   
;;;1900       case TIM_CHANNEL_3:
;;;1901       {
;;;1902         /* Disable the TIM Capture/Compare 3  DMA request */
;;;1903         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
000ce0  6820              LDR      r0,[r4,#0]
000ce2  68c0              LDR      r0,[r0,#0xc]
000ce4  f4206000          BIC      r0,r0,#0x800
000ce8  6821              LDR      r1,[r4,#0]
000cea  60c8              STR      r0,[r1,#0xc]
;;;1904       }
;;;1905       break;
000cec  e007              B        |L1.3326|
                  |L1.3310|
;;;1906   
;;;1907       case TIM_CHANNEL_4:
;;;1908       {
;;;1909         /* Disable the TIM Capture/Compare 4  DMA request */
;;;1910         __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
000cee  6820              LDR      r0,[r4,#0]
000cf0  68c0              LDR      r0,[r0,#0xc]
000cf2  f4205080          BIC      r0,r0,#0x1000
000cf6  6821              LDR      r1,[r4,#0]
000cf8  60c8              STR      r0,[r1,#0xc]
;;;1911       }
;;;1912       break;
000cfa  e000              B        |L1.3326|
                  |L1.3324|
;;;1913   
;;;1914       default:
;;;1915       break;
000cfc  bf00              NOP      
                  |L1.3326|
000cfe  bf00              NOP                            ;1891
;;;1916     }
;;;1917   
;;;1918     /* Disable the Input Capture channel */
;;;1919     TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
000d00  2200              MOVS     r2,#0
000d02  4629              MOV      r1,r5
000d04  6820              LDR      r0,[r4,#0]
000d06  f7fffffe          BL       TIM_CCxChannelCmd
;;;1920   
;;;1921     /* Disable the Peripheral */
;;;1922     __HAL_TIM_DISABLE(htim);
000d0a  bf00              NOP      
000d0c  6820              LDR      r0,[r4,#0]
000d0e  6a00              LDR      r0,[r0,#0x20]
000d10  f2411111          MOV      r1,#0x1111
000d14  4008              ANDS     r0,r0,r1
000d16  b950              CBNZ     r0,|L1.3374|
000d18  6820              LDR      r0,[r4,#0]
000d1a  6a00              LDR      r0,[r0,#0x20]
000d1c  1089              ASRS     r1,r1,#2
000d1e  4008              ANDS     r0,r0,r1
000d20  b928              CBNZ     r0,|L1.3374|
000d22  6820              LDR      r0,[r4,#0]
000d24  6800              LDR      r0,[r0,#0]
000d26  f0200001          BIC      r0,r0,#1
000d2a  6821              LDR      r1,[r4,#0]
000d2c  6008              STR      r0,[r1,#0]
                  |L1.3374|
000d2e  bf00              NOP      
;;;1923   
;;;1924     /* Change the htim state */
;;;1925     htim->State = HAL_TIM_STATE_READY;
000d30  2001              MOVS     r0,#1
000d32  f8840039          STRB     r0,[r4,#0x39]
;;;1926   
;;;1927     /* Return function status */
;;;1928     return HAL_OK;
000d36  2000              MOVS     r0,#0
;;;1929   }
000d38  bd30              POP      {r4,r5,pc}
;;;1930   /**
                          ENDP

                  HAL_TIM_OnePulse_MspInit PROC
;;;2037     */
;;;2038   __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
000d3a  4770              BX       lr
;;;2039   {
;;;2040     /* Prevent unused argument(s) compilation warning */
;;;2041     UNUSED(htim);
;;;2042     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2043               the HAL_TIM_OnePulse_MspInit could be implemented in the user file
;;;2044      */
;;;2045   }
;;;2046   
                          ENDP

                  HAL_TIM_OnePulse_Init PROC
;;;1964     */
;;;1965   HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
000d3c  b570              PUSH     {r4-r6,lr}
;;;1966   {
000d3e  4604              MOV      r4,r0
000d40  460d              MOV      r5,r1
;;;1967     /* Check the TIM handle allocation */
;;;1968     if(htim == NULL)
000d42  b90c              CBNZ     r4,|L1.3400|
;;;1969     {
;;;1970       return HAL_ERROR;
000d44  2001              MOVS     r0,#1
                  |L1.3398|
;;;1971     }
;;;1972   
;;;1973     /* Check the parameters */
;;;1974     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;1975     assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
;;;1976     assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
;;;1977     assert_param(IS_TIM_OPM_MODE(OnePulseMode));
;;;1978   
;;;1979     if(htim->State == HAL_TIM_STATE_RESET)
;;;1980     {
;;;1981       /* Allocate lock resource and initialize it */
;;;1982       htim->Lock = HAL_UNLOCKED;
;;;1983       
;;;1984       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;1985       HAL_TIM_OnePulse_MspInit(htim);
;;;1986     }
;;;1987   
;;;1988     /* Set the TIM state */
;;;1989     htim->State= HAL_TIM_STATE_BUSY;
;;;1990   
;;;1991     /* Configure the Time base in the One Pulse Mode */
;;;1992     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;1993   
;;;1994     /* Reset the OPM Bit */
;;;1995     htim->Instance->CR1 &= ~TIM_CR1_OPM;
;;;1996   
;;;1997     /* Configure the OPM Mode */
;;;1998     htim->Instance->CR1 |= OnePulseMode;
;;;1999   
;;;2000     /* Initialize the TIM state*/
;;;2001     htim->State= HAL_TIM_STATE_READY;
;;;2002   
;;;2003     return HAL_OK;
;;;2004   }
000d46  bd70              POP      {r4-r6,pc}
                  |L1.3400|
000d48  f8940039          LDRB     r0,[r4,#0x39]         ;1979
000d4c  b928              CBNZ     r0,|L1.3418|
000d4e  2000              MOVS     r0,#0                 ;1982
000d50  f8840038          STRB     r0,[r4,#0x38]         ;1982
000d54  4620              MOV      r0,r4                 ;1985
000d56  f7fffffe          BL       HAL_TIM_OnePulse_MspInit
                  |L1.3418|
000d5a  2002              MOVS     r0,#2                 ;1989
000d5c  f8840039          STRB     r0,[r4,#0x39]         ;1989
000d60  1d21              ADDS     r1,r4,#4              ;1992
000d62  6820              LDR      r0,[r4,#0]            ;1992
000d64  f7fffffe          BL       TIM_Base_SetConfig
000d68  6820              LDR      r0,[r4,#0]            ;1995
000d6a  6800              LDR      r0,[r0,#0]            ;1995
000d6c  f0200008          BIC      r0,r0,#8              ;1995
000d70  6821              LDR      r1,[r4,#0]            ;1995
000d72  6008              STR      r0,[r1,#0]            ;1995
000d74  6820              LDR      r0,[r4,#0]            ;1998
000d76  6800              LDR      r0,[r0,#0]            ;1998
000d78  4328              ORRS     r0,r0,r5              ;1998
000d7a  6821              LDR      r1,[r4,#0]            ;1998
000d7c  6008              STR      r0,[r1,#0]            ;1998
000d7e  2001              MOVS     r0,#1                 ;2001
000d80  f8840039          STRB     r0,[r4,#0x39]         ;2001
000d84  2000              MOVS     r0,#0                 ;2003
000d86  e7de              B        |L1.3398|
;;;2005   
                          ENDP

                  HAL_TIM_OnePulse_MspDeInit PROC
;;;2051     */
;;;2052   __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
000d88  4770              BX       lr
;;;2053   {
;;;2054     /* Prevent unused argument(s) compilation warning */
;;;2055     UNUSED(htim);
;;;2056     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2057               the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
;;;2058      */
;;;2059   }
;;;2060   
                          ENDP

                  HAL_TIM_OnePulse_DeInit PROC
;;;2010     */
;;;2011   HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
000d8a  b510              PUSH     {r4,lr}
;;;2012   {
000d8c  4604              MOV      r4,r0
;;;2013     /* Check the parameters */
;;;2014     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2015   
;;;2016     htim->State = HAL_TIM_STATE_BUSY;
000d8e  2002              MOVS     r0,#2
000d90  f8840039          STRB     r0,[r4,#0x39]
;;;2017   
;;;2018     /* Disable the TIM Peripheral Clock */
;;;2019     __HAL_TIM_DISABLE(htim);
000d94  bf00              NOP      
000d96  6820              LDR      r0,[r4,#0]
000d98  6a00              LDR      r0,[r0,#0x20]
000d9a  f2411111          MOV      r1,#0x1111
000d9e  4008              ANDS     r0,r0,r1
000da0  b950              CBNZ     r0,|L1.3512|
000da2  6820              LDR      r0,[r4,#0]
000da4  6a00              LDR      r0,[r0,#0x20]
000da6  1089              ASRS     r1,r1,#2
000da8  4008              ANDS     r0,r0,r1
000daa  b928              CBNZ     r0,|L1.3512|
000dac  6820              LDR      r0,[r4,#0]
000dae  6800              LDR      r0,[r0,#0]
000db0  f0200001          BIC      r0,r0,#1
000db4  6821              LDR      r1,[r4,#0]
000db6  6008              STR      r0,[r1,#0]
                  |L1.3512|
000db8  bf00              NOP      
;;;2020   
;;;2021     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2022     HAL_TIM_OnePulse_MspDeInit(htim);
000dba  4620              MOV      r0,r4
000dbc  f7fffffe          BL       HAL_TIM_OnePulse_MspDeInit
;;;2023   
;;;2024     /* Change TIM state */
;;;2025     htim->State = HAL_TIM_STATE_RESET;
000dc0  2000              MOVS     r0,#0
000dc2  f8840039          STRB     r0,[r4,#0x39]
;;;2026   
;;;2027     /* Release Lock */
;;;2028     __HAL_UNLOCK(htim);
000dc6  bf00              NOP      
000dc8  f8840038          STRB     r0,[r4,#0x38]
000dcc  bf00              NOP      
;;;2029   
;;;2030     return HAL_OK;
;;;2031   }
000dce  bd10              POP      {r4,pc}
;;;2032   
                          ENDP

                  HAL_TIM_OnePulse_Start PROC
;;;2069   */
;;;2070   HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000dd0  b530              PUSH     {r4,r5,lr}
;;;2071   {
000dd2  4604              MOV      r4,r0
000dd4  460d              MOV      r5,r1
;;;2072     /* Enable the Capture compare and the Input Capture channels 
;;;2073       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2074       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2075       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2076       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2077   
;;;2078       No need to enable the counter, it's enabled automatically by hardware 
;;;2079       (the counter starts in response to a stimulus and generate a pulse */
;;;2080   
;;;2081     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000dd6  2201              MOVS     r2,#1
000dd8  2100              MOVS     r1,#0
000dda  6820              LDR      r0,[r4,#0]
000ddc  f7fffffe          BL       TIM_CCxChannelCmd
;;;2082     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000de0  2201              MOVS     r2,#1
000de2  2104              MOVS     r1,#4
000de4  6820              LDR      r0,[r4,#0]
000de6  f7fffffe          BL       TIM_CCxChannelCmd
;;;2083   
;;;2084     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2085     {
;;;2086       /* Enable the main output */
;;;2087       __HAL_TIM_MOE_ENABLE(htim);
;;;2088     }
;;;2089   
;;;2090     /* Return function status */
;;;2091     return HAL_OK;
000dea  2000              MOVS     r0,#0
;;;2092   }
000dec  bd30              POP      {r4,r5,pc}
;;;2093   
                          ENDP

                  HAL_TIM_OnePulse_Stop PROC
;;;2102   */
;;;2103   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000dee  b530              PUSH     {r4,r5,lr}
;;;2104   {
000df0  4604              MOV      r4,r0
000df2  460d              MOV      r5,r1
;;;2105     /* Disable the Capture compare and the Input Capture channels
;;;2106     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2107     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2108     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2109     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2110   
;;;2111     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000df4  2200              MOVS     r2,#0
000df6  4611              MOV      r1,r2
000df8  6820              LDR      r0,[r4,#0]
000dfa  f7fffffe          BL       TIM_CCxChannelCmd
;;;2112     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000dfe  2200              MOVS     r2,#0
000e00  2104              MOVS     r1,#4
000e02  6820              LDR      r0,[r4,#0]
000e04  f7fffffe          BL       TIM_CCxChannelCmd
;;;2113   
;;;2114     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2115     {
;;;2116       /* Disable the Main Ouput */
;;;2117       __HAL_TIM_MOE_DISABLE(htim);
;;;2118     }
;;;2119   
;;;2120     /* Disable the Peripheral */
;;;2121     __HAL_TIM_DISABLE(htim);
000e08  bf00              NOP      
000e0a  6820              LDR      r0,[r4,#0]
000e0c  6a00              LDR      r0,[r0,#0x20]
000e0e  f2411111          MOV      r1,#0x1111
000e12  4008              ANDS     r0,r0,r1
000e14  b950              CBNZ     r0,|L1.3628|
000e16  6820              LDR      r0,[r4,#0]
000e18  6a00              LDR      r0,[r0,#0x20]
000e1a  1089              ASRS     r1,r1,#2
000e1c  4008              ANDS     r0,r0,r1
000e1e  b928              CBNZ     r0,|L1.3628|
000e20  6820              LDR      r0,[r4,#0]
000e22  6800              LDR      r0,[r0,#0]
000e24  f0200001          BIC      r0,r0,#1
000e28  6821              LDR      r1,[r4,#0]
000e2a  6008              STR      r0,[r1,#0]
                  |L1.3628|
000e2c  bf00              NOP      
;;;2122   
;;;2123     /* Return function status */
;;;2124     return HAL_OK;
000e2e  2000              MOVS     r0,#0
;;;2125   }
000e30  bd30              POP      {r4,r5,pc}
;;;2126   
                          ENDP

                  HAL_TIM_OnePulse_Start_IT PROC
;;;2135   */
;;;2136   HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000e32  b530              PUSH     {r4,r5,lr}
;;;2137   {
000e34  4604              MOV      r4,r0
000e36  460d              MOV      r5,r1
;;;2138     /* Enable the Capture compare and the Input Capture channels 
;;;2139       (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2140       if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2141       if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2142       in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
;;;2143   
;;;2144       No need to enable the counter, it's enabled automatically by hardware 
;;;2145       (the counter starts in response to a stimulus and generate a pulse */
;;;2146   
;;;2147     /* Enable the TIM Capture/Compare 1 interrupt */
;;;2148     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
000e38  6820              LDR      r0,[r4,#0]
000e3a  68c0              LDR      r0,[r0,#0xc]
000e3c  f0400002          ORR      r0,r0,#2
000e40  6821              LDR      r1,[r4,#0]
000e42  60c8              STR      r0,[r1,#0xc]
;;;2149   
;;;2150     /* Enable the TIM Capture/Compare 2 interrupt */
;;;2151     __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
000e44  6820              LDR      r0,[r4,#0]
000e46  68c0              LDR      r0,[r0,#0xc]
000e48  f0400004          ORR      r0,r0,#4
000e4c  6821              LDR      r1,[r4,#0]
000e4e  60c8              STR      r0,[r1,#0xc]
;;;2152   
;;;2153     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000e50  2201              MOVS     r2,#1
000e52  2100              MOVS     r1,#0
000e54  6820              LDR      r0,[r4,#0]
000e56  f7fffffe          BL       TIM_CCxChannelCmd
;;;2154     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000e5a  2201              MOVS     r2,#1
000e5c  2104              MOVS     r1,#4
000e5e  6820              LDR      r0,[r4,#0]
000e60  f7fffffe          BL       TIM_CCxChannelCmd
;;;2155   
;;;2156     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2157     {
;;;2158       /* Enable the main output */
;;;2159       __HAL_TIM_MOE_ENABLE(htim);
;;;2160     }
;;;2161   
;;;2162     /* Return function status */
;;;2163     return HAL_OK;
000e64  2000              MOVS     r0,#0
;;;2164   }
000e66  bd30              POP      {r4,r5,pc}
;;;2165   
                          ENDP

                  HAL_TIM_OnePulse_Stop_IT PROC
;;;2174   */
;;;2175   HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
000e68  b530              PUSH     {r4,r5,lr}
;;;2176   {
000e6a  4604              MOV      r4,r0
000e6c  460d              MOV      r5,r1
;;;2177     /* Disable the TIM Capture/Compare 1 interrupt */
;;;2178     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
000e6e  6820              LDR      r0,[r4,#0]
000e70  68c0              LDR      r0,[r0,#0xc]
000e72  f0200002          BIC      r0,r0,#2
000e76  6821              LDR      r1,[r4,#0]
000e78  60c8              STR      r0,[r1,#0xc]
;;;2179   
;;;2180     /* Disable the TIM Capture/Compare 2 interrupt */
;;;2181     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
000e7a  6820              LDR      r0,[r4,#0]
000e7c  68c0              LDR      r0,[r0,#0xc]
000e7e  f0200004          BIC      r0,r0,#4
000e82  6821              LDR      r1,[r4,#0]
000e84  60c8              STR      r0,[r1,#0xc]
;;;2182   
;;;2183     /* Disable the Capture compare and the Input Capture channels 
;;;2184     (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
;;;2185     if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
;;;2186     if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
;;;2187     in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
;;;2188     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
000e86  2200              MOVS     r2,#0
000e88  4611              MOV      r1,r2
000e8a  6820              LDR      r0,[r4,#0]
000e8c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2189     TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
000e90  2200              MOVS     r2,#0
000e92  2104              MOVS     r1,#4
000e94  6820              LDR      r0,[r4,#0]
000e96  f7fffffe          BL       TIM_CCxChannelCmd
;;;2190   
;;;2191     if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
;;;2192     {
;;;2193       /* Disable the Main Ouput */
;;;2194       __HAL_TIM_MOE_DISABLE(htim);
;;;2195     }
;;;2196   
;;;2197     /* Disable the Peripheral */
;;;2198      __HAL_TIM_DISABLE(htim);
000e9a  bf00              NOP      
000e9c  6820              LDR      r0,[r4,#0]
000e9e  6a00              LDR      r0,[r0,#0x20]
000ea0  f2411111          MOV      r1,#0x1111
000ea4  4008              ANDS     r0,r0,r1
000ea6  b950              CBNZ     r0,|L1.3774|
000ea8  6820              LDR      r0,[r4,#0]
000eaa  6a00              LDR      r0,[r0,#0x20]
000eac  1089              ASRS     r1,r1,#2
000eae  4008              ANDS     r0,r0,r1
000eb0  b928              CBNZ     r0,|L1.3774|
000eb2  6820              LDR      r0,[r4,#0]
000eb4  6800              LDR      r0,[r0,#0]
000eb6  f0200001          BIC      r0,r0,#1
000eba  6821              LDR      r1,[r4,#0]
000ebc  6008              STR      r0,[r1,#0]
                  |L1.3774|
000ebe  bf00              NOP      
;;;2199   
;;;2200     /* Return function status */
;;;2201     return HAL_OK;
000ec0  2000              MOVS     r0,#0
;;;2202   }
000ec2  bd30              POP      {r4,r5,pc}
;;;2203   
                          ENDP

                  HAL_TIM_Encoder_MspInit PROC
;;;2351     */
;;;2352   __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
000ec4  4770              BX       lr
;;;2353   {
;;;2354     /* Prevent unused argument(s) compilation warning */
;;;2355     UNUSED(htim);
;;;2356     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2357               the HAL_TIM_Encoder_MspInit could be implemented in the user file
;;;2358      */
;;;2359   }
;;;2360   
                          ENDP

                  HAL_TIM_Encoder_Init PROC
;;;2234     */
;;;2235   HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
000ec6  e92d41f0          PUSH     {r4-r8,lr}
;;;2236   {
000eca  4604              MOV      r4,r0
000ecc  460d              MOV      r5,r1
;;;2237     uint32_t tmpsmcr = 0;
000ece  f04f0800          MOV      r8,#0
;;;2238     uint32_t tmpccmr1 = 0;
000ed2  2600              MOVS     r6,#0
;;;2239     uint32_t tmpccer = 0;
000ed4  2700              MOVS     r7,#0
;;;2240   
;;;2241     /* Check the TIM handle allocation */
;;;2242     if(htim == NULL)
000ed6  b914              CBNZ     r4,|L1.3806|
;;;2243     {
;;;2244       return HAL_ERROR;
000ed8  2001              MOVS     r0,#1
                  |L1.3802|
;;;2245     }
;;;2246   
;;;2247     /* Check the parameters */
;;;2248     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2249     assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
;;;2250     assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
;;;2251     assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
;;;2252     assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
;;;2253     assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
;;;2254     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
;;;2255     assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
;;;2256     assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
;;;2257     assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
;;;2258   
;;;2259     if(htim->State == HAL_TIM_STATE_RESET)
;;;2260     {
;;;2261       /* Allocate lock resource and initialize it */
;;;2262       htim->Lock = HAL_UNLOCKED;
;;;2263       
;;;2264       /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
;;;2265       HAL_TIM_Encoder_MspInit(htim);
;;;2266     }
;;;2267   
;;;2268     /* Set the TIM state */
;;;2269     htim->State= HAL_TIM_STATE_BUSY;
;;;2270   
;;;2271     /* Reset the SMS bits */
;;;2272     htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;2273   
;;;2274     /* Configure the Time base in the Encoder Mode */
;;;2275     TIM_Base_SetConfig(htim->Instance, &htim->Init);
;;;2276   
;;;2277     /* Get the TIMx SMCR register value */
;;;2278     tmpsmcr = htim->Instance->SMCR;
;;;2279   
;;;2280     /* Get the TIMx CCMR1 register value */
;;;2281     tmpccmr1 = htim->Instance->CCMR1;
;;;2282   
;;;2283     /* Get the TIMx CCER register value */
;;;2284     tmpccer = htim->Instance->CCER;
;;;2285   
;;;2286     /* Set the encoder Mode */
;;;2287     tmpsmcr |= sConfig->EncoderMode;
;;;2288   
;;;2289     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;2290     tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
;;;2291     tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8));
;;;2292   
;;;2293     /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
;;;2294     tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
;;;2295     tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
;;;2296     tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8);
;;;2297     tmpccmr1 |= (sConfig->IC1Filter << 4) | (sConfig->IC2Filter << 12);
;;;2298   
;;;2299     /* Set the TI1 and the TI2 Polarities */
;;;2300     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
;;;2301     tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
;;;2302     tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4);
;;;2303   
;;;2304     /* Write to TIMx SMCR */
;;;2305     htim->Instance->SMCR = tmpsmcr;
;;;2306   
;;;2307     /* Write to TIMx CCMR1 */
;;;2308     htim->Instance->CCMR1 = tmpccmr1;
;;;2309   
;;;2310     /* Write to TIMx CCER */
;;;2311     htim->Instance->CCER = tmpccer;
;;;2312   
;;;2313     /* Initialize the TIM state*/
;;;2314     htim->State= HAL_TIM_STATE_READY;
;;;2315   
;;;2316     return HAL_OK;
;;;2317   }
000eda  e8bd81f0          POP      {r4-r8,pc}
                  |L1.3806|
000ede  f8940039          LDRB     r0,[r4,#0x39]         ;2259
000ee2  b928              CBNZ     r0,|L1.3824|
000ee4  2000              MOVS     r0,#0                 ;2262
000ee6  f8840038          STRB     r0,[r4,#0x38]         ;2262
000eea  4620              MOV      r0,r4                 ;2265
000eec  f7fffffe          BL       HAL_TIM_Encoder_MspInit
                  |L1.3824|
000ef0  2002              MOVS     r0,#2                 ;2269
000ef2  f8840039          STRB     r0,[r4,#0x39]         ;2269
000ef6  6820              LDR      r0,[r4,#0]            ;2272
000ef8  6880              LDR      r0,[r0,#8]            ;2272
000efa  f0200007          BIC      r0,r0,#7              ;2272
000efe  6821              LDR      r1,[r4,#0]            ;2272
000f00  6088              STR      r0,[r1,#8]            ;2272
000f02  1d21              ADDS     r1,r4,#4              ;2275
000f04  6820              LDR      r0,[r4,#0]            ;2275
000f06  f7fffffe          BL       TIM_Base_SetConfig
000f0a  6820              LDR      r0,[r4,#0]            ;2278
000f0c  f8d08008          LDR      r8,[r0,#8]            ;2278
000f10  6820              LDR      r0,[r4,#0]            ;2281
000f12  6986              LDR      r6,[r0,#0x18]         ;2281
000f14  6820              LDR      r0,[r4,#0]            ;2284
000f16  6a07              LDR      r7,[r0,#0x20]         ;2284
000f18  6828              LDR      r0,[r5,#0]            ;2287
000f1a  ea400808          ORR      r8,r0,r8              ;2287
000f1e  f2403003          MOV      r0,#0x303             ;2290
000f22  4386              BICS     r6,r6,r0              ;2290
000f24  69a9              LDR      r1,[r5,#0x18]         ;2291
000f26  68a8              LDR      r0,[r5,#8]            ;2291
000f28  ea402001          ORR      r0,r0,r1,LSL #8       ;2291
000f2c  4306              ORRS     r6,r6,r0              ;2291
000f2e  f640400c          MOV      r0,#0xc0c             ;2294
000f32  4386              BICS     r6,r6,r0              ;2294
000f34  f24f00f0          MOV      r0,#0xf0f0            ;2295
000f38  4386              BICS     r6,r6,r0              ;2295
000f3a  69e9              LDR      r1,[r5,#0x1c]         ;2296
000f3c  68e8              LDR      r0,[r5,#0xc]          ;2296
000f3e  ea402001          ORR      r0,r0,r1,LSL #8       ;2296
000f42  4306              ORRS     r6,r6,r0              ;2296
000f44  6928              LDR      r0,[r5,#0x10]         ;2297
000f46  0100              LSLS     r0,r0,#4              ;2297
000f48  6a29              LDR      r1,[r5,#0x20]         ;2297
000f4a  ea403001          ORR      r0,r0,r1,LSL #12      ;2297
000f4e  4306              ORRS     r6,r6,r0              ;2297
000f50  f0270722          BIC      r7,r7,#0x22           ;2300
000f54  f0270788          BIC      r7,r7,#0x88           ;2301
000f58  6969              LDR      r1,[r5,#0x14]         ;2302
000f5a  6868              LDR      r0,[r5,#4]            ;2302
000f5c  ea401001          ORR      r0,r0,r1,LSL #4       ;2302
000f60  4307              ORRS     r7,r7,r0              ;2302
000f62  6820              LDR      r0,[r4,#0]            ;2305
000f64  f8c08008          STR      r8,[r0,#8]            ;2305
000f68  6820              LDR      r0,[r4,#0]            ;2308
000f6a  6186              STR      r6,[r0,#0x18]         ;2308
000f6c  6820              LDR      r0,[r4,#0]            ;2311
000f6e  6207              STR      r7,[r0,#0x20]         ;2311
000f70  2001              MOVS     r0,#1                 ;2314
000f72  f8840039          STRB     r0,[r4,#0x39]         ;2314
000f76  2000              MOVS     r0,#0                 ;2316
000f78  e7af              B        |L1.3802|
;;;2318   
                          ENDP

                  HAL_TIM_Encoder_MspDeInit PROC
;;;2365     */
;;;2366   __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
000f7a  4770              BX       lr
;;;2367   {
;;;2368     /* Prevent unused argument(s) compilation warning */
;;;2369     UNUSED(htim);
;;;2370     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2371               the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
;;;2372      */
;;;2373   }
;;;2374   
                          ENDP

                  HAL_TIM_Encoder_DeInit PROC
;;;2324     */
;;;2325   HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
000f7c  b510              PUSH     {r4,lr}
;;;2326   {
000f7e  4604              MOV      r4,r0
;;;2327     /* Check the parameters */
;;;2328     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;2329   
;;;2330     htim->State = HAL_TIM_STATE_BUSY;
000f80  2002              MOVS     r0,#2
000f82  f8840039          STRB     r0,[r4,#0x39]
;;;2331   
;;;2332     /* Disable the TIM Peripheral Clock */
;;;2333     __HAL_TIM_DISABLE(htim);
000f86  bf00              NOP      
000f88  6820              LDR      r0,[r4,#0]
000f8a  6a00              LDR      r0,[r0,#0x20]
000f8c  f2411111          MOV      r1,#0x1111
000f90  4008              ANDS     r0,r0,r1
000f92  b950              CBNZ     r0,|L1.4010|
000f94  6820              LDR      r0,[r4,#0]
000f96  6a00              LDR      r0,[r0,#0x20]
000f98  1089              ASRS     r1,r1,#2
000f9a  4008              ANDS     r0,r0,r1
000f9c  b928              CBNZ     r0,|L1.4010|
000f9e  6820              LDR      r0,[r4,#0]
000fa0  6800              LDR      r0,[r0,#0]
000fa2  f0200001          BIC      r0,r0,#1
000fa6  6821              LDR      r1,[r4,#0]
000fa8  6008              STR      r0,[r1,#0]
                  |L1.4010|
000faa  bf00              NOP      
;;;2334   
;;;2335     /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
;;;2336     HAL_TIM_Encoder_MspDeInit(htim);
000fac  4620              MOV      r0,r4
000fae  f7fffffe          BL       HAL_TIM_Encoder_MspDeInit
;;;2337   
;;;2338     /* Change TIM state */
;;;2339     htim->State = HAL_TIM_STATE_RESET;
000fb2  2000              MOVS     r0,#0
000fb4  f8840039          STRB     r0,[r4,#0x39]
;;;2340   
;;;2341     /* Release Lock */
;;;2342     __HAL_UNLOCK(htim);
000fb8  bf00              NOP      
000fba  f8840038          STRB     r0,[r4,#0x38]
000fbe  bf00              NOP      
;;;2343   
;;;2344     return HAL_OK;
;;;2345   }
000fc0  bd10              POP      {r4,pc}
;;;2346   
                          ENDP

                  HAL_TIM_Encoder_Start PROC
;;;2384   */
;;;2385   HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
000fc2  b530              PUSH     {r4,r5,lr}
;;;2386   {
000fc4  4604              MOV      r4,r0
000fc6  460d              MOV      r5,r1
;;;2387     /* Check the parameters */
;;;2388     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2389   
;;;2390     /* Enable the encoder interface channels */
;;;2391     switch (Channel)
000fc8  b115              CBZ      r5,|L1.4048|
000fca  2d04              CMP      r5,#4
000fcc  d10c              BNE      |L1.4072|
000fce  e005              B        |L1.4060|
                  |L1.4048|
;;;2392     {
;;;2393       case TIM_CHANNEL_1:
;;;2394     {
;;;2395       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000fd0  2201              MOVS     r2,#1
000fd2  2100              MOVS     r1,#0
000fd4  6820              LDR      r0,[r4,#0]
000fd6  f7fffffe          BL       TIM_CCxChannelCmd
;;;2396         break;
000fda  e010              B        |L1.4094|
                  |L1.4060|
;;;2397     }
;;;2398       case TIM_CHANNEL_2:
;;;2399     {
;;;2400       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000fdc  2201              MOVS     r2,#1
000fde  2104              MOVS     r1,#4
000fe0  6820              LDR      r0,[r4,#0]
000fe2  f7fffffe          BL       TIM_CCxChannelCmd
;;;2401         break;
000fe6  e00a              B        |L1.4094|
                  |L1.4072|
;;;2402     }
;;;2403       default :
;;;2404     {
;;;2405        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
000fe8  2201              MOVS     r2,#1
000fea  2100              MOVS     r1,#0
000fec  6820              LDR      r0,[r4,#0]
000fee  f7fffffe          BL       TIM_CCxChannelCmd
;;;2406        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
000ff2  2201              MOVS     r2,#1
000ff4  2104              MOVS     r1,#4
000ff6  6820              LDR      r0,[r4,#0]
000ff8  f7fffffe          BL       TIM_CCxChannelCmd
;;;2407        break;
000ffc  bf00              NOP      
                  |L1.4094|
000ffe  bf00              NOP                            ;2396
;;;2408       }
;;;2409     }
;;;2410     /* Enable the Peripheral */
;;;2411     __HAL_TIM_ENABLE(htim);
001000  6820              LDR      r0,[r4,#0]
001002  6800              LDR      r0,[r0,#0]
001004  f0400001          ORR      r0,r0,#1
001008  6821              LDR      r1,[r4,#0]
00100a  6008              STR      r0,[r1,#0]
;;;2412   
;;;2413     /* Return function status */
;;;2414     return HAL_OK;
00100c  2000              MOVS     r0,#0
;;;2415   }
00100e  bd30              POP      {r4,r5,pc}
;;;2416   
                          ENDP

                  HAL_TIM_Encoder_Stop PROC
;;;2426   */
;;;2427   HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
001010  b530              PUSH     {r4,r5,lr}
;;;2428   {
001012  4604              MOV      r4,r0
001014  460d              MOV      r5,r1
;;;2429     /* Check the parameters */
;;;2430       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2431   
;;;2432      /* Disable the Input Capture channels 1 and 2
;;;2433       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2434     switch (Channel)
001016  b115              CBZ      r5,|L1.4126|
001018  2d04              CMP      r5,#4
00101a  d10c              BNE      |L1.4150|
00101c  e005              B        |L1.4138|
                  |L1.4126|
;;;2435     {
;;;2436       case TIM_CHANNEL_1:
;;;2437     {
;;;2438        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
00101e  2200              MOVS     r2,#0
001020  4611              MOV      r1,r2
001022  6820              LDR      r0,[r4,#0]
001024  f7fffffe          BL       TIM_CCxChannelCmd
;;;2439         break;
001028  e010              B        |L1.4172|
                  |L1.4138|
;;;2440     }
;;;2441       case TIM_CHANNEL_2:
;;;2442     {
;;;2443       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00102a  2200              MOVS     r2,#0
00102c  2104              MOVS     r1,#4
00102e  6820              LDR      r0,[r4,#0]
001030  f7fffffe          BL       TIM_CCxChannelCmd
;;;2444         break;
001034  e00a              B        |L1.4172|
                  |L1.4150|
;;;2445     }
;;;2446       default :
;;;2447     {
;;;2448       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
001036  2200              MOVS     r2,#0
001038  4611              MOV      r1,r2
00103a  6820              LDR      r0,[r4,#0]
00103c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2449       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
001040  2200              MOVS     r2,#0
001042  2104              MOVS     r1,#4
001044  6820              LDR      r0,[r4,#0]
001046  f7fffffe          BL       TIM_CCxChannelCmd
;;;2450        break;
00104a  bf00              NOP      
                  |L1.4172|
00104c  bf00              NOP                            ;2439
;;;2451       }
;;;2452     }
;;;2453   
;;;2454     /* Disable the Peripheral */
;;;2455     __HAL_TIM_DISABLE(htim);
00104e  bf00              NOP      
001050  6820              LDR      r0,[r4,#0]
001052  6a00              LDR      r0,[r0,#0x20]
001054  f2411111          MOV      r1,#0x1111
001058  4008              ANDS     r0,r0,r1
00105a  b950              CBNZ     r0,|L1.4210|
00105c  6820              LDR      r0,[r4,#0]
00105e  6a00              LDR      r0,[r0,#0x20]
001060  1089              ASRS     r1,r1,#2
001062  4008              ANDS     r0,r0,r1
001064  b928              CBNZ     r0,|L1.4210|
001066  6820              LDR      r0,[r4,#0]
001068  6800              LDR      r0,[r0,#0]
00106a  f0200001          BIC      r0,r0,#1
00106e  6821              LDR      r1,[r4,#0]
001070  6008              STR      r0,[r1,#0]
                  |L1.4210|
001072  bf00              NOP      
;;;2456   
;;;2457     /* Return function status */
;;;2458     return HAL_OK;
001074  2000              MOVS     r0,#0
;;;2459   }
001076  bd30              POP      {r4,r5,pc}
;;;2460   
                          ENDP

                  HAL_TIM_Encoder_Start_IT PROC
;;;2470   */
;;;2471   HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
001078  b530              PUSH     {r4,r5,lr}
;;;2472   {
00107a  4604              MOV      r4,r0
00107c  460d              MOV      r5,r1
;;;2473     /* Check the parameters */
;;;2474     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2475   
;;;2476     /* Enable the encoder interface channels */
;;;2477     /* Enable the capture compare Interrupts 1 and/or 2 */
;;;2478     switch (Channel)
00107e  b115              CBZ      r5,|L1.4230|
001080  2d04              CMP      r5,#4
001082  d118              BNE      |L1.4278|
001084  e00b              B        |L1.4254|
                  |L1.4230|
;;;2479     {
;;;2480       case TIM_CHANNEL_1:
;;;2481     {
;;;2482       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
001086  2201              MOVS     r2,#1
001088  2100              MOVS     r1,#0
00108a  6820              LDR      r0,[r4,#0]
00108c  f7fffffe          BL       TIM_CCxChannelCmd
;;;2483       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
001090  6820              LDR      r0,[r4,#0]
001092  68c0              LDR      r0,[r0,#0xc]
001094  f0400002          ORR      r0,r0,#2
001098  6821              LDR      r1,[r4,#0]
00109a  60c8              STR      r0,[r1,#0xc]
;;;2484         break;
00109c  e022              B        |L1.4324|
                  |L1.4254|
;;;2485     }
;;;2486       case TIM_CHANNEL_2:
;;;2487     {
;;;2488       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
00109e  2201              MOVS     r2,#1
0010a0  2104              MOVS     r1,#4
0010a2  6820              LDR      r0,[r4,#0]
0010a4  f7fffffe          BL       TIM_CCxChannelCmd
;;;2489       __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
0010a8  6820              LDR      r0,[r4,#0]
0010aa  68c0              LDR      r0,[r0,#0xc]
0010ac  f0400004          ORR      r0,r0,#4
0010b0  6821              LDR      r1,[r4,#0]
0010b2  60c8              STR      r0,[r1,#0xc]
;;;2490         break;
0010b4  e016              B        |L1.4324|
                  |L1.4278|
;;;2491     }
;;;2492       default :
;;;2493     {
;;;2494        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
0010b6  2201              MOVS     r2,#1
0010b8  2100              MOVS     r1,#0
0010ba  6820              LDR      r0,[r4,#0]
0010bc  f7fffffe          BL       TIM_CCxChannelCmd
;;;2495        TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
0010c0  2201              MOVS     r2,#1
0010c2  2104              MOVS     r1,#4
0010c4  6820              LDR      r0,[r4,#0]
0010c6  f7fffffe          BL       TIM_CCxChannelCmd
;;;2496        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
0010ca  6820              LDR      r0,[r4,#0]
0010cc  68c0              LDR      r0,[r0,#0xc]
0010ce  f0400002          ORR      r0,r0,#2
0010d2  6821              LDR      r1,[r4,#0]
0010d4  60c8              STR      r0,[r1,#0xc]
;;;2497        __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
0010d6  6820              LDR      r0,[r4,#0]
0010d8  68c0              LDR      r0,[r0,#0xc]
0010da  f0400004          ORR      r0,r0,#4
0010de  6821              LDR      r1,[r4,#0]
0010e0  60c8              STR      r0,[r1,#0xc]
;;;2498        break;
0010e2  bf00              NOP      
                  |L1.4324|
0010e4  bf00              NOP                            ;2484
;;;2499       }
;;;2500     }
;;;2501   
;;;2502     /* Enable the Peripheral */
;;;2503     __HAL_TIM_ENABLE(htim);
0010e6  6820              LDR      r0,[r4,#0]
0010e8  6800              LDR      r0,[r0,#0]
0010ea  f0400001          ORR      r0,r0,#1
0010ee  6821              LDR      r1,[r4,#0]
0010f0  6008              STR      r0,[r1,#0]
;;;2504   
;;;2505     /* Return function status */
;;;2506     return HAL_OK;
0010f2  2000              MOVS     r0,#0
;;;2507   }
0010f4  bd30              POP      {r4,r5,pc}
;;;2508   
                          ENDP

                  HAL_TIM_Encoder_Stop_IT PROC
;;;2518   */
;;;2519   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
0010f6  b530              PUSH     {r4,r5,lr}
;;;2520   {
0010f8  4604              MOV      r4,r0
0010fa  460d              MOV      r5,r1
;;;2521     /* Check the parameters */
;;;2522     assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2523   
;;;2524     /* Disable the Input Capture channels 1 and 2
;;;2525       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2526     if(Channel == TIM_CHANNEL_1)
0010fc  b95d              CBNZ     r5,|L1.4374|
;;;2527     {
;;;2528       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
0010fe  2200              MOVS     r2,#0
001100  4611              MOV      r1,r2
001102  6820              LDR      r0,[r4,#0]
001104  f7fffffe          BL       TIM_CCxChannelCmd
;;;2529   
;;;2530       /* Disable the capture compare Interrupts 1 */
;;;2531     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
001108  6820              LDR      r0,[r4,#0]
00110a  68c0              LDR      r0,[r0,#0xc]
00110c  f0200002          BIC      r0,r0,#2
001110  6821              LDR      r1,[r4,#0]
001112  60c8              STR      r0,[r1,#0xc]
001114  e023              B        |L1.4446|
                  |L1.4374|
;;;2532     }
;;;2533     else if(Channel == TIM_CHANNEL_2)
001116  2d04              CMP      r5,#4
001118  d10b              BNE      |L1.4402|
;;;2534     {
;;;2535       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00111a  2200              MOVS     r2,#0
00111c  2104              MOVS     r1,#4
00111e  6820              LDR      r0,[r4,#0]
001120  f7fffffe          BL       TIM_CCxChannelCmd
;;;2536   
;;;2537       /* Disable the capture compare Interrupts 2 */
;;;2538     __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
001124  6820              LDR      r0,[r4,#0]
001126  68c0              LDR      r0,[r0,#0xc]
001128  f0200004          BIC      r0,r0,#4
00112c  6821              LDR      r1,[r4,#0]
00112e  60c8              STR      r0,[r1,#0xc]
001130  e015              B        |L1.4446|
                  |L1.4402|
;;;2539     }
;;;2540     else
;;;2541     {
;;;2542       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
001132  2200              MOVS     r2,#0
001134  4611              MOV      r1,r2
001136  6820              LDR      r0,[r4,#0]
001138  f7fffffe          BL       TIM_CCxChannelCmd
;;;2543       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00113c  2200              MOVS     r2,#0
00113e  2104              MOVS     r1,#4
001140  6820              LDR      r0,[r4,#0]
001142  f7fffffe          BL       TIM_CCxChannelCmd
;;;2544   
;;;2545       /* Disable the capture compare Interrupts 1 and 2 */
;;;2546       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
001146  6820              LDR      r0,[r4,#0]
001148  68c0              LDR      r0,[r0,#0xc]
00114a  f0200002          BIC      r0,r0,#2
00114e  6821              LDR      r1,[r4,#0]
001150  60c8              STR      r0,[r1,#0xc]
;;;2547       __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
001152  6820              LDR      r0,[r4,#0]
001154  68c0              LDR      r0,[r0,#0xc]
001156  f0200004          BIC      r0,r0,#4
00115a  6821              LDR      r1,[r4,#0]
00115c  60c8              STR      r0,[r1,#0xc]
                  |L1.4446|
;;;2548     }
;;;2549   
;;;2550     /* Disable the Peripheral */
;;;2551     __HAL_TIM_DISABLE(htim);
00115e  bf00              NOP      
001160  6820              LDR      r0,[r4,#0]
001162  6a00              LDR      r0,[r0,#0x20]
001164  f2411111          MOV      r1,#0x1111
001168  4008              ANDS     r0,r0,r1
00116a  b950              CBNZ     r0,|L1.4482|
00116c  6820              LDR      r0,[r4,#0]
00116e  6a00              LDR      r0,[r0,#0x20]
001170  1089              ASRS     r1,r1,#2
001172  4008              ANDS     r0,r0,r1
001174  b928              CBNZ     r0,|L1.4482|
001176  6820              LDR      r0,[r4,#0]
001178  6800              LDR      r0,[r0,#0]
00117a  f0200001          BIC      r0,r0,#1
00117e  6821              LDR      r1,[r4,#0]
001180  6008              STR      r0,[r1,#0]
                  |L1.4482|
001182  bf00              NOP      
;;;2552   
;;;2553     /* Change the htim state */
;;;2554     htim->State = HAL_TIM_STATE_READY;
001184  2001              MOVS     r0,#1
001186  f8840039          STRB     r0,[r4,#0x39]
;;;2555   
;;;2556     /* Return function status */
;;;2557     return HAL_OK;
00118a  2000              MOVS     r0,#0
;;;2558   }
00118c  bd30              POP      {r4,r5,pc}
;;;2559   
                          ENDP

                  HAL_TIM_Encoder_Start_DMA PROC
;;;2572   */
;;;2573   HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
00118e  e92d41f0          PUSH     {r4-r8,lr}
;;;2574   {
001192  4604              MOV      r4,r0
001194  460e              MOV      r6,r1
001196  4617              MOV      r7,r2
001198  461d              MOV      r5,r3
00119a  f8dd8018          LDR      r8,[sp,#0x18]
;;;2575     /* Check the parameters */
;;;2576     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2577   
;;;2578     if((htim->State == HAL_TIM_STATE_BUSY))
00119e  f8940039          LDRB     r0,[r4,#0x39]
0011a2  2802              CMP      r0,#2
0011a4  d101              BNE      |L1.4522|
                  |L1.4518|
;;;2579     {
;;;2580        return HAL_BUSY;
;;;2581     }
;;;2582     else if((htim->State == HAL_TIM_STATE_READY))
;;;2583     {
;;;2584       if((((pData1 == 0) || (pData2 == 0) )) && (Length > 0))
;;;2585       {
;;;2586         return HAL_ERROR;
;;;2587       }
;;;2588       else
;;;2589       {
;;;2590         htim->State = HAL_TIM_STATE_BUSY;
;;;2591       }
;;;2592     }
;;;2593   
;;;2594     switch (Channel)
;;;2595     {
;;;2596       case TIM_CHANNEL_1:
;;;2597       {
;;;2598         /* Set the DMA Period elapsed callback */
;;;2599         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2600   
;;;2601         /* Set the DMA error callback */
;;;2602         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2603   
;;;2604         /* Enable the DMA channel */
;;;2605         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
;;;2606   
;;;2607         /* Enable the TIM Input Capture DMA request */
;;;2608         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2609   
;;;2610         /* Enable the Peripheral */
;;;2611         __HAL_TIM_ENABLE(htim);
;;;2612   
;;;2613         /* Enable the Capture compare channel */
;;;2614         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2615       }
;;;2616       break;
;;;2617   
;;;2618       case TIM_CHANNEL_2:
;;;2619       {
;;;2620         /* Set the DMA Period elapsed callback */
;;;2621         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2622   
;;;2623         /* Set the DMA error callback */
;;;2624         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
;;;2625         /* Enable the DMA channel */
;;;2626         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2627   
;;;2628         /* Enable the TIM Input Capture  DMA request */
;;;2629         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2630   
;;;2631         /* Enable the Peripheral */
;;;2632         __HAL_TIM_ENABLE(htim);
;;;2633   
;;;2634         /* Enable the Capture compare channel */
;;;2635         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2636       }
;;;2637       break;
;;;2638   
;;;2639       case TIM_CHANNEL_ALL:
;;;2640       {
;;;2641         /* Set the DMA Period elapsed callback */
;;;2642         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2643   
;;;2644         /* Set the DMA error callback */
;;;2645         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;2646   
;;;2647         /* Enable the DMA channel */
;;;2648         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
;;;2649   
;;;2650         /* Set the DMA Period elapsed callback */
;;;2651         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
;;;2652   
;;;2653         /* Set the DMA error callback */
;;;2654         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;2655   
;;;2656         /* Enable the DMA channel */
;;;2657         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
;;;2658   
;;;2659        /* Enable the Peripheral */
;;;2660         __HAL_TIM_ENABLE(htim);
;;;2661   
;;;2662         /* Enable the Capture compare channel */
;;;2663         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
;;;2664         TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
;;;2665   
;;;2666         /* Enable the TIM Input Capture  DMA request */
;;;2667         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
;;;2668         /* Enable the TIM Input Capture  DMA request */
;;;2669         __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
;;;2670       }
;;;2671       break;
;;;2672   
;;;2673       default:
;;;2674       break;
;;;2675     }
;;;2676     /* Return function status */
;;;2677     return HAL_OK;
;;;2678   }
0011a6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.4522|
0011aa  f8940039          LDRB     r0,[r4,#0x39]         ;2582
0011ae  2801              CMP      r0,#1                 ;2582
0011b0  d109              BNE      |L1.4550|
0011b2  b107              CBZ      r7,|L1.4534|
0011b4  b925              CBNZ     r5,|L1.4544|
                  |L1.4534|
0011b6  f1b80f00          CMP      r8,#0                 ;2584
0011ba  dd01              BLE      |L1.4544|
0011bc  2001              MOVS     r0,#1                 ;2586
0011be  e7f2              B        |L1.4518|
                  |L1.4544|
0011c0  2002              MOVS     r0,#2                 ;2590
0011c2  f8840039          STRB     r0,[r4,#0x39]         ;2590
                  |L1.4550|
0011c6  b126              CBZ      r6,|L1.4562|
0011c8  2e04              CMP      r6,#4                 ;2594
0011ca  d023              BEQ      |L1.4628|
0011cc  2e18              CMP      r6,#0x18              ;2594
0011ce  d17e              BNE      |L1.4814|
0011d0  e041              B        |L1.4694|
                  |L1.4562|
0011d2  f2af617f          ADR      r1,TIM_DMACaptureCplt + 1
0011d6  6a20              LDR      r0,[r4,#0x20]         ;2599
0011d8  6281              STR      r1,[r0,#0x28]         ;2599
0011da  49f6              LDR      r1,|L1.5556|
0011dc  6a20              LDR      r0,[r4,#0x20]         ;2602
0011de  6301              STR      r1,[r0,#0x30]         ;2602
0011e0  6822              LDR      r2,[r4,#0]            ;2605
0011e2  f1020134          ADD      r1,r2,#0x34           ;2605
0011e6  4643              MOV      r3,r8                 ;2605
0011e8  463a              MOV      r2,r7                 ;2605
0011ea  6a20              LDR      r0,[r4,#0x20]         ;2605
0011ec  f7fffffe          BL       HAL_DMA_Start_IT
0011f0  6820              LDR      r0,[r4,#0]            ;2608
0011f2  68c0              LDR      r0,[r0,#0xc]          ;2608
0011f4  f4407000          ORR      r0,r0,#0x200          ;2608
0011f8  6821              LDR      r1,[r4,#0]            ;2608
0011fa  60c8              STR      r0,[r1,#0xc]          ;2608
0011fc  6820              LDR      r0,[r4,#0]            ;2611
0011fe  6800              LDR      r0,[r0,#0]            ;2611
001200  f0400001          ORR      r0,r0,#1              ;2611
001204  6821              LDR      r1,[r4,#0]            ;2611
001206  6008              STR      r0,[r1,#0]            ;2611
001208  2201              MOVS     r2,#1                 ;2614
00120a  2100              MOVS     r1,#0                 ;2614
00120c  6820              LDR      r0,[r4,#0]            ;2614
00120e  f7fffffe          BL       TIM_CCxChannelCmd
001212  e05d              B        |L1.4816|
                  |L1.4628|
001214  f2af61c3          ADR      r1,TIM_DMACaptureCplt + 1
001218  6a60              LDR      r0,[r4,#0x24]         ;2621
00121a  6281              STR      r1,[r0,#0x28]         ;2621
00121c  49e5              LDR      r1,|L1.5556|
00121e  6a60              LDR      r0,[r4,#0x24]         ;2624
001220  6301              STR      r1,[r0,#0x30]         ;2624
001222  6822              LDR      r2,[r4,#0]            ;2626
001224  f1020138          ADD      r1,r2,#0x38           ;2626
001228  4643              MOV      r3,r8                 ;2626
00122a  462a              MOV      r2,r5                 ;2626
00122c  6a60              LDR      r0,[r4,#0x24]         ;2626
00122e  f7fffffe          BL       HAL_DMA_Start_IT
001232  6820              LDR      r0,[r4,#0]            ;2629
001234  68c0              LDR      r0,[r0,#0xc]          ;2629
001236  f4406080          ORR      r0,r0,#0x400          ;2629
00123a  6821              LDR      r1,[r4,#0]            ;2629
00123c  60c8              STR      r0,[r1,#0xc]          ;2629
00123e  6820              LDR      r0,[r4,#0]            ;2632
001240  6800              LDR      r0,[r0,#0]            ;2632
001242  f0400001          ORR      r0,r0,#1              ;2632
001246  6821              LDR      r1,[r4,#0]            ;2632
001248  6008              STR      r0,[r1,#0]            ;2632
00124a  2201              MOVS     r2,#1                 ;2635
00124c  2104              MOVS     r1,#4                 ;2635
00124e  6820              LDR      r0,[r4,#0]            ;2635
001250  f7fffffe          BL       TIM_CCxChannelCmd
001254  e03c              B        |L1.4816|
                  |L1.4694|
001256  f2af7103          ADR      r1,TIM_DMACaptureCplt + 1
00125a  6a20              LDR      r0,[r4,#0x20]         ;2642
00125c  6281              STR      r1,[r0,#0x28]         ;2642
00125e  49d5              LDR      r1,|L1.5556|
001260  6a20              LDR      r0,[r4,#0x20]         ;2645
001262  6301              STR      r1,[r0,#0x30]         ;2645
001264  6822              LDR      r2,[r4,#0]            ;2648
001266  f1020134          ADD      r1,r2,#0x34           ;2648
00126a  4643              MOV      r3,r8                 ;2648
00126c  463a              MOV      r2,r7                 ;2648
00126e  6a20              LDR      r0,[r4,#0x20]         ;2648
001270  f7fffffe          BL       HAL_DMA_Start_IT
001274  f2af7123          ADR      r1,TIM_DMACaptureCplt + 1
001278  6a60              LDR      r0,[r4,#0x24]         ;2651
00127a  6281              STR      r1,[r0,#0x28]         ;2651
00127c  49cd              LDR      r1,|L1.5556|
00127e  6a60              LDR      r0,[r4,#0x24]         ;2654
001280  6301              STR      r1,[r0,#0x30]         ;2654
001282  6822              LDR      r2,[r4,#0]            ;2657
001284  f1020138          ADD      r1,r2,#0x38           ;2657
001288  4643              MOV      r3,r8                 ;2657
00128a  462a              MOV      r2,r5                 ;2657
00128c  6a60              LDR      r0,[r4,#0x24]         ;2657
00128e  f7fffffe          BL       HAL_DMA_Start_IT
001292  6820              LDR      r0,[r4,#0]            ;2660
001294  6800              LDR      r0,[r0,#0]            ;2660
001296  f0400001          ORR      r0,r0,#1              ;2660
00129a  6821              LDR      r1,[r4,#0]            ;2660
00129c  6008              STR      r0,[r1,#0]            ;2660
00129e  2201              MOVS     r2,#1                 ;2663
0012a0  2100              MOVS     r1,#0                 ;2663
0012a2  6820              LDR      r0,[r4,#0]            ;2663
0012a4  f7fffffe          BL       TIM_CCxChannelCmd
0012a8  2201              MOVS     r2,#1                 ;2664
0012aa  2104              MOVS     r1,#4                 ;2664
0012ac  6820              LDR      r0,[r4,#0]            ;2664
0012ae  f7fffffe          BL       TIM_CCxChannelCmd
0012b2  6820              LDR      r0,[r4,#0]            ;2667
0012b4  68c0              LDR      r0,[r0,#0xc]          ;2667
0012b6  f4407000          ORR      r0,r0,#0x200          ;2667
0012ba  6821              LDR      r1,[r4,#0]            ;2667
0012bc  60c8              STR      r0,[r1,#0xc]          ;2667
0012be  6820              LDR      r0,[r4,#0]            ;2669
0012c0  68c0              LDR      r0,[r0,#0xc]          ;2669
0012c2  f4406080          ORR      r0,r0,#0x400          ;2669
0012c6  6821              LDR      r1,[r4,#0]            ;2669
0012c8  60c8              STR      r0,[r1,#0xc]          ;2669
0012ca  e001              B        |L1.4816|
0012cc  e7ff              B        |L1.4814|
                  |L1.4814|
0012ce  bf00              NOP                            ;2674
                  |L1.4816|
0012d0  bf00              NOP                            ;2616
0012d2  2000              MOVS     r0,#0                 ;2677
0012d4  e767              B        |L1.4518|
;;;2679   
                          ENDP

                  HAL_TIM_Encoder_Stop_DMA PROC
;;;2689   */
;;;2690   HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
0012d6  b530              PUSH     {r4,r5,lr}
;;;2691   {
0012d8  4604              MOV      r4,r0
0012da  460d              MOV      r5,r1
;;;2692     /* Check the parameters */
;;;2693     assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
;;;2694   
;;;2695     /* Disable the Input Capture channels 1 and 2
;;;2696       (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
;;;2697     if(Channel == TIM_CHANNEL_1)
0012dc  b95d              CBNZ     r5,|L1.4854|
;;;2698     {
;;;2699       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
0012de  2200              MOVS     r2,#0
0012e0  4611              MOV      r1,r2
0012e2  6820              LDR      r0,[r4,#0]
0012e4  f7fffffe          BL       TIM_CCxChannelCmd
;;;2700   
;;;2701       /* Disable the capture compare DMA Request 1 */
;;;2702       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
0012e8  6820              LDR      r0,[r4,#0]
0012ea  68c0              LDR      r0,[r0,#0xc]
0012ec  f4207000          BIC      r0,r0,#0x200
0012f0  6821              LDR      r1,[r4,#0]
0012f2  60c8              STR      r0,[r1,#0xc]
0012f4  e023              B        |L1.4926|
                  |L1.4854|
;;;2703     }
;;;2704     else if(Channel == TIM_CHANNEL_2)
0012f6  2d04              CMP      r5,#4
0012f8  d10b              BNE      |L1.4882|
;;;2705     {
;;;2706       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
0012fa  2200              MOVS     r2,#0
0012fc  2104              MOVS     r1,#4
0012fe  6820              LDR      r0,[r4,#0]
001300  f7fffffe          BL       TIM_CCxChannelCmd
;;;2707   
;;;2708       /* Disable the capture compare DMA Request 2 */
;;;2709       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
001304  6820              LDR      r0,[r4,#0]
001306  68c0              LDR      r0,[r0,#0xc]
001308  f4206080          BIC      r0,r0,#0x400
00130c  6821              LDR      r1,[r4,#0]
00130e  60c8              STR      r0,[r1,#0xc]
001310  e015              B        |L1.4926|
                  |L1.4882|
;;;2710     }
;;;2711     else
;;;2712     {
;;;2713       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
001312  2200              MOVS     r2,#0
001314  4611              MOV      r1,r2
001316  6820              LDR      r0,[r4,#0]
001318  f7fffffe          BL       TIM_CCxChannelCmd
;;;2714       TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
00131c  2200              MOVS     r2,#0
00131e  2104              MOVS     r1,#4
001320  6820              LDR      r0,[r4,#0]
001322  f7fffffe          BL       TIM_CCxChannelCmd
;;;2715   
;;;2716       /* Disable the capture compare DMA Request 1 and 2 */
;;;2717       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
001326  6820              LDR      r0,[r4,#0]
001328  68c0              LDR      r0,[r0,#0xc]
00132a  f4207000          BIC      r0,r0,#0x200
00132e  6821              LDR      r1,[r4,#0]
001330  60c8              STR      r0,[r1,#0xc]
;;;2718       __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
001332  6820              LDR      r0,[r4,#0]
001334  68c0              LDR      r0,[r0,#0xc]
001336  f4206080          BIC      r0,r0,#0x400
00133a  6821              LDR      r1,[r4,#0]
00133c  60c8              STR      r0,[r1,#0xc]
                  |L1.4926|
;;;2719     }
;;;2720   
;;;2721     /* Disable the Peripheral */
;;;2722     __HAL_TIM_DISABLE(htim);
00133e  bf00              NOP      
001340  6820              LDR      r0,[r4,#0]
001342  6a00              LDR      r0,[r0,#0x20]
001344  f2411111          MOV      r1,#0x1111
001348  4008              ANDS     r0,r0,r1
00134a  b950              CBNZ     r0,|L1.4962|
00134c  6820              LDR      r0,[r4,#0]
00134e  6a00              LDR      r0,[r0,#0x20]
001350  1089              ASRS     r1,r1,#2
001352  4008              ANDS     r0,r0,r1
001354  b928              CBNZ     r0,|L1.4962|
001356  6820              LDR      r0,[r4,#0]
001358  6800              LDR      r0,[r0,#0]
00135a  f0200001          BIC      r0,r0,#1
00135e  6821              LDR      r1,[r4,#0]
001360  6008              STR      r0,[r1,#0]
                  |L1.4962|
001362  bf00              NOP      
;;;2723   
;;;2724     /* Change the htim state */
;;;2725     htim->State = HAL_TIM_STATE_READY;
001364  2001              MOVS     r0,#1
001366  f8840039          STRB     r0,[r4,#0x39]
;;;2726   
;;;2727     /* Return function status */
;;;2728     return HAL_OK;
00136a  2000              MOVS     r0,#0
;;;2729   }
00136c  bd30              POP      {r4,r5,pc}
;;;2730   
                          ENDP

                  HAL_TIM_TriggerCallback PROC
;;;4325     */
;;;4326   __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
00136e  4770              BX       lr
;;;4327   {
;;;4328     /* Prevent unused argument(s) compilation warning */
;;;4329     UNUSED(htim);
;;;4330     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4331               the HAL_TIM_TriggerCallback could be implemented in the user file
;;;4332      */
;;;4333   }
;;;4334   
                          ENDP

                  HAL_TIM_OC_DelayElapsedCallback PROC
;;;4284     */
;;;4285   __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
001370  4770              BX       lr
;;;4286   {
;;;4287     /* Prevent unused argument(s) compilation warning */
;;;4288     UNUSED(htim);
;;;4289     /* NOTE : This function Should not be modified, when the callback is needed,
;;;4290               the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
;;;4291      */
;;;4292   }
;;;4293   /**
                          ENDP

                  HAL_TIM_IRQHandler PROC
;;;2751     */
;;;2752   void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
001372  b510              PUSH     {r4,lr}
;;;2753   {
001374  4604              MOV      r4,r0
;;;2754     /* Capture compare 1 event */
;;;2755     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
001376  6820              LDR      r0,[r4,#0]
001378  6900              LDR      r0,[r0,#0x10]
00137a  f3c00040          UBFX     r0,r0,#1,#1
00137e  b1d8              CBZ      r0,|L1.5048|
;;;2756     {
;;;2757       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
001380  6820              LDR      r0,[r4,#0]
001382  68c0              LDR      r0,[r0,#0xc]
001384  f3c00040          UBFX     r0,r0,#1,#1
001388  b1b0              CBZ      r0,|L1.5048|
;;;2758       {
;;;2759         {
;;;2760           __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
00138a  f06f0002          MVN      r0,#2
00138e  6821              LDR      r1,[r4,#0]
001390  6108              STR      r0,[r1,#0x10]
;;;2761           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
001392  2001              MOVS     r0,#1
001394  7620              STRB     r0,[r4,#0x18]
;;;2762   
;;;2763           /* Input capture event */
;;;2764           if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
001396  6820              LDR      r0,[r4,#0]
001398  6980              LDR      r0,[r0,#0x18]
00139a  f0000003          AND      r0,r0,#3
00139e  b118              CBZ      r0,|L1.5032|
;;;2765           {
;;;2766             HAL_TIM_IC_CaptureCallback(htim);
0013a0  4620              MOV      r0,r4
0013a2  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0013a6  e005              B        |L1.5044|
                  |L1.5032|
;;;2767           }
;;;2768           /* Output compare event */
;;;2769           else
;;;2770           {
;;;2771             HAL_TIM_OC_DelayElapsedCallback(htim);
0013a8  4620              MOV      r0,r4
0013aa  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2772             HAL_TIM_PWM_PulseFinishedCallback(htim);
0013ae  4620              MOV      r0,r4
0013b0  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5044|
;;;2773           }
;;;2774           htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0013b4  2000              MOVS     r0,#0
0013b6  7620              STRB     r0,[r4,#0x18]
                  |L1.5048|
;;;2775         }
;;;2776       }
;;;2777     }
;;;2778     /* Capture compare 2 event */
;;;2779     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
0013b8  6820              LDR      r0,[r4,#0]
0013ba  6900              LDR      r0,[r0,#0x10]
0013bc  f3c00080          UBFX     r0,r0,#2,#1
0013c0  b1d8              CBZ      r0,|L1.5114|
;;;2780     {
;;;2781       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
0013c2  6820              LDR      r0,[r4,#0]
0013c4  68c0              LDR      r0,[r0,#0xc]
0013c6  f3c00080          UBFX     r0,r0,#2,#1
0013ca  b1b0              CBZ      r0,|L1.5114|
;;;2782       {
;;;2783         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
0013cc  f06f0004          MVN      r0,#4
0013d0  6821              LDR      r1,[r4,#0]
0013d2  6108              STR      r0,[r1,#0x10]
;;;2784         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
0013d4  2002              MOVS     r0,#2
0013d6  7620              STRB     r0,[r4,#0x18]
;;;2785         /* Input capture event */
;;;2786         if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
0013d8  6820              LDR      r0,[r4,#0]
0013da  6980              LDR      r0,[r0,#0x18]
0013dc  f4007040          AND      r0,r0,#0x300
0013e0  b118              CBZ      r0,|L1.5098|
;;;2787         {
;;;2788           HAL_TIM_IC_CaptureCallback(htim);
0013e2  4620              MOV      r0,r4
0013e4  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
0013e8  e005              B        |L1.5110|
                  |L1.5098|
;;;2789         }
;;;2790         /* Output compare event */
;;;2791         else
;;;2792         {
;;;2793           HAL_TIM_OC_DelayElapsedCallback(htim);
0013ea  4620              MOV      r0,r4
0013ec  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2794           HAL_TIM_PWM_PulseFinishedCallback(htim);
0013f0  4620              MOV      r0,r4
0013f2  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5110|
;;;2795         }
;;;2796         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
0013f6  2000              MOVS     r0,#0
0013f8  7620              STRB     r0,[r4,#0x18]
                  |L1.5114|
;;;2797       }
;;;2798     }
;;;2799     /* Capture compare 3 event */
;;;2800     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
0013fa  6820              LDR      r0,[r4,#0]
0013fc  6900              LDR      r0,[r0,#0x10]
0013fe  f3c000c0          UBFX     r0,r0,#3,#1
001402  b1d8              CBZ      r0,|L1.5180|
;;;2801     {
;;;2802       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
001404  6820              LDR      r0,[r4,#0]
001406  68c0              LDR      r0,[r0,#0xc]
001408  f3c000c0          UBFX     r0,r0,#3,#1
00140c  b1b0              CBZ      r0,|L1.5180|
;;;2803       {
;;;2804         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
00140e  f06f0008          MVN      r0,#8
001412  6821              LDR      r1,[r4,#0]
001414  6108              STR      r0,[r1,#0x10]
;;;2805         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
001416  2004              MOVS     r0,#4
001418  7620              STRB     r0,[r4,#0x18]
;;;2806         /* Input capture event */
;;;2807         if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
00141a  6820              LDR      r0,[r4,#0]
00141c  69c0              LDR      r0,[r0,#0x1c]
00141e  f0000003          AND      r0,r0,#3
001422  b118              CBZ      r0,|L1.5164|
;;;2808         {
;;;2809           HAL_TIM_IC_CaptureCallback(htim);
001424  4620              MOV      r0,r4
001426  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00142a  e005              B        |L1.5176|
                  |L1.5164|
;;;2810         }
;;;2811         /* Output compare event */
;;;2812         else
;;;2813         {
;;;2814           HAL_TIM_OC_DelayElapsedCallback(htim);
00142c  4620              MOV      r0,r4
00142e  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2815           HAL_TIM_PWM_PulseFinishedCallback(htim);
001432  4620              MOV      r0,r4
001434  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5176|
;;;2816         }
;;;2817         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
001438  2000              MOVS     r0,#0
00143a  7620              STRB     r0,[r4,#0x18]
                  |L1.5180|
;;;2818       }
;;;2819     }
;;;2820     /* Capture compare 4 event */
;;;2821     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
00143c  6820              LDR      r0,[r4,#0]
00143e  6900              LDR      r0,[r0,#0x10]
001440  f3c01000          UBFX     r0,r0,#4,#1
001444  b1d8              CBZ      r0,|L1.5246|
;;;2822     {
;;;2823       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
001446  6820              LDR      r0,[r4,#0]
001448  68c0              LDR      r0,[r0,#0xc]
00144a  f3c01000          UBFX     r0,r0,#4,#1
00144e  b1b0              CBZ      r0,|L1.5246|
;;;2824       {
;;;2825         __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
001450  f06f0010          MVN      r0,#0x10
001454  6821              LDR      r1,[r4,#0]
001456  6108              STR      r0,[r1,#0x10]
;;;2826         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
001458  2008              MOVS     r0,#8
00145a  7620              STRB     r0,[r4,#0x18]
;;;2827         /* Input capture event */
;;;2828         if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
00145c  6820              LDR      r0,[r4,#0]
00145e  69c0              LDR      r0,[r0,#0x1c]
001460  f4007040          AND      r0,r0,#0x300
001464  b118              CBZ      r0,|L1.5230|
;;;2829         {
;;;2830           HAL_TIM_IC_CaptureCallback(htim);
001466  4620              MOV      r0,r4
001468  f7fffffe          BL       HAL_TIM_IC_CaptureCallback
00146c  e005              B        |L1.5242|
                  |L1.5230|
;;;2831         }
;;;2832         /* Output compare event */
;;;2833         else
;;;2834         {
;;;2835           HAL_TIM_OC_DelayElapsedCallback(htim);
00146e  4620              MOV      r0,r4
001470  f7fffffe          BL       HAL_TIM_OC_DelayElapsedCallback
;;;2836           HAL_TIM_PWM_PulseFinishedCallback(htim);
001474  4620              MOV      r0,r4
001476  f7fffffe          BL       HAL_TIM_PWM_PulseFinishedCallback
                  |L1.5242|
;;;2837         }
;;;2838         htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
00147a  2000              MOVS     r0,#0
00147c  7620              STRB     r0,[r4,#0x18]
                  |L1.5246|
;;;2839       }
;;;2840     }
;;;2841     /* TIM Update event */
;;;2842     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
00147e  6820              LDR      r0,[r4,#0]
001480  6900              LDR      r0,[r0,#0x10]
001482  f0000001          AND      r0,r0,#1
001486  b158              CBZ      r0,|L1.5280|
;;;2843     {
;;;2844       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
001488  6820              LDR      r0,[r4,#0]
00148a  68c0              LDR      r0,[r0,#0xc]
00148c  f0000001          AND      r0,r0,#1
001490  b130              CBZ      r0,|L1.5280|
;;;2845       {
;;;2846         __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
001492  f06f0001          MVN      r0,#1
001496  6821              LDR      r1,[r4,#0]
001498  6108              STR      r0,[r1,#0x10]
;;;2847         HAL_TIM_PeriodElapsedCallback(htim);
00149a  4620              MOV      r0,r4
00149c  f7fffffe          BL       HAL_TIM_PeriodElapsedCallback
                  |L1.5280|
;;;2848       }
;;;2849     }
;;;2850     /* TIM Break input event */
;;;2851     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
0014a0  6820              LDR      r0,[r4,#0]
0014a2  6900              LDR      r0,[r0,#0x10]
0014a4  f3c010c0          UBFX     r0,r0,#7,#1
0014a8  b158              CBZ      r0,|L1.5314|
;;;2852     {
;;;2853       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
0014aa  6820              LDR      r0,[r4,#0]
0014ac  68c0              LDR      r0,[r0,#0xc]
0014ae  f3c010c0          UBFX     r0,r0,#7,#1
0014b2  b130              CBZ      r0,|L1.5314|
;;;2854       {
;;;2855         __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
0014b4  f06f0080          MVN      r0,#0x80
0014b8  6821              LDR      r1,[r4,#0]
0014ba  6108              STR      r0,[r1,#0x10]
;;;2856         HAL_TIMEx_BreakCallback(htim);
0014bc  4620              MOV      r0,r4
0014be  f7fffffe          BL       HAL_TIMEx_BreakCallback
                  |L1.5314|
;;;2857       }
;;;2858     }
;;;2859     /* TIM Trigger detection event */
;;;2860     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
0014c2  6820              LDR      r0,[r4,#0]
0014c4  6900              LDR      r0,[r0,#0x10]
0014c6  f3c01080          UBFX     r0,r0,#6,#1
0014ca  b158              CBZ      r0,|L1.5348|
;;;2861     {
;;;2862       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
0014cc  6820              LDR      r0,[r4,#0]
0014ce  68c0              LDR      r0,[r0,#0xc]
0014d0  f3c01080          UBFX     r0,r0,#6,#1
0014d4  b130              CBZ      r0,|L1.5348|
;;;2863       {
;;;2864         __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
0014d6  f06f0040          MVN      r0,#0x40
0014da  6821              LDR      r1,[r4,#0]
0014dc  6108              STR      r0,[r1,#0x10]
;;;2865         HAL_TIM_TriggerCallback(htim);
0014de  4620              MOV      r0,r4
0014e0  f7fffffe          BL       HAL_TIM_TriggerCallback
                  |L1.5348|
;;;2866       }
;;;2867     }
;;;2868     /* TIM commutation event */
;;;2869     if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
0014e4  6820              LDR      r0,[r4,#0]
0014e6  6900              LDR      r0,[r0,#0x10]
0014e8  f3c01040          UBFX     r0,r0,#5,#1
0014ec  b158              CBZ      r0,|L1.5382|
;;;2870     {
;;;2871       if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
0014ee  6820              LDR      r0,[r4,#0]
0014f0  68c0              LDR      r0,[r0,#0xc]
0014f2  f3c01040          UBFX     r0,r0,#5,#1
0014f6  b130              CBZ      r0,|L1.5382|
;;;2872       {
;;;2873         __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
0014f8  f06f0020          MVN      r0,#0x20
0014fc  6821              LDR      r1,[r4,#0]
0014fe  6108              STR      r0,[r1,#0x10]
;;;2874         HAL_TIMEx_CommutationCallback(htim);
001500  4620              MOV      r0,r4
001502  f7fffffe          BL       HAL_TIMEx_CommutationCallback
                  |L1.5382|
;;;2875       }
;;;2876     }
;;;2877   }
001506  bd10              POP      {r4,pc}
;;;2878   
                          ENDP

                  TIM_OC4_SetConfig PROC
;;;4821     */
;;;4822   static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001508  b530              PUSH     {r4,r5,lr}
;;;4823   {
;;;4824     uint32_t tmpccmrx = 0;
00150a  2200              MOVS     r2,#0
;;;4825     uint32_t tmpccer = 0;
00150c  2300              MOVS     r3,#0
;;;4826     uint32_t tmpcr2 = 0;
00150e  2400              MOVS     r4,#0
;;;4827   
;;;4828     /* Disable the Channel 4: Reset the CC4E Bit */
;;;4829     TIMx->CCER &= ~TIM_CCER_CC4E;
001510  6a05              LDR      r5,[r0,#0x20]
001512  f4255580          BIC      r5,r5,#0x1000
001516  6205              STR      r5,[r0,#0x20]
;;;4830   
;;;4831     /* Get the TIMx CCER register value */
;;;4832     tmpccer = TIMx->CCER;
001518  6a03              LDR      r3,[r0,#0x20]
;;;4833     /* Get the TIMx CR2 register value */
;;;4834     tmpcr2 =  TIMx->CR2;
00151a  6844              LDR      r4,[r0,#4]
;;;4835   
;;;4836     /* Get the TIMx CCMR2 register value */
;;;4837     tmpccmrx = TIMx->CCMR2;
00151c  69c2              LDR      r2,[r0,#0x1c]
;;;4838   
;;;4839     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4840     tmpccmrx &= ~TIM_CCMR2_OC4M;
00151e  f42242e0          BIC      r2,r2,#0x7000
;;;4841     tmpccmrx &= ~TIM_CCMR2_CC4S;
001522  f4227240          BIC      r2,r2,#0x300
;;;4842   
;;;4843     /* Select the Output Compare Mode */
;;;4844     tmpccmrx |= (OC_Config->OCMode << 8);
001526  680d              LDR      r5,[r1,#0]
001528  ea422205          ORR      r2,r2,r5,LSL #8
;;;4845   
;;;4846     /* Reset the Output Polarity level */
;;;4847     tmpccer &= ~TIM_CCER_CC4P;
00152c  f4235300          BIC      r3,r3,#0x2000
;;;4848     /* Set the Output Compare Polarity */
;;;4849     tmpccer |= (OC_Config->OCPolarity << 12);
001530  688d              LDR      r5,[r1,#8]
001532  ea433305          ORR      r3,r3,r5,LSL #12
;;;4850   
;;;4851     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4852     {
;;;4853       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4854   
;;;4855      /* Reset the Output Compare IDLE State */
;;;4856       tmpcr2 &= ~TIM_CR2_OIS4;
;;;4857       /* Set the Output Idle state */
;;;4858       tmpcr2 |= (OC_Config->OCIdleState << 6);
;;;4859     }
;;;4860   
;;;4861     /* Write to TIMx CR2 */
;;;4862     TIMx->CR2 = tmpcr2;
001536  6044              STR      r4,[r0,#4]
;;;4863   
;;;4864     /* Write to TIMx CCMR2 */
;;;4865     TIMx->CCMR2 = tmpccmrx;
001538  61c2              STR      r2,[r0,#0x1c]
;;;4866   
;;;4867     /* Set the Capture Compare Register value */
;;;4868     TIMx->CCR4 = OC_Config->Pulse;
00153a  684d              LDR      r5,[r1,#4]
00153c  6405              STR      r5,[r0,#0x40]
;;;4869   
;;;4870     /* Write to TIMx CCER */
;;;4871     TIMx->CCER = tmpccer;
00153e  6203              STR      r3,[r0,#0x20]
;;;4872   }
001540  bd30              POP      {r4,r5,pc}
;;;4873   
                          ENDP

                  TIM_OC3_SetConfig PROC
;;;4747     */
;;;4748   static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
001542  b530              PUSH     {r4,r5,lr}
;;;4749   {
;;;4750     uint32_t tmpccmrx = 0;
001544  2200              MOVS     r2,#0
;;;4751     uint32_t tmpccer = 0;
001546  2300              MOVS     r3,#0
;;;4752     uint32_t tmpcr2 = 0;
001548  2400              MOVS     r4,#0
;;;4753   
;;;4754     /* Disable the Channel 3: Reset the CC2E Bit */
;;;4755     TIMx->CCER &= ~TIM_CCER_CC3E;
00154a  6a05              LDR      r5,[r0,#0x20]
00154c  f4257580          BIC      r5,r5,#0x100
001550  6205              STR      r5,[r0,#0x20]
;;;4756   
;;;4757     /* Get the TIMx CCER register value */
;;;4758     tmpccer = TIMx->CCER;
001552  6a03              LDR      r3,[r0,#0x20]
;;;4759     /* Get the TIMx CR2 register value */
;;;4760     tmpcr2 =  TIMx->CR2;
001554  6844              LDR      r4,[r0,#4]
;;;4761   
;;;4762     /* Get the TIMx CCMR2 register value */
;;;4763     tmpccmrx = TIMx->CCMR2;
001556  69c2              LDR      r2,[r0,#0x1c]
;;;4764   
;;;4765     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4766     tmpccmrx &= ~TIM_CCMR2_OC3M;
001558  f0220270          BIC      r2,r2,#0x70
;;;4767     tmpccmrx &= ~TIM_CCMR2_CC3S;
00155c  f0220203          BIC      r2,r2,#3
;;;4768     /* Select the Output Compare Mode */
;;;4769     tmpccmrx |= OC_Config->OCMode;
001560  680d              LDR      r5,[r1,#0]
001562  432a              ORRS     r2,r2,r5
;;;4770   
;;;4771     /* Reset the Output Polarity level */
;;;4772     tmpccer &= ~TIM_CCER_CC3P;
001564  f4237300          BIC      r3,r3,#0x200
;;;4773     /* Set the Output Compare Polarity */
;;;4774     tmpccer |= (OC_Config->OCPolarity << 8);
001568  688d              LDR      r5,[r1,#8]
00156a  ea432305          ORR      r3,r3,r5,LSL #8
;;;4775   
;;;4776     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
;;;4777     {
;;;4778       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4779   
;;;4780       /* Reset the Output N Polarity level */
;;;4781       tmpccer &= ~TIM_CCER_CC3NP;
;;;4782       /* Set the Output N Polarity */
;;;4783       tmpccer |= (OC_Config->OCNPolarity << 8);
;;;4784       /* Reset the Output N State */
;;;4785       tmpccer &= ~TIM_CCER_CC3NE;
;;;4786     }
;;;4787   
;;;4788     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4789     {
;;;4790       /* Check parameters */
;;;4791       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4792       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4793   
;;;4794       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4795       tmpcr2 &= ~TIM_CR2_OIS3;
;;;4796       tmpcr2 &= ~TIM_CR2_OIS3N;
;;;4797       /* Set the Output Idle state */
;;;4798       tmpcr2 |= (OC_Config->OCIdleState << 4);
;;;4799       /* Set the Output N Idle state */
;;;4800       tmpcr2 |= (OC_Config->OCNIdleState << 4);
;;;4801     }
;;;4802   
;;;4803     /* Write to TIMx CR2 */
;;;4804     TIMx->CR2 = tmpcr2;
00156e  6044              STR      r4,[r0,#4]
;;;4805   
;;;4806     /* Write to TIMx CCMR2 */
;;;4807     TIMx->CCMR2 = tmpccmrx;
001570  61c2              STR      r2,[r0,#0x1c]
;;;4808   
;;;4809     /* Set the Capture Compare Register value */
;;;4810     TIMx->CCR3 = OC_Config->Pulse;
001572  684d              LDR      r5,[r1,#4]
001574  63c5              STR      r5,[r0,#0x3c]
;;;4811   
;;;4812     /* Write to TIMx CCER */
;;;4813     TIMx->CCER = tmpccer;
001576  6203              STR      r3,[r0,#0x20]
;;;4814   }
001578  bd30              POP      {r4,r5,pc}
;;;4815   
                          ENDP

                  TIM_OC2_SetConfig PROC
;;;4671     */
;;;4672   void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
00157a  b530              PUSH     {r4,r5,lr}
;;;4673   {
;;;4674     uint32_t tmpccmrx = 0;
00157c  2200              MOVS     r2,#0
;;;4675     uint32_t tmpccer = 0;
00157e  2300              MOVS     r3,#0
;;;4676     uint32_t tmpcr2 = 0;
001580  2400              MOVS     r4,#0
;;;4677   
;;;4678     /* Disable the Channel 2: Reset the CC2E Bit */
;;;4679     TIMx->CCER &= ~TIM_CCER_CC2E;
001582  6a05              LDR      r5,[r0,#0x20]
001584  f0250510          BIC      r5,r5,#0x10
001588  6205              STR      r5,[r0,#0x20]
;;;4680   
;;;4681     /* Get the TIMx CCER register value */
;;;4682     tmpccer = TIMx->CCER;
00158a  6a03              LDR      r3,[r0,#0x20]
;;;4683     /* Get the TIMx CR2 register value */
;;;4684     tmpcr2 =  TIMx->CR2;
00158c  6844              LDR      r4,[r0,#4]
;;;4685   
;;;4686     /* Get the TIMx CCMR1 register value */
;;;4687     tmpccmrx = TIMx->CCMR1;
00158e  6982              LDR      r2,[r0,#0x18]
;;;4688   
;;;4689     /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;4690     tmpccmrx &= ~TIM_CCMR1_OC2M;
001590  f42242e0          BIC      r2,r2,#0x7000
;;;4691     tmpccmrx &= ~TIM_CCMR1_CC2S;
001594  f4227240          BIC      r2,r2,#0x300
;;;4692   
;;;4693     /* Select the Output Compare Mode */
;;;4694     tmpccmrx |= (OC_Config->OCMode << 8);
001598  680d              LDR      r5,[r1,#0]
00159a  ea422205          ORR      r2,r2,r5,LSL #8
;;;4695   
;;;4696     /* Reset the Output Polarity level */
;;;4697     tmpccer &= ~TIM_CCER_CC2P;
00159e  f0230320          BIC      r3,r3,#0x20
;;;4698     /* Set the Output Compare Polarity */
;;;4699     tmpccer |= (OC_Config->OCPolarity << 4);
0015a2  688d              LDR      r5,[r1,#8]
0015a4  ea431305          ORR      r3,r3,r5,LSL #4
;;;4700   
;;;4701     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
;;;4702     {
;;;4703       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4704   
;;;4705       /* Reset the Output N Polarity level */
;;;4706       tmpccer &= ~TIM_CCER_CC2NP;
;;;4707       /* Set the Output N Polarity */
;;;4708       tmpccer |= (OC_Config->OCNPolarity << 4);
;;;4709       /* Reset the Output N State */
;;;4710       tmpccer &= ~TIM_CCER_CC2NE;
;;;4711   
;;;4712     }
;;;4713   
;;;4714     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4715     {
;;;4716       /* Check parameters */
;;;4717       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4718       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4719   
;;;4720       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4721       tmpcr2 &= ~TIM_CR2_OIS2;
;;;4722       tmpcr2 &= ~TIM_CR2_OIS2N;
;;;4723       /* Set the Output Idle state */
;;;4724       tmpcr2 |= (OC_Config->OCIdleState << 2);
;;;4725       /* Set the Output N Idle state */
;;;4726       tmpcr2 |= (OC_Config->OCNIdleState << 2);
;;;4727     }
;;;4728   
;;;4729     /* Write to TIMx CR2 */
;;;4730     TIMx->CR2 = tmpcr2;
0015a8  6044              STR      r4,[r0,#4]
;;;4731   
;;;4732     /* Write to TIMx CCMR1 */
;;;4733     TIMx->CCMR1 = tmpccmrx;
0015aa  6182              STR      r2,[r0,#0x18]
;;;4734   
;;;4735     /* Set the Capture Compare Register value */
;;;4736     TIMx->CCR2 = OC_Config->Pulse;
0015ac  684d              LDR      r5,[r1,#4]
0015ae  6385              STR      r5,[r0,#0x38]
;;;4737   
;;;4738     /* Write to TIMx CCER */
;;;4739     TIMx->CCER = tmpccer;
0015b0  6203              STR      r3,[r0,#0x20]
;;;4740   }
0015b2  bd30              POP      {r4,r5,pc}
                  |L1.5556|
                          DCD      TIM_DMAError
                          ENDP

                  TIM_OC1_SetConfig PROC
;;;4597     */
;;;4598   static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
0015b8  b530              PUSH     {r4,r5,lr}
;;;4599   {
;;;4600     uint32_t tmpccmrx = 0;
0015ba  2200              MOVS     r2,#0
;;;4601     uint32_t tmpccer = 0;
0015bc  2300              MOVS     r3,#0
;;;4602     uint32_t tmpcr2 = 0;
0015be  2400              MOVS     r4,#0
;;;4603   
;;;4604      /* Disable the Channel 1: Reset the CC1E Bit */
;;;4605     TIMx->CCER &= ~TIM_CCER_CC1E;
0015c0  6a05              LDR      r5,[r0,#0x20]
0015c2  f0250501          BIC      r5,r5,#1
0015c6  6205              STR      r5,[r0,#0x20]
;;;4606   
;;;4607     /* Get the TIMx CCER register value */
;;;4608     tmpccer = TIMx->CCER;
0015c8  6a03              LDR      r3,[r0,#0x20]
;;;4609     /* Get the TIMx CR2 register value */
;;;4610     tmpcr2 =  TIMx->CR2;
0015ca  6844              LDR      r4,[r0,#4]
;;;4611   
;;;4612     /* Get the TIMx CCMR1 register value */
;;;4613     tmpccmrx = TIMx->CCMR1;
0015cc  6982              LDR      r2,[r0,#0x18]
;;;4614   
;;;4615     /* Reset the Output Compare Mode Bits */
;;;4616     tmpccmrx &= ~TIM_CCMR1_OC1M;
0015ce  f0220270          BIC      r2,r2,#0x70
;;;4617     tmpccmrx &= ~TIM_CCMR1_CC1S;
0015d2  f0220203          BIC      r2,r2,#3
;;;4618     /* Select the Output Compare Mode */
;;;4619     tmpccmrx |= OC_Config->OCMode;
0015d6  680d              LDR      r5,[r1,#0]
0015d8  432a              ORRS     r2,r2,r5
;;;4620   
;;;4621     /* Reset the Output Polarity level */
;;;4622     tmpccer &= ~TIM_CCER_CC1P;
0015da  f0230302          BIC      r3,r3,#2
;;;4623     /* Set the Output Compare Polarity */
;;;4624     tmpccer |= OC_Config->OCPolarity;
0015de  688d              LDR      r5,[r1,#8]
0015e0  432b              ORRS     r3,r3,r5
;;;4625   
;;;4626     if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
;;;4627     {
;;;4628       /* Check parameters */
;;;4629       assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
;;;4630   
;;;4631       /* Reset the Output N Polarity level */
;;;4632       tmpccer &= ~TIM_CCER_CC1NP;
;;;4633       /* Set the Output N Polarity */
;;;4634       tmpccer |= OC_Config->OCNPolarity;
;;;4635       /* Reset the Output N State */
;;;4636       tmpccer &= ~TIM_CCER_CC1NE;
;;;4637     }
;;;4638   
;;;4639     if(IS_TIM_BREAK_INSTANCE(TIMx))
;;;4640     {
;;;4641       /* Check parameters */
;;;4642       assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
;;;4643       assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
;;;4644   
;;;4645       /* Reset the Output Compare and Output Compare N IDLE State */
;;;4646       tmpcr2 &= ~TIM_CR2_OIS1;
;;;4647       tmpcr2 &= ~TIM_CR2_OIS1N;
;;;4648       /* Set the Output Idle state */
;;;4649       tmpcr2 |= OC_Config->OCIdleState;
;;;4650       /* Set the Output N Idle state */
;;;4651       tmpcr2 |= OC_Config->OCNIdleState;
;;;4652     }
;;;4653     /* Write to TIMx CR2 */
;;;4654     TIMx->CR2 = tmpcr2;
0015e2  6044              STR      r4,[r0,#4]
;;;4655   
;;;4656     /* Write to TIMx CCMR1 */
;;;4657     TIMx->CCMR1 = tmpccmrx;
0015e4  6182              STR      r2,[r0,#0x18]
;;;4658   
;;;4659     /* Set the Capture Compare Register value */
;;;4660     TIMx->CCR1 = OC_Config->Pulse;
0015e6  684d              LDR      r5,[r1,#4]
0015e8  6345              STR      r5,[r0,#0x34]
;;;4661   
;;;4662     /* Write to TIMx CCER */
;;;4663     TIMx->CCER = tmpccer;
0015ea  6203              STR      r3,[r0,#0x20]
;;;4664   }
0015ec  bd30              POP      {r4,r5,pc}
;;;4665   
                          ENDP

                  HAL_TIM_OC_ConfigChannel PROC
;;;2914     */
;;;2915   HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
0015ee  b570              PUSH     {r4-r6,lr}
;;;2916   {
0015f0  4604              MOV      r4,r0
0015f2  460e              MOV      r6,r1
0015f4  4615              MOV      r5,r2
;;;2917     /* Check the parameters */
;;;2918     assert_param(IS_TIM_CHANNELS(Channel));
;;;2919     assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
;;;2920     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;2921   
;;;2922     /* Check input state */
;;;2923     __HAL_LOCK(htim);
0015f6  bf00              NOP      
0015f8  f8940038          LDRB     r0,[r4,#0x38]
0015fc  2801              CMP      r0,#1
0015fe  d101              BNE      |L1.5636|
001600  2002              MOVS     r0,#2
                  |L1.5634|
;;;2924   
;;;2925     htim->State = HAL_TIM_STATE_BUSY;
;;;2926   
;;;2927     switch (Channel)
;;;2928     {
;;;2929       case TIM_CHANNEL_1:
;;;2930       {
;;;2931         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2932         /* Configure the TIM Channel 1 in Output Compare */
;;;2933         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;2934       }
;;;2935       break;
;;;2936   
;;;2937       case TIM_CHANNEL_2:
;;;2938       {
;;;2939         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;2940         /* Configure the TIM Channel 2 in Output Compare */
;;;2941         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;2942       }
;;;2943       break;
;;;2944   
;;;2945       case TIM_CHANNEL_3:
;;;2946       {
;;;2947          assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;2948         /* Configure the TIM Channel 3 in Output Compare */
;;;2949         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;2950       }
;;;2951       break;
;;;2952   
;;;2953       case TIM_CHANNEL_4:
;;;2954       {
;;;2955         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;2956          /* Configure the TIM Channel 4 in Output Compare */
;;;2957          TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;2958       }
;;;2959       break;
;;;2960   
;;;2961       default:
;;;2962       break;
;;;2963     }
;;;2964     htim->State = HAL_TIM_STATE_READY;
;;;2965   
;;;2966     __HAL_UNLOCK(htim);
;;;2967   
;;;2968     return HAL_OK;
;;;2969   }
001602  bd70              POP      {r4-r6,pc}
                  |L1.5636|
001604  2001              MOVS     r0,#1                 ;2923
001606  f8840038          STRB     r0,[r4,#0x38]         ;2923
00160a  bf00              NOP                            ;2923
00160c  2002              MOVS     r0,#2                 ;2925
00160e  f8840039          STRB     r0,[r4,#0x39]         ;2925
001612  b135              CBZ      r5,|L1.5666|
001614  2d04              CMP      r5,#4                 ;2927
001616  d009              BEQ      |L1.5676|
001618  2d08              CMP      r5,#8                 ;2927
00161a  d00c              BEQ      |L1.5686|
00161c  2d0c              CMP      r5,#0xc               ;2927
00161e  d114              BNE      |L1.5706|
001620  e00e              B        |L1.5696|
                  |L1.5666|
001622  4631              MOV      r1,r6                 ;2933
001624  6820              LDR      r0,[r4,#0]            ;2933
001626  f7fffffe          BL       TIM_OC1_SetConfig
00162a  e00f              B        |L1.5708|
                  |L1.5676|
00162c  4631              MOV      r1,r6                 ;2941
00162e  6820              LDR      r0,[r4,#0]            ;2941
001630  f7fffffe          BL       TIM_OC2_SetConfig
001634  e00a              B        |L1.5708|
                  |L1.5686|
001636  4631              MOV      r1,r6                 ;2949
001638  6820              LDR      r0,[r4,#0]            ;2949
00163a  f7fffffe          BL       TIM_OC3_SetConfig
00163e  e005              B        |L1.5708|
                  |L1.5696|
001640  4631              MOV      r1,r6                 ;2957
001642  6820              LDR      r0,[r4,#0]            ;2957
001644  f7fffffe          BL       TIM_OC4_SetConfig
001648  e000              B        |L1.5708|
                  |L1.5706|
00164a  bf00              NOP                            ;2962
                  |L1.5708|
00164c  bf00              NOP                            ;2935
00164e  2001              MOVS     r0,#1                 ;2964
001650  f8840039          STRB     r0,[r4,#0x39]         ;2964
001654  bf00              NOP                            ;2966
001656  2000              MOVS     r0,#0                 ;2966
001658  f8840038          STRB     r0,[r4,#0x38]         ;2966
00165c  bf00              NOP                            ;2966
00165e  bf00              NOP                            ;2968
001660  e7cf              B        |L1.5634|
;;;2970   
                          ENDP

                  TIM_TI4_SetConfig PROC
;;;5246     */
;;;5247   static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
001662  b570              PUSH     {r4-r6,lr}
;;;5248                          uint32_t TIM_ICFilter)
;;;5249   {
001664  460c              MOV      r4,r1
001666  4615              MOV      r5,r2
;;;5250     uint32_t tmpccmr2 = 0;
001668  2100              MOVS     r1,#0
;;;5251     uint32_t tmpccer = 0;
00166a  2200              MOVS     r2,#0
;;;5252   
;;;5253     /* Disable the Channel 4: Reset the CC4E Bit */
;;;5254     TIMx->CCER &= ~TIM_CCER_CC4E;
00166c  6a06              LDR      r6,[r0,#0x20]
00166e  f4265680          BIC      r6,r6,#0x1000
001672  6206              STR      r6,[r0,#0x20]
;;;5255     tmpccmr2 = TIMx->CCMR2;
001674  69c1              LDR      r1,[r0,#0x1c]
;;;5256     tmpccer = TIMx->CCER;
001676  6a02              LDR      r2,[r0,#0x20]
;;;5257   
;;;5258     /* Select the Input */
;;;5259     tmpccmr2 &= ~TIM_CCMR2_CC4S;
001678  f4217140          BIC      r1,r1,#0x300
;;;5260     tmpccmr2 |= (TIM_ICSelection << 8);
00167c  ea412105          ORR      r1,r1,r5,LSL #8
;;;5261   
;;;5262     /* Set the filter */
;;;5263     tmpccmr2 &= ~TIM_CCMR2_IC4F;
001680  f4214170          BIC      r1,r1,#0xf000
;;;5264     tmpccmr2 |= ((TIM_ICFilter << 12) & TIM_CCMR2_IC4F);
001684  f44f4670          MOV      r6,#0xf000
001688  ea063603          AND      r6,r6,r3,LSL #12
00168c  4331              ORRS     r1,r1,r6
;;;5265   
;;;5266     /* Select the Polarity and set the CC4E Bit */
;;;5267     tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
00168e  f4224220          BIC      r2,r2,#0xa000
;;;5268     tmpccer |= ((TIM_ICPolarity << 12) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
001692  f44f4620          MOV      r6,#0xa000
001696  ea063604          AND      r6,r6,r4,LSL #12
00169a  4332              ORRS     r2,r2,r6
;;;5269   
;;;5270     /* Write to TIMx CCMR2 and CCER registers */
;;;5271     TIMx->CCMR2 = tmpccmr2;
00169c  61c1              STR      r1,[r0,#0x1c]
;;;5272     TIMx->CCER = tmpccer ;
00169e  6202              STR      r2,[r0,#0x20]
;;;5273   }
0016a0  bd70              POP      {r4-r6,pc}
;;;5274   
                          ENDP

                  TIM_TI3_SetConfig PROC
;;;5198     */
;;;5199   static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
0016a2  b570              PUSH     {r4-r6,lr}
;;;5200                          uint32_t TIM_ICFilter)
;;;5201   {
0016a4  460c              MOV      r4,r1
0016a6  4615              MOV      r5,r2
;;;5202     uint32_t tmpccmr2 = 0;
0016a8  2100              MOVS     r1,#0
;;;5203     uint32_t tmpccer = 0;
0016aa  2200              MOVS     r2,#0
;;;5204   
;;;5205     /* Disable the Channel 3: Reset the CC3E Bit */
;;;5206     TIMx->CCER &= ~TIM_CCER_CC3E;
0016ac  6a06              LDR      r6,[r0,#0x20]
0016ae  f4267680          BIC      r6,r6,#0x100
0016b2  6206              STR      r6,[r0,#0x20]
;;;5207     tmpccmr2 = TIMx->CCMR2;
0016b4  69c1              LDR      r1,[r0,#0x1c]
;;;5208     tmpccer = TIMx->CCER;
0016b6  6a02              LDR      r2,[r0,#0x20]
;;;5209   
;;;5210     /* Select the Input */
;;;5211     tmpccmr2 &= ~TIM_CCMR2_CC3S;
0016b8  f0210103          BIC      r1,r1,#3
;;;5212     tmpccmr2 |= TIM_ICSelection;
0016bc  4329              ORRS     r1,r1,r5
;;;5213   
;;;5214     /* Set the filter */
;;;5215     tmpccmr2 &= ~TIM_CCMR2_IC3F;
0016be  f02101f0          BIC      r1,r1,#0xf0
;;;5216     tmpccmr2 |= ((TIM_ICFilter << 4) & TIM_CCMR2_IC3F);
0016c2  26f0              MOVS     r6,#0xf0
0016c4  ea061603          AND      r6,r6,r3,LSL #4
0016c8  4331              ORRS     r1,r1,r6
;;;5217   
;;;5218     /* Select the Polarity and set the CC3E Bit */
;;;5219     tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
0016ca  f4226220          BIC      r2,r2,#0xa00
;;;5220     tmpccer |= ((TIM_ICPolarity << 8) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
0016ce  f44f6620          MOV      r6,#0xa00
0016d2  ea062604          AND      r6,r6,r4,LSL #8
0016d6  4332              ORRS     r2,r2,r6
;;;5221   
;;;5222     /* Write to TIMx CCMR2 and CCER registers */
;;;5223     TIMx->CCMR2 = tmpccmr2;
0016d8  61c1              STR      r1,[r0,#0x1c]
;;;5224     TIMx->CCER = tmpccer;
0016da  6202              STR      r2,[r0,#0x20]
;;;5225   }
0016dc  bd70              POP      {r4-r6,pc}
;;;5226   
                          ENDP

                  TIM_TI2_SetConfig PROC
;;;5115     */
;;;5116   static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
0016de  b570              PUSH     {r4-r6,lr}
;;;5117                          uint32_t TIM_ICFilter)
;;;5118   {
0016e0  460c              MOV      r4,r1
0016e2  4615              MOV      r5,r2
;;;5119     uint32_t tmpccmr1 = 0;
0016e4  2100              MOVS     r1,#0
;;;5120     uint32_t tmpccer = 0;
0016e6  2200              MOVS     r2,#0
;;;5121   
;;;5122     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5123     TIMx->CCER &= ~TIM_CCER_CC2E;
0016e8  6a06              LDR      r6,[r0,#0x20]
0016ea  f0260610          BIC      r6,r6,#0x10
0016ee  6206              STR      r6,[r0,#0x20]
;;;5124     tmpccmr1 = TIMx->CCMR1;
0016f0  6981              LDR      r1,[r0,#0x18]
;;;5125     tmpccer = TIMx->CCER;
0016f2  6a02              LDR      r2,[r0,#0x20]
;;;5126   
;;;5127     /* Select the Input */
;;;5128     tmpccmr1 &= ~TIM_CCMR1_CC2S;
0016f4  f4217140          BIC      r1,r1,#0x300
;;;5129     tmpccmr1 |= (TIM_ICSelection << 8);
0016f8  ea412105          ORR      r1,r1,r5,LSL #8
;;;5130   
;;;5131     /* Set the filter */
;;;5132     tmpccmr1 &= ~TIM_CCMR1_IC2F;
0016fc  f4214170          BIC      r1,r1,#0xf000
;;;5133     tmpccmr1 |= ((TIM_ICFilter << 12) & TIM_CCMR1_IC2F);
001700  f44f4670          MOV      r6,#0xf000
001704  ea063603          AND      r6,r6,r3,LSL #12
001708  4331              ORRS     r1,r1,r6
;;;5134   
;;;5135     /* Select the Polarity and set the CC2E Bit */
;;;5136     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
00170a  f02202a0          BIC      r2,r2,#0xa0
;;;5137     tmpccer |= ((TIM_ICPolarity << 4) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
00170e  26a0              MOVS     r6,#0xa0
001710  ea061604          AND      r6,r6,r4,LSL #4
001714  4332              ORRS     r2,r2,r6
;;;5138   
;;;5139     /* Write to TIMx CCMR1 and CCER registers */
;;;5140     TIMx->CCMR1 = tmpccmr1 ;
001716  6181              STR      r1,[r0,#0x18]
;;;5141     TIMx->CCER = tmpccer;
001718  6202              STR      r2,[r0,#0x20]
;;;5142   }
00171a  bd70              POP      {r4-r6,pc}
;;;5143   
                          ENDP

                  TIM_TI1_SetConfig PROC
;;;5025     */
;;;5026   void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
00171c  b570              PUSH     {r4-r6,lr}
;;;5027                          uint32_t TIM_ICFilter)
;;;5028   {
00171e  460c              MOV      r4,r1
001720  4615              MOV      r5,r2
;;;5029     uint32_t tmpccmr1 = 0;
001722  2100              MOVS     r1,#0
;;;5030     uint32_t tmpccer = 0;
001724  2200              MOVS     r2,#0
;;;5031   
;;;5032     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5033     TIMx->CCER &= ~TIM_CCER_CC1E;
001726  6a06              LDR      r6,[r0,#0x20]
001728  f0260601          BIC      r6,r6,#1
00172c  6206              STR      r6,[r0,#0x20]
;;;5034     tmpccmr1 = TIMx->CCMR1;
00172e  6981              LDR      r1,[r0,#0x18]
;;;5035     tmpccer = TIMx->CCER;
001730  6a02              LDR      r2,[r0,#0x20]
;;;5036   
;;;5037     /* Select the Input */
;;;5038     if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
001732  f1b04f80          CMP      r0,#0x40000000
001736  d005              BEQ      |L1.5956|
001738  4efd              LDR      r6,|L1.6960|
00173a  42b0              CMP      r0,r6
00173c  d002              BEQ      |L1.5956|
00173e  4efd              LDR      r6,|L1.6964|
001740  42b0              CMP      r0,r6
001742  d101              BNE      |L1.5960|
                  |L1.5956|
001744  2601              MOVS     r6,#1
001746  e000              B        |L1.5962|
                  |L1.5960|
001748  2600              MOVS     r6,#0
                  |L1.5962|
00174a  b11e              CBZ      r6,|L1.5972|
;;;5039     {
;;;5040       tmpccmr1 &= ~TIM_CCMR1_CC1S;
00174c  f0210103          BIC      r1,r1,#3
;;;5041       tmpccmr1 |= TIM_ICSelection;
001750  4329              ORRS     r1,r1,r5
001752  e001              B        |L1.5976|
                  |L1.5972|
;;;5042     }
;;;5043     else
;;;5044     {
;;;5045       tmpccmr1 |= TIM_CCMR1_CC1S_0;
001754  f0410101          ORR      r1,r1,#1
                  |L1.5976|
;;;5046     }
;;;5047   
;;;5048     /* Set the filter */
;;;5049     tmpccmr1 &= ~TIM_CCMR1_IC1F;
001758  f02101f0          BIC      r1,r1,#0xf0
;;;5050     tmpccmr1 |= ((TIM_ICFilter << 4) & TIM_CCMR1_IC1F);
00175c  26f0              MOVS     r6,#0xf0
00175e  ea061603          AND      r6,r6,r3,LSL #4
001762  4331              ORRS     r1,r1,r6
;;;5051   
;;;5052     /* Select the Polarity and set the CC1E Bit */
;;;5053     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
001764  f022020a          BIC      r2,r2,#0xa
;;;5054     tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
001768  f004060a          AND      r6,r4,#0xa
00176c  4332              ORRS     r2,r2,r6
;;;5055   
;;;5056     /* Write to TIMx CCMR1 and CCER registers */
;;;5057     TIMx->CCMR1 = tmpccmr1;
00176e  6181              STR      r1,[r0,#0x18]
;;;5058     TIMx->CCER = tmpccer;
001770  6202              STR      r2,[r0,#0x20]
;;;5059   }
001772  bd70              POP      {r4-r6,pc}
;;;5060   
                          ENDP

                  HAL_TIM_IC_ConfigChannel PROC
;;;2983     */
;;;2984   HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
001774  e92d41f0          PUSH     {r4-r8,lr}
;;;2985   {
001778  4604              MOV      r4,r0
00177a  460d              MOV      r5,r1
00177c  4616              MOV      r6,r2
;;;2986     /* Check the parameters */
;;;2987     assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;2988     assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
;;;2989     assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
;;;2990     assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
;;;2991     assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
;;;2992   
;;;2993     __HAL_LOCK(htim);
00177e  bf00              NOP      
001780  f8940038          LDRB     r0,[r4,#0x38]
001784  2801              CMP      r0,#1
001786  d102              BNE      |L1.6030|
001788  2002              MOVS     r0,#2
                  |L1.6026|
;;;2994   
;;;2995     htim->State = HAL_TIM_STATE_BUSY;
;;;2996   
;;;2997     if (Channel == TIM_CHANNEL_1)
;;;2998     {
;;;2999       /* TI1 Configuration */
;;;3000       TIM_TI1_SetConfig(htim->Instance,
;;;3001                  sConfig->ICPolarity,
;;;3002                  sConfig->ICSelection,
;;;3003                  sConfig->ICFilter);
;;;3004   
;;;3005       /* Reset the IC1PSC Bits */
;;;3006       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3007   
;;;3008       /* Set the IC1PSC value */
;;;3009       htim->Instance->CCMR1 |= sConfig->ICPrescaler;
;;;3010     }
;;;3011     else if (Channel == TIM_CHANNEL_2)
;;;3012     {
;;;3013       /* TI2 Configuration */
;;;3014       assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3015   
;;;3016       TIM_TI2_SetConfig(htim->Instance,
;;;3017                         sConfig->ICPolarity,
;;;3018                         sConfig->ICSelection,
;;;3019                         sConfig->ICFilter);
;;;3020   
;;;3021       /* Reset the IC2PSC Bits */
;;;3022       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3023   
;;;3024       /* Set the IC2PSC value */
;;;3025       htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8);
;;;3026     }
;;;3027     else if (Channel == TIM_CHANNEL_3)
;;;3028     {
;;;3029       /* TI3 Configuration */
;;;3030       assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3031   
;;;3032       TIM_TI3_SetConfig(htim->Instance,
;;;3033                  sConfig->ICPolarity,
;;;3034                  sConfig->ICSelection,
;;;3035                  sConfig->ICFilter);
;;;3036   
;;;3037       /* Reset the IC3PSC Bits */
;;;3038       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
;;;3039   
;;;3040       /* Set the IC3PSC value */
;;;3041       htim->Instance->CCMR2 |= sConfig->ICPrescaler;
;;;3042     }
;;;3043     else
;;;3044     {
;;;3045       /* TI4 Configuration */
;;;3046       assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3047   
;;;3048       TIM_TI4_SetConfig(htim->Instance,
;;;3049                  sConfig->ICPolarity,
;;;3050                  sConfig->ICSelection,
;;;3051                  sConfig->ICFilter);
;;;3052   
;;;3053       /* Reset the IC4PSC Bits */
;;;3054       htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
;;;3055   
;;;3056       /* Set the IC4PSC value */
;;;3057       htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8);
;;;3058     }
;;;3059   
;;;3060     htim->State = HAL_TIM_STATE_READY;
;;;3061   
;;;3062     __HAL_UNLOCK(htim);
;;;3063   
;;;3064     return HAL_OK;
;;;3065   }
00178a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6030|
00178e  2001              MOVS     r0,#1                 ;2993
001790  f8840038          STRB     r0,[r4,#0x38]         ;2993
001794  bf00              NOP                            ;2993
001796  2002              MOVS     r0,#2                 ;2995
001798  f8840039          STRB     r0,[r4,#0x39]         ;2995
00179c  b996              CBNZ     r6,|L1.6084|
00179e  68eb              LDR      r3,[r5,#0xc]          ;3000
0017a0  e9d51200          LDRD     r1,r2,[r5,#0]         ;3000
0017a4  6820              LDR      r0,[r4,#0]            ;3000
0017a6  f7fffffe          BL       TIM_TI1_SetConfig
0017aa  6820              LDR      r0,[r4,#0]            ;3006
0017ac  6980              LDR      r0,[r0,#0x18]         ;3006
0017ae  f020000c          BIC      r0,r0,#0xc            ;3006
0017b2  6821              LDR      r1,[r4,#0]            ;3006
0017b4  6188              STR      r0,[r1,#0x18]         ;3006
0017b6  6820              LDR      r0,[r4,#0]            ;3009
0017b8  6980              LDR      r0,[r0,#0x18]         ;3009
0017ba  68a9              LDR      r1,[r5,#8]            ;3009
0017bc  4308              ORRS     r0,r0,r1              ;3009
0017be  6821              LDR      r1,[r4,#0]            ;3009
0017c0  6188              STR      r0,[r1,#0x18]         ;3009
0017c2  e03d              B        |L1.6208|
                  |L1.6084|
0017c4  2e04              CMP      r6,#4                 ;3011
0017c6  d113              BNE      |L1.6128|
0017c8  68eb              LDR      r3,[r5,#0xc]          ;3016
0017ca  e9d51200          LDRD     r1,r2,[r5,#0]         ;3016
0017ce  6820              LDR      r0,[r4,#0]            ;3016
0017d0  f7fffffe          BL       TIM_TI2_SetConfig
0017d4  6820              LDR      r0,[r4,#0]            ;3022
0017d6  6980              LDR      r0,[r0,#0x18]         ;3022
0017d8  f4206040          BIC      r0,r0,#0xc00          ;3022
0017dc  6821              LDR      r1,[r4,#0]            ;3022
0017de  6188              STR      r0,[r1,#0x18]         ;3022
0017e0  6820              LDR      r0,[r4,#0]            ;3025
0017e2  6980              LDR      r0,[r0,#0x18]         ;3025
0017e4  68a9              LDR      r1,[r5,#8]            ;3025
0017e6  ea402001          ORR      r0,r0,r1,LSL #8       ;3025
0017ea  6821              LDR      r1,[r4,#0]            ;3025
0017ec  6188              STR      r0,[r1,#0x18]         ;3025
0017ee  e027              B        |L1.6208|
                  |L1.6128|
0017f0  2e08              CMP      r6,#8                 ;3027
0017f2  d112              BNE      |L1.6170|
0017f4  68eb              LDR      r3,[r5,#0xc]          ;3032
0017f6  e9d51200          LDRD     r1,r2,[r5,#0]         ;3032
0017fa  6820              LDR      r0,[r4,#0]            ;3032
0017fc  f7fffffe          BL       TIM_TI3_SetConfig
001800  6820              LDR      r0,[r4,#0]            ;3038
001802  69c0              LDR      r0,[r0,#0x1c]         ;3038
001804  f020000c          BIC      r0,r0,#0xc            ;3038
001808  6821              LDR      r1,[r4,#0]            ;3038
00180a  61c8              STR      r0,[r1,#0x1c]         ;3038
00180c  6820              LDR      r0,[r4,#0]            ;3041
00180e  69c0              LDR      r0,[r0,#0x1c]         ;3041
001810  68a9              LDR      r1,[r5,#8]            ;3041
001812  4308              ORRS     r0,r0,r1              ;3041
001814  6821              LDR      r1,[r4,#0]            ;3041
001816  61c8              STR      r0,[r1,#0x1c]         ;3041
001818  e012              B        |L1.6208|
                  |L1.6170|
00181a  68eb              LDR      r3,[r5,#0xc]          ;3048
00181c  e9d51200          LDRD     r1,r2,[r5,#0]         ;3048
001820  6820              LDR      r0,[r4,#0]            ;3048
001822  f7fffffe          BL       TIM_TI4_SetConfig
001826  6820              LDR      r0,[r4,#0]            ;3054
001828  69c0              LDR      r0,[r0,#0x1c]         ;3054
00182a  f4206040          BIC      r0,r0,#0xc00          ;3054
00182e  6821              LDR      r1,[r4,#0]            ;3054
001830  61c8              STR      r0,[r1,#0x1c]         ;3054
001832  6820              LDR      r0,[r4,#0]            ;3057
001834  69c0              LDR      r0,[r0,#0x1c]         ;3057
001836  68a9              LDR      r1,[r5,#8]            ;3057
001838  ea402001          ORR      r0,r0,r1,LSL #8       ;3057
00183c  6821              LDR      r1,[r4,#0]            ;3057
00183e  61c8              STR      r0,[r1,#0x1c]         ;3057
                  |L1.6208|
001840  2001              MOVS     r0,#1                 ;3060
001842  f8840039          STRB     r0,[r4,#0x39]         ;3060
001846  bf00              NOP                            ;3062
001848  2000              MOVS     r0,#0                 ;3062
00184a  f8840038          STRB     r0,[r4,#0x38]         ;3062
00184e  bf00              NOP                            ;3062
001850  bf00              NOP                            ;3064
001852  e79a              B        |L1.6026|
;;;3066   
                          ENDP

                  HAL_TIM_PWM_ConfigChannel PROC
;;;3079     */
;;;3080   HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
001854  b570              PUSH     {r4-r6,lr}
;;;3081   {
001856  4604              MOV      r4,r0
001858  460d              MOV      r5,r1
00185a  4616              MOV      r6,r2
;;;3082     __HAL_LOCK(htim);
00185c  bf00              NOP      
00185e  f8940038          LDRB     r0,[r4,#0x38]
001862  2801              CMP      r0,#1
001864  d101              BNE      |L1.6250|
001866  2002              MOVS     r0,#2
                  |L1.6248|
;;;3083   
;;;3084     /* Check the parameters */
;;;3085     assert_param(IS_TIM_CHANNELS(Channel));
;;;3086     assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
;;;3087     assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
;;;3088     assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
;;;3089   
;;;3090     htim->State = HAL_TIM_STATE_BUSY;
;;;3091   
;;;3092     switch (Channel)
;;;3093     {
;;;3094       case TIM_CHANNEL_1:
;;;3095       {
;;;3096         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3097         /* Configure the Channel 1 in PWM mode */
;;;3098         TIM_OC1_SetConfig(htim->Instance, sConfig);
;;;3099   
;;;3100         /* Set the Preload enable bit for channel1 */
;;;3101         htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
;;;3102   
;;;3103         /* Configure the Output Fast mode */
;;;3104         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
;;;3105         htim->Instance->CCMR1 |= sConfig->OCFastMode;
;;;3106       }
;;;3107       break;
;;;3108   
;;;3109       case TIM_CHANNEL_2:
;;;3110       {
;;;3111         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3112         /* Configure the Channel 2 in PWM mode */
;;;3113         TIM_OC2_SetConfig(htim->Instance, sConfig);
;;;3114   
;;;3115         /* Set the Preload enable bit for channel2 */
;;;3116         htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
;;;3117   
;;;3118         /* Configure the Output Fast mode */
;;;3119         htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
;;;3120         htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
;;;3121       }
;;;3122       break;
;;;3123   
;;;3124       case TIM_CHANNEL_3:
;;;3125       {
;;;3126         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3127         /* Configure the Channel 3 in PWM mode */
;;;3128         TIM_OC3_SetConfig(htim->Instance, sConfig);
;;;3129   
;;;3130         /* Set the Preload enable bit for channel3 */
;;;3131         htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
;;;3132   
;;;3133        /* Configure the Output Fast mode */
;;;3134         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
;;;3135         htim->Instance->CCMR2 |= sConfig->OCFastMode;
;;;3136       }
;;;3137       break;
;;;3138   
;;;3139       case TIM_CHANNEL_4:
;;;3140       {
;;;3141         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3142         /* Configure the Channel 4 in PWM mode */
;;;3143         TIM_OC4_SetConfig(htim->Instance, sConfig);
;;;3144   
;;;3145         /* Set the Preload enable bit for channel4 */
;;;3146         htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
;;;3147   
;;;3148        /* Configure the Output Fast mode */
;;;3149         htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
;;;3150         htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
;;;3151       }
;;;3152       break;
;;;3153   
;;;3154       default:
;;;3155       break;
;;;3156     }
;;;3157   
;;;3158     htim->State = HAL_TIM_STATE_READY;
;;;3159   
;;;3160     __HAL_UNLOCK(htim);
;;;3161   
;;;3162     return HAL_OK;
;;;3163   }
001868  bd70              POP      {r4-r6,pc}
                  |L1.6250|
00186a  2001              MOVS     r0,#1                 ;3082
00186c  f8840038          STRB     r0,[r4,#0x38]         ;3082
001870  bf00              NOP                            ;3082
001872  2002              MOVS     r0,#2                 ;3090
001874  f8840039          STRB     r0,[r4,#0x39]         ;3090
001878  b136              CBZ      r6,|L1.6280|
00187a  2e04              CMP      r6,#4                 ;3092
00187c  d01b              BEQ      |L1.6326|
00187e  2e08              CMP      r6,#8                 ;3092
001880  d031              BEQ      |L1.6374|
001882  2e0c              CMP      r6,#0xc               ;3092
001884  d15e              BNE      |L1.6468|
001886  e045              B        |L1.6420|
                  |L1.6280|
001888  4629              MOV      r1,r5                 ;3098
00188a  6820              LDR      r0,[r4,#0]            ;3098
00188c  f7fffffe          BL       TIM_OC1_SetConfig
001890  6820              LDR      r0,[r4,#0]            ;3101
001892  6980              LDR      r0,[r0,#0x18]         ;3101
001894  f0400008          ORR      r0,r0,#8              ;3101
001898  6821              LDR      r1,[r4,#0]            ;3101
00189a  6188              STR      r0,[r1,#0x18]         ;3101
00189c  6820              LDR      r0,[r4,#0]            ;3104
00189e  6980              LDR      r0,[r0,#0x18]         ;3104
0018a0  f0200004          BIC      r0,r0,#4              ;3104
0018a4  6821              LDR      r1,[r4,#0]            ;3104
0018a6  6188              STR      r0,[r1,#0x18]         ;3104
0018a8  6820              LDR      r0,[r4,#0]            ;3105
0018aa  6980              LDR      r0,[r0,#0x18]         ;3105
0018ac  6929              LDR      r1,[r5,#0x10]         ;3105
0018ae  4308              ORRS     r0,r0,r1              ;3105
0018b0  6821              LDR      r1,[r4,#0]            ;3105
0018b2  6188              STR      r0,[r1,#0x18]         ;3105
0018b4  e047              B        |L1.6470|
                  |L1.6326|
0018b6  4629              MOV      r1,r5                 ;3113
0018b8  6820              LDR      r0,[r4,#0]            ;3113
0018ba  f7fffffe          BL       TIM_OC2_SetConfig
0018be  6820              LDR      r0,[r4,#0]            ;3116
0018c0  6980              LDR      r0,[r0,#0x18]         ;3116
0018c2  f4406000          ORR      r0,r0,#0x800          ;3116
0018c6  6821              LDR      r1,[r4,#0]            ;3116
0018c8  6188              STR      r0,[r1,#0x18]         ;3116
0018ca  6820              LDR      r0,[r4,#0]            ;3119
0018cc  6980              LDR      r0,[r0,#0x18]         ;3119
0018ce  f4206080          BIC      r0,r0,#0x400          ;3119
0018d2  6821              LDR      r1,[r4,#0]            ;3119
0018d4  6188              STR      r0,[r1,#0x18]         ;3119
0018d6  6820              LDR      r0,[r4,#0]            ;3120
0018d8  6980              LDR      r0,[r0,#0x18]         ;3120
0018da  6929              LDR      r1,[r5,#0x10]         ;3120
0018dc  ea402001          ORR      r0,r0,r1,LSL #8       ;3120
0018e0  6821              LDR      r1,[r4,#0]            ;3120
0018e2  6188              STR      r0,[r1,#0x18]         ;3120
0018e4  e02f              B        |L1.6470|
                  |L1.6374|
0018e6  4629              MOV      r1,r5                 ;3128
0018e8  6820              LDR      r0,[r4,#0]            ;3128
0018ea  f7fffffe          BL       TIM_OC3_SetConfig
0018ee  6820              LDR      r0,[r4,#0]            ;3131
0018f0  69c0              LDR      r0,[r0,#0x1c]         ;3131
0018f2  f0400008          ORR      r0,r0,#8              ;3131
0018f6  6821              LDR      r1,[r4,#0]            ;3131
0018f8  61c8              STR      r0,[r1,#0x1c]         ;3131
0018fa  6820              LDR      r0,[r4,#0]            ;3134
0018fc  69c0              LDR      r0,[r0,#0x1c]         ;3134
0018fe  f0200004          BIC      r0,r0,#4              ;3134
001902  6821              LDR      r1,[r4,#0]            ;3134
001904  61c8              STR      r0,[r1,#0x1c]         ;3134
001906  6820              LDR      r0,[r4,#0]            ;3135
001908  69c0              LDR      r0,[r0,#0x1c]         ;3135
00190a  6929              LDR      r1,[r5,#0x10]         ;3135
00190c  4308              ORRS     r0,r0,r1              ;3135
00190e  6821              LDR      r1,[r4,#0]            ;3135
001910  61c8              STR      r0,[r1,#0x1c]         ;3135
001912  e018              B        |L1.6470|
                  |L1.6420|
001914  4629              MOV      r1,r5                 ;3143
001916  6820              LDR      r0,[r4,#0]            ;3143
001918  f7fffffe          BL       TIM_OC4_SetConfig
00191c  6820              LDR      r0,[r4,#0]            ;3146
00191e  69c0              LDR      r0,[r0,#0x1c]         ;3146
001920  f4406000          ORR      r0,r0,#0x800          ;3146
001924  6821              LDR      r1,[r4,#0]            ;3146
001926  61c8              STR      r0,[r1,#0x1c]         ;3146
001928  6820              LDR      r0,[r4,#0]            ;3149
00192a  69c0              LDR      r0,[r0,#0x1c]         ;3149
00192c  f4206080          BIC      r0,r0,#0x400          ;3149
001930  6821              LDR      r1,[r4,#0]            ;3149
001932  61c8              STR      r0,[r1,#0x1c]         ;3149
001934  6820              LDR      r0,[r4,#0]            ;3150
001936  69c0              LDR      r0,[r0,#0x1c]         ;3150
001938  6929              LDR      r1,[r5,#0x10]         ;3150
00193a  ea402001          ORR      r0,r0,r1,LSL #8       ;3150
00193e  6821              LDR      r1,[r4,#0]            ;3150
001940  61c8              STR      r0,[r1,#0x1c]         ;3150
001942  e000              B        |L1.6470|
                  |L1.6468|
001944  bf00              NOP                            ;3155
                  |L1.6470|
001946  bf00              NOP                            ;3107
001948  2001              MOVS     r0,#1                 ;3158
00194a  f8840039          STRB     r0,[r4,#0x39]         ;3158
00194e  bf00              NOP                            ;3160
001950  2000              MOVS     r0,#0                 ;3160
001952  f8840038          STRB     r0,[r4,#0x38]         ;3160
001956  bf00              NOP                            ;3160
001958  bf00              NOP                            ;3162
00195a  e785              B        |L1.6248|
;;;3164   
                          ENDP

                  HAL_TIM_OnePulse_ConfigChannel PROC
;;;3179     */
;;;3180   HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
00195c  b5f0              PUSH     {r4-r7,lr}
;;;3181   {
00195e  b087              SUB      sp,sp,#0x1c
001960  4604              MOV      r4,r0
001962  460d              MOV      r5,r1
001964  4616              MOV      r6,r2
001966  461f              MOV      r7,r3
;;;3182     TIM_OC_InitTypeDef temp1;
;;;3183   
;;;3184     /* Check the parameters */
;;;3185     assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
;;;3186     assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
;;;3187   
;;;3188     if(OutputChannel != InputChannel)
001968  42be              CMP      r6,r7
00196a  d078              BEQ      |L1.6750|
;;;3189     {
;;;3190     __HAL_LOCK(htim);
00196c  bf00              NOP      
00196e  f8940038          LDRB     r0,[r4,#0x38]
001972  2801              CMP      r0,#1
001974  d102              BNE      |L1.6524|
001976  2002              MOVS     r0,#2
                  |L1.6520|
;;;3191   
;;;3192     htim->State = HAL_TIM_STATE_BUSY;
;;;3193   
;;;3194     /* Extract the Ouput compare configuration from sConfig structure */
;;;3195     temp1.OCMode = sConfig->OCMode;
;;;3196     temp1.Pulse = sConfig->Pulse;
;;;3197     temp1.OCPolarity = sConfig->OCPolarity;
;;;3198     temp1.OCNPolarity = sConfig->OCNPolarity;
;;;3199     temp1.OCIdleState = sConfig->OCIdleState;
;;;3200     temp1.OCNIdleState = sConfig->OCNIdleState;
;;;3201   
;;;3202       switch (OutputChannel)
;;;3203     {
;;;3204       case TIM_CHANNEL_1:
;;;3205       {
;;;3206           assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3207   
;;;3208         TIM_OC1_SetConfig(htim->Instance, &temp1);
;;;3209       }
;;;3210       break;
;;;3211       case TIM_CHANNEL_2:
;;;3212       {
;;;3213           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3214   
;;;3215         TIM_OC2_SetConfig(htim->Instance, &temp1);
;;;3216       }
;;;3217       break;
;;;3218       default:
;;;3219       break;
;;;3220     }
;;;3221     switch (InputChannel)
;;;3222     {
;;;3223       case TIM_CHANNEL_1:
;;;3224       {
;;;3225         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;3226   
;;;3227         TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3228                           sConfig->ICSelection, sConfig->ICFilter);
;;;3229   
;;;3230         /* Reset the IC1PSC Bits */
;;;3231       htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
;;;3232   
;;;3233         /* Select the Trigger source */
;;;3234           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3235         htim->Instance->SMCR |= TIM_TS_TI1FP1;
;;;3236   
;;;3237         /* Select the Slave Mode */
;;;3238           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3239         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3240       }
;;;3241       break;
;;;3242       case TIM_CHANNEL_2:
;;;3243       {
;;;3244         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3245   
;;;3246         TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
;;;3247                    sConfig->ICSelection, sConfig->ICFilter);
;;;3248   
;;;3249         /* Reset the IC2PSC Bits */
;;;3250           htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
;;;3251   
;;;3252         /* Select the Trigger source */
;;;3253           htim->Instance->SMCR &= ~TIM_SMCR_TS;
;;;3254         htim->Instance->SMCR |= TIM_TS_TI2FP2;
;;;3255   
;;;3256         /* Select the Slave Mode */
;;;3257           htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3258         htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
;;;3259       }
;;;3260       break;
;;;3261   
;;;3262       default:
;;;3263       break;
;;;3264     }
;;;3265   
;;;3266     htim->State = HAL_TIM_STATE_READY;
;;;3267   
;;;3268     __HAL_UNLOCK(htim);
;;;3269   
;;;3270     return HAL_OK;
;;;3271   }
;;;3272     else
;;;3273     {
;;;3274       return HAL_ERROR;
;;;3275     }
;;;3276   }
001978  b007              ADD      sp,sp,#0x1c
00197a  bdf0              POP      {r4-r7,pc}
                  |L1.6524|
00197c  2001              MOVS     r0,#1                 ;3190
00197e  f8840038          STRB     r0,[r4,#0x38]         ;3190
001982  bf00              NOP                            ;3190
001984  2002              MOVS     r0,#2                 ;3192
001986  f8840039          STRB     r0,[r4,#0x39]         ;3192
00198a  6828              LDR      r0,[r5,#0]            ;3195
00198c  9000              STR      r0,[sp,#0]            ;3195
00198e  6868              LDR      r0,[r5,#4]            ;3196
001990  9001              STR      r0,[sp,#4]            ;3196
001992  68a8              LDR      r0,[r5,#8]            ;3197
001994  9002              STR      r0,[sp,#8]            ;3197
001996  68e8              LDR      r0,[r5,#0xc]          ;3198
001998  9003              STR      r0,[sp,#0xc]          ;3198
00199a  6928              LDR      r0,[r5,#0x10]         ;3199
00199c  9005              STR      r0,[sp,#0x14]         ;3199
00199e  6968              LDR      r0,[r5,#0x14]         ;3200
0019a0  9006              STR      r0,[sp,#0x18]         ;3200
0019a2  b116              CBZ      r6,|L1.6570|
0019a4  2e04              CMP      r6,#4                 ;3202
0019a6  d10a              BNE      |L1.6590|
0019a8  e004              B        |L1.6580|
                  |L1.6570|
0019aa  4669              MOV      r1,sp                 ;3208
0019ac  6820              LDR      r0,[r4,#0]            ;3208
0019ae  f7fffffe          BL       TIM_OC1_SetConfig
0019b2  e005              B        |L1.6592|
                  |L1.6580|
0019b4  4669              MOV      r1,sp                 ;3215
0019b6  6820              LDR      r0,[r4,#0]            ;3215
0019b8  f7fffffe          BL       TIM_OC2_SetConfig
0019bc  e000              B        |L1.6592|
                  |L1.6590|
0019be  bf00              NOP                            ;3219
                  |L1.6592|
0019c0  bf00              NOP                            ;3210
0019c2  b117              CBZ      r7,|L1.6602|
0019c4  2f04              CMP      r7,#4                 ;3221
0019c6  d14b              BNE      |L1.6752|
0019c8  e024              B        |L1.6676|
                  |L1.6602|
0019ca  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3227
0019ce  69a9              LDR      r1,[r5,#0x18]         ;3227
0019d0  6820              LDR      r0,[r4,#0]            ;3227
0019d2  f7fffffe          BL       TIM_TI1_SetConfig
0019d6  6820              LDR      r0,[r4,#0]            ;3231
0019d8  6980              LDR      r0,[r0,#0x18]         ;3231
0019da  f020000c          BIC      r0,r0,#0xc            ;3231
0019de  6821              LDR      r1,[r4,#0]            ;3231
0019e0  6188              STR      r0,[r1,#0x18]         ;3231
0019e2  6820              LDR      r0,[r4,#0]            ;3234
0019e4  6880              LDR      r0,[r0,#8]            ;3234
0019e6  f0200070          BIC      r0,r0,#0x70           ;3234
0019ea  6821              LDR      r1,[r4,#0]            ;3234
0019ec  6088              STR      r0,[r1,#8]            ;3234
0019ee  6820              LDR      r0,[r4,#0]            ;3235
0019f0  6880              LDR      r0,[r0,#8]            ;3235
0019f2  f0400050          ORR      r0,r0,#0x50           ;3235
0019f6  6821              LDR      r1,[r4,#0]            ;3235
0019f8  6088              STR      r0,[r1,#8]            ;3235
0019fa  6820              LDR      r0,[r4,#0]            ;3238
0019fc  6880              LDR      r0,[r0,#8]            ;3238
0019fe  f0200007          BIC      r0,r0,#7              ;3238
001a02  6821              LDR      r1,[r4,#0]            ;3238
001a04  6088              STR      r0,[r1,#8]            ;3238
001a06  6820              LDR      r0,[r4,#0]            ;3239
001a08  6880              LDR      r0,[r0,#8]            ;3239
001a0a  f0400006          ORR      r0,r0,#6              ;3239
001a0e  6821              LDR      r1,[r4,#0]            ;3239
001a10  6088              STR      r0,[r1,#8]            ;3239
001a12  e026              B        |L1.6754|
                  |L1.6676|
001a14  e9d52307          LDRD     r2,r3,[r5,#0x1c]      ;3246
001a18  69a9              LDR      r1,[r5,#0x18]         ;3246
001a1a  6820              LDR      r0,[r4,#0]            ;3246
001a1c  f7fffffe          BL       TIM_TI2_SetConfig
001a20  6820              LDR      r0,[r4,#0]            ;3250
001a22  6980              LDR      r0,[r0,#0x18]         ;3250
001a24  f4206040          BIC      r0,r0,#0xc00          ;3250
001a28  6821              LDR      r1,[r4,#0]            ;3250
001a2a  6188              STR      r0,[r1,#0x18]         ;3250
001a2c  6820              LDR      r0,[r4,#0]            ;3253
001a2e  6880              LDR      r0,[r0,#8]            ;3253
001a30  f0200070          BIC      r0,r0,#0x70           ;3253
001a34  6821              LDR      r1,[r4,#0]            ;3253
001a36  6088              STR      r0,[r1,#8]            ;3253
001a38  6820              LDR      r0,[r4,#0]            ;3254
001a3a  6880              LDR      r0,[r0,#8]            ;3254
001a3c  f0400060          ORR      r0,r0,#0x60           ;3254
001a40  6821              LDR      r1,[r4,#0]            ;3254
001a42  6088              STR      r0,[r1,#8]            ;3254
001a44  6820              LDR      r0,[r4,#0]            ;3257
001a46  6880              LDR      r0,[r0,#8]            ;3257
001a48  f0200007          BIC      r0,r0,#7              ;3257
001a4c  6821              LDR      r1,[r4,#0]            ;3257
001a4e  6088              STR      r0,[r1,#8]            ;3257
001a50  6820              LDR      r0,[r4,#0]            ;3258
001a52  6880              LDR      r0,[r0,#8]            ;3258
001a54  f0400006          ORR      r0,r0,#6              ;3258
001a58  6821              LDR      r1,[r4,#0]            ;3258
001a5a  6088              STR      r0,[r1,#8]            ;3258
001a5c  e001              B        |L1.6754|
                  |L1.6750|
001a5e  e00a              B        |L1.6774|
                  |L1.6752|
001a60  bf00              NOP                            ;3263
                  |L1.6754|
001a62  bf00              NOP                            ;3241
001a64  2001              MOVS     r0,#1                 ;3266
001a66  f8840039          STRB     r0,[r4,#0x39]         ;3266
001a6a  bf00              NOP                            ;3268
001a6c  2000              MOVS     r0,#0                 ;3268
001a6e  f8840038          STRB     r0,[r4,#0x38]         ;3268
001a72  bf00              NOP                            ;3268
001a74  e780              B        |L1.6520|
                  |L1.6774|
001a76  2001              MOVS     r0,#1                 ;3274
001a78  e77e              B        |L1.6520|
;;;3277   
                          ENDP

                  TIM_DMATriggerCplt PROC
;;;4537     */
;;;4538   static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
001a7a  b570              PUSH     {r4-r6,lr}
;;;4539   {
001a7c  4604              MOV      r4,r0
;;;4540     TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
001a7e  6a65              LDR      r5,[r4,#0x24]
;;;4541   
;;;4542     htim->State= HAL_TIM_STATE_READY;
001a80  2001              MOVS     r0,#1
001a82  f8850039          STRB     r0,[r5,#0x39]
;;;4543   
;;;4544     HAL_TIM_TriggerCallback(htim);
001a86  4628              MOV      r0,r5
001a88  f7fffffe          BL       HAL_TIM_TriggerCallback
;;;4545   }
001a8c  bd70              POP      {r4-r6,pc}
;;;4546   
                          ENDP

                  HAL_TIM_DMABurst_WriteStart PROC
;;;3315     */
;;;3316   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
001a8e  e92d41f0          PUSH     {r4-r8,lr}
;;;3317                                                 uint32_t* BurstBuffer, uint32_t  BurstLength)
;;;3318   {
001a92  4604              MOV      r4,r0
001a94  4688              MOV      r8,r1
001a96  4616              MOV      r6,r2
001a98  461f              MOV      r7,r3
001a9a  9d06              LDR      r5,[sp,#0x18]
;;;3319     /* Check the parameters */
;;;3320     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3321     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3322     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3323     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3324   
;;;3325     if((htim->State == HAL_TIM_STATE_BUSY))
001a9c  f8940039          LDRB     r0,[r4,#0x39]
001aa0  2802              CMP      r0,#2
001aa2  d101              BNE      |L1.6824|
                  |L1.6820|
;;;3326     {
;;;3327        return HAL_BUSY;
;;;3328     }
;;;3329     else if((htim->State == HAL_TIM_STATE_READY))
;;;3330     {
;;;3331       if((BurstBuffer == 0 ) && (BurstLength > 0))
;;;3332       {
;;;3333         return HAL_ERROR;
;;;3334       }
;;;3335       else
;;;3336       {
;;;3337         htim->State = HAL_TIM_STATE_BUSY;
;;;3338       }
;;;3339     }
;;;3340     switch(BurstRequestSrc)
;;;3341     {
;;;3342       case TIM_DMA_UPDATE:
;;;3343       {
;;;3344         /* Set the DMA Period elapsed callback */
;;;3345         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3346   
;;;3347         /* Set the DMA error callback */
;;;3348         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3349   
;;;3350         /* Enable the DMA channel */
;;;3351         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3352       }
;;;3353       break;
;;;3354       case TIM_DMA_CC1:
;;;3355       {
;;;3356         /* Set the DMA Period elapsed callback */
;;;3357         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3358   
;;;3359         /* Set the DMA error callback */
;;;3360         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3361   
;;;3362         /* Enable the DMA channel */
;;;3363         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3364       }
;;;3365       break;
;;;3366       case TIM_DMA_CC2:
;;;3367       {
;;;3368         /* Set the DMA Period elapsed callback */
;;;3369         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3370   
;;;3371         /* Set the DMA error callback */
;;;3372         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3373   
;;;3374         /* Enable the DMA channel */
;;;3375         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3376       }
;;;3377       break;
;;;3378       case TIM_DMA_CC3:
;;;3379       {
;;;3380         /* Set the DMA Period elapsed callback */
;;;3381         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3382   
;;;3383         /* Set the DMA error callback */
;;;3384         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3385   
;;;3386         /* Enable the DMA channel */
;;;3387         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3388       }
;;;3389       break;
;;;3390       case TIM_DMA_CC4:
;;;3391       {
;;;3392         /* Set the DMA Period elapsed callback */
;;;3393         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
;;;3394   
;;;3395         /* Set the DMA error callback */
;;;3396         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3397   
;;;3398         /* Enable the DMA channel */
;;;3399         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3400       }
;;;3401       break;
;;;3402       case TIM_DMA_COM:
;;;3403       {
;;;3404         /* Set the DMA Period elapsed callback */
;;;3405         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3406   
;;;3407         /* Set the DMA error callback */
;;;3408         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3409   
;;;3410         /* Enable the DMA channel */
;;;3411         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3412       }
;;;3413       break;
;;;3414       case TIM_DMA_TRIGGER:
;;;3415       {
;;;3416         /* Set the DMA Period elapsed callback */
;;;3417         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3418   
;;;3419         /* Set the DMA error callback */
;;;3420         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3421   
;;;3422         /* Enable the DMA channel */
;;;3423         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8) + 1);
;;;3424       }
;;;3425       break;
;;;3426       default:
;;;3427       break;
;;;3428     }
;;;3429      /* configure the DMA Burst Mode */
;;;3430      htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3431   
;;;3432      /* Enable the TIM DMA Request */
;;;3433      __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3434   
;;;3435      htim->State = HAL_TIM_STATE_READY;
;;;3436   
;;;3437     /* Return function status */
;;;3438     return HAL_OK;
;;;3439   }
001aa4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.6824|
001aa8  f8940039          LDRB     r0,[r4,#0x39]         ;3329
001aac  2801              CMP      r0,#1                 ;3329
001aae  d105              BNE      |L1.6844|
001ab0  b90f              CBNZ     r7,|L1.6838|
001ab2  b105              CBZ      r5,|L1.6838|
001ab4  e7f6              B        |L1.6820|
                  |L1.6838|
001ab6  2002              MOVS     r0,#2                 ;3337
001ab8  f8840039          STRB     r0,[r4,#0x39]         ;3337
                  |L1.6844|
001abc  f5b66f00          CMP      r6,#0x800             ;3340
001ac0  d051              BEQ      |L1.7014|
001ac2  dc09              BGT      |L1.6872|
001ac4  f5b67f80          CMP      r6,#0x100             ;3340
001ac8  d010              BEQ      |L1.6892|
001aca  f5b67f00          CMP      r6,#0x200             ;3340
001ace  d01e              BEQ      |L1.6926|
001ad0  f5b66f80          CMP      r6,#0x400             ;3340
                  |L1.6868|
001ad4  d17a              BNE      |L1.7116|
001ad6  e035              B        |L1.6980|
                  |L1.6872|
001ad8  f5b65f80          CMP      r6,#0x1000            ;3340
001adc  d054              BEQ      |L1.7048|
001ade  f5b65f00          CMP      r6,#0x2000            ;3340
001ae2  d062              BEQ      |L1.7082|
001ae4  f5b64f80          CMP      r6,#0x4000            ;3340
001ae8  d1f4              BNE      |L1.6868|
001aea  e070              B        |L1.7118|
                  |L1.6892|
001aec  4812              LDR      r0,|L1.6968|
001aee  69e1              LDR      r1,[r4,#0x1c]         ;3345
001af0  6288              STR      r0,[r1,#0x28]         ;3345
001af2  4812              LDR      r0,|L1.6972|
001af4  69e1              LDR      r1,[r4,#0x1c]         ;3348
001af6  6308              STR      r0,[r1,#0x30]         ;3348
001af8  2101              MOVS     r1,#1                 ;3351
001afa  eb012315          ADD      r3,r1,r5,LSR #8       ;3351
001afe  6821              LDR      r1,[r4,#0]            ;3351
001b00  f101024c          ADD      r2,r1,#0x4c           ;3351
001b04  4639              MOV      r1,r7                 ;3351
001b06  69e0              LDR      r0,[r4,#0x1c]         ;3351
001b08  f7fffffe          BL       HAL_DMA_Start_IT
001b0c  e071              B        |L1.7154|
                  |L1.6926|
001b0e  490c              LDR      r1,|L1.6976|
001b10  6a20              LDR      r0,[r4,#0x20]         ;3357
001b12  6281              STR      r1,[r0,#0x28]         ;3357
001b14  4909              LDR      r1,|L1.6972|
001b16  6a20              LDR      r0,[r4,#0x20]         ;3360
001b18  6301              STR      r1,[r0,#0x30]         ;3360
001b1a  2101              MOVS     r1,#1                 ;3363
001b1c  eb012315          ADD      r3,r1,r5,LSR #8       ;3363
001b20  6821              LDR      r1,[r4,#0]            ;3363
001b22  f101024c          ADD      r2,r1,#0x4c           ;3363
001b26  4639              MOV      r1,r7                 ;3363
001b28  6a20              LDR      r0,[r4,#0x20]         ;3363
001b2a  f7fffffe          BL       HAL_DMA_Start_IT
001b2e  e060              B        |L1.7154|
                  |L1.6960|
                          DCD      0x40000400
                  |L1.6964|
                          DCD      0x40000800
                  |L1.6968|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L1.6972|
                          DCD      TIM_DMAError
                  |L1.6976|
                          DCD      TIM_DMADelayPulseCplt
                  |L1.6980|
001b44  49f8              LDR      r1,|L1.7976|
001b46  6a60              LDR      r0,[r4,#0x24]         ;3369
001b48  6281              STR      r1,[r0,#0x28]         ;3369
001b4a  49f8              LDR      r1,|L1.7980|
001b4c  6a60              LDR      r0,[r4,#0x24]         ;3372
001b4e  6301              STR      r1,[r0,#0x30]         ;3372
001b50  2101              MOVS     r1,#1                 ;3375
001b52  eb012315          ADD      r3,r1,r5,LSR #8       ;3375
001b56  6821              LDR      r1,[r4,#0]            ;3375
001b58  f101024c          ADD      r2,r1,#0x4c           ;3375
001b5c  4639              MOV      r1,r7                 ;3375
001b5e  6a60              LDR      r0,[r4,#0x24]         ;3375
001b60  f7fffffe          BL       HAL_DMA_Start_IT
001b64  e045              B        |L1.7154|
                  |L1.7014|
001b66  49f0              LDR      r1,|L1.7976|
001b68  6aa0              LDR      r0,[r4,#0x28]         ;3381
001b6a  6281              STR      r1,[r0,#0x28]         ;3381
001b6c  49ef              LDR      r1,|L1.7980|
001b6e  6aa0              LDR      r0,[r4,#0x28]         ;3384
001b70  6301              STR      r1,[r0,#0x30]         ;3384
001b72  2101              MOVS     r1,#1                 ;3387
001b74  eb012315          ADD      r3,r1,r5,LSR #8       ;3387
001b78  6821              LDR      r1,[r4,#0]            ;3387
001b7a  f101024c          ADD      r2,r1,#0x4c           ;3387
001b7e  4639              MOV      r1,r7                 ;3387
001b80  6aa0              LDR      r0,[r4,#0x28]         ;3387
001b82  f7fffffe          BL       HAL_DMA_Start_IT
001b86  e034              B        |L1.7154|
                  |L1.7048|
001b88  49e7              LDR      r1,|L1.7976|
001b8a  6ae0              LDR      r0,[r4,#0x2c]         ;3393
001b8c  6281              STR      r1,[r0,#0x28]         ;3393
001b8e  49e7              LDR      r1,|L1.7980|
001b90  6ae0              LDR      r0,[r4,#0x2c]         ;3396
001b92  6301              STR      r1,[r0,#0x30]         ;3396
001b94  2101              MOVS     r1,#1                 ;3399
001b96  eb012315          ADD      r3,r1,r5,LSR #8       ;3399
001b9a  6821              LDR      r1,[r4,#0]            ;3399
001b9c  f101024c          ADD      r2,r1,#0x4c           ;3399
001ba0  4639              MOV      r1,r7                 ;3399
001ba2  6ae0              LDR      r0,[r4,#0x2c]         ;3399
001ba4  f7fffffe          BL       HAL_DMA_Start_IT
001ba8  e023              B        |L1.7154|
                  |L1.7082|
001baa  49e1              LDR      r1,|L1.7984|
001bac  6b20              LDR      r0,[r4,#0x30]         ;3405
001bae  6281              STR      r1,[r0,#0x28]         ;3405
001bb0  49de              LDR      r1,|L1.7980|
001bb2  6b20              LDR      r0,[r4,#0x30]         ;3408
001bb4  6301              STR      r1,[r0,#0x30]         ;3408
001bb6  2101              MOVS     r1,#1                 ;3411
001bb8  eb012315          ADD      r3,r1,r5,LSR #8       ;3411
001bbc  6821              LDR      r1,[r4,#0]            ;3411
001bbe  f101024c          ADD      r2,r1,#0x4c           ;3411
001bc2  4639              MOV      r1,r7                 ;3411
001bc4  6b20              LDR      r0,[r4,#0x30]         ;3411
001bc6  f7fffffe          BL       HAL_DMA_Start_IT
001bca  e012              B        |L1.7154|
                  |L1.7116|
001bcc  e010              B        |L1.7152|
                  |L1.7118|
001bce  49d9              LDR      r1,|L1.7988|
001bd0  6b60              LDR      r0,[r4,#0x34]         ;3417
001bd2  6281              STR      r1,[r0,#0x28]         ;3417
001bd4  49d5              LDR      r1,|L1.7980|
001bd6  6b60              LDR      r0,[r4,#0x34]         ;3420
001bd8  6301              STR      r1,[r0,#0x30]         ;3420
001bda  2101              MOVS     r1,#1                 ;3423
001bdc  eb012315          ADD      r3,r1,r5,LSR #8       ;3423
001be0  6821              LDR      r1,[r4,#0]            ;3423
001be2  f101024c          ADD      r2,r1,#0x4c           ;3423
001be6  4639              MOV      r1,r7                 ;3423
001be8  6b60              LDR      r0,[r4,#0x34]         ;3423
001bea  f7fffffe          BL       HAL_DMA_Start_IT
001bee  e000              B        |L1.7154|
                  |L1.7152|
001bf0  bf00              NOP                            ;3427
                  |L1.7154|
001bf2  bf00              NOP                            ;3353
001bf4  ea480005          ORR      r0,r8,r5              ;3430
001bf8  6821              LDR      r1,[r4,#0]            ;3430
001bfa  6488              STR      r0,[r1,#0x48]         ;3430
001bfc  6820              LDR      r0,[r4,#0]            ;3433
001bfe  68c0              LDR      r0,[r0,#0xc]          ;3433
001c00  4330              ORRS     r0,r0,r6              ;3433
001c02  6821              LDR      r1,[r4,#0]            ;3433
001c04  60c8              STR      r0,[r1,#0xc]          ;3433
001c06  2001              MOVS     r0,#1                 ;3435
001c08  f8840039          STRB     r0,[r4,#0x39]         ;3435
001c0c  2000              MOVS     r0,#0                 ;3438
001c0e  e749              B        |L1.6820|
;;;3440   
                          ENDP

                  HAL_TIM_DMABurst_WriteStop PROC
;;;3446     */
;;;3447   HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
001c10  b570              PUSH     {r4-r6,lr}
;;;3448   {
001c12  4604              MOV      r4,r0
001c14  460d              MOV      r5,r1
;;;3449     /* Check the parameters */
;;;3450     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3451   
;;;3452     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3453     switch(BurstRequestSrc)
001c16  f5b56f00          CMP      r5,#0x800
001c1a  d020              BEQ      |L1.7262|
001c1c  dc09              BGT      |L1.7218|
001c1e  f5b57f80          CMP      r5,#0x100
001c22  d010              BEQ      |L1.7238|
001c24  f5b57f00          CMP      r5,#0x200
001c28  d011              BEQ      |L1.7246|
001c2a  f5b56f80          CMP      r5,#0x400
001c2e  d126              BNE      |L1.7294|
001c30  e011              B        |L1.7254|
                  |L1.7218|
001c32  f5b55f80          CMP      r5,#0x1000
001c36  d016              BEQ      |L1.7270|
001c38  f5b55f00          CMP      r5,#0x2000
001c3c  d017              BEQ      |L1.7278|
001c3e  f5b54f80          CMP      r5,#0x4000
001c42  d11c              BNE      |L1.7294|
001c44  e017              B        |L1.7286|
                  |L1.7238|
;;;3454     {
;;;3455       case TIM_DMA_UPDATE:
;;;3456       {
;;;3457         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
001c46  69e0              LDR      r0,[r4,#0x1c]
001c48  f7fffffe          BL       HAL_DMA_Abort
;;;3458       }
;;;3459       break;
001c4c  e018              B        |L1.7296|
                  |L1.7246|
;;;3460       case TIM_DMA_CC1:
;;;3461       {
;;;3462         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
001c4e  6a20              LDR      r0,[r4,#0x20]
001c50  f7fffffe          BL       HAL_DMA_Abort
;;;3463       }
;;;3464       break;
001c54  e014              B        |L1.7296|
                  |L1.7254|
;;;3465       case TIM_DMA_CC2:
;;;3466       {
;;;3467         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
001c56  6a60              LDR      r0,[r4,#0x24]
001c58  f7fffffe          BL       HAL_DMA_Abort
;;;3468       }
;;;3469       break;
001c5c  e010              B        |L1.7296|
                  |L1.7262|
;;;3470       case TIM_DMA_CC3:
;;;3471       {
;;;3472         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
001c5e  6aa0              LDR      r0,[r4,#0x28]
001c60  f7fffffe          BL       HAL_DMA_Abort
;;;3473       }
;;;3474       break;
001c64  e00c              B        |L1.7296|
                  |L1.7270|
;;;3475       case TIM_DMA_CC4:
;;;3476       {
;;;3477         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
001c66  6ae0              LDR      r0,[r4,#0x2c]
001c68  f7fffffe          BL       HAL_DMA_Abort
;;;3478       }
;;;3479       break;
001c6c  e008              B        |L1.7296|
                  |L1.7278|
;;;3480       case TIM_DMA_COM:
;;;3481       {
;;;3482         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
001c6e  6b20              LDR      r0,[r4,#0x30]
001c70  f7fffffe          BL       HAL_DMA_Abort
;;;3483       }
;;;3484       break;
001c74  e004              B        |L1.7296|
                  |L1.7286|
;;;3485       case TIM_DMA_TRIGGER:
;;;3486       {
;;;3487         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
001c76  6b60              LDR      r0,[r4,#0x34]
001c78  f7fffffe          BL       HAL_DMA_Abort
;;;3488       }
;;;3489       break;
001c7c  e000              B        |L1.7296|
                  |L1.7294|
;;;3490       default:
;;;3491       break;
001c7e  bf00              NOP      
                  |L1.7296|
001c80  bf00              NOP                            ;3459
;;;3492     }
;;;3493   
;;;3494     /* Disable the TIM Update DMA request */
;;;3495     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
001c82  6820              LDR      r0,[r4,#0]
001c84  68c0              LDR      r0,[r0,#0xc]
001c86  43a8              BICS     r0,r0,r5
001c88  6821              LDR      r1,[r4,#0]
001c8a  60c8              STR      r0,[r1,#0xc]
;;;3496   
;;;3497     /* Return function status */
;;;3498     return HAL_OK;
001c8c  2000              MOVS     r0,#0
;;;3499   }
001c8e  bd70              POP      {r4-r6,pc}
;;;3500   
                          ENDP

                  HAL_TIM_DMABurst_ReadStart PROC
;;;3538     */
;;;3539   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
001c90  e92d41f0          PUSH     {r4-r8,lr}
;;;3540                                                uint32_t  *BurstBuffer, uint32_t  BurstLength)
;;;3541   {
001c94  4604              MOV      r4,r0
001c96  4688              MOV      r8,r1
001c98  4616              MOV      r6,r2
001c9a  461f              MOV      r7,r3
001c9c  9d06              LDR      r5,[sp,#0x18]
;;;3542     /* Check the parameters */
;;;3543     assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
;;;3544     assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
;;;3545     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3546     assert_param(IS_TIM_DMA_LENGTH(BurstLength));
;;;3547   
;;;3548     if((htim->State == HAL_TIM_STATE_BUSY))
001c9e  f8940039          LDRB     r0,[r4,#0x39]
001ca2  2802              CMP      r0,#2
001ca4  d101              BNE      |L1.7338|
                  |L1.7334|
;;;3549     {
;;;3550        return HAL_BUSY;
;;;3551     }
;;;3552     else if((htim->State == HAL_TIM_STATE_READY))
;;;3553     {
;;;3554       if((BurstBuffer == 0 ) && (BurstLength > 0))
;;;3555       {
;;;3556         return HAL_ERROR;
;;;3557       }
;;;3558       else
;;;3559       {
;;;3560         htim->State = HAL_TIM_STATE_BUSY;
;;;3561       }
;;;3562     }
;;;3563     switch(BurstRequestSrc)
;;;3564     {
;;;3565       case TIM_DMA_UPDATE:
;;;3566       {
;;;3567         /* Set the DMA Period elapsed callback */
;;;3568         htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
;;;3569   
;;;3570         /* Set the DMA error callback */
;;;3571         htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
;;;3572   
;;;3573         /* Enable the DMA channel */
;;;3574          HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3575       }
;;;3576       break;
;;;3577       case TIM_DMA_CC1:
;;;3578       {
;;;3579         /* Set the DMA Period elapsed callback */
;;;3580         htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3581   
;;;3582         /* Set the DMA error callback */
;;;3583         htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
;;;3584   
;;;3585         /* Enable the DMA channel */
;;;3586         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3587       }
;;;3588       break;
;;;3589       case TIM_DMA_CC2:
;;;3590       {
;;;3591         /* Set the DMA Period elapsed callback */
;;;3592         htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3593   
;;;3594         /* Set the DMA error callback */
;;;3595         htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
;;;3596   
;;;3597         /* Enable the DMA channel */
;;;3598         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3599       }
;;;3600       break;
;;;3601       case TIM_DMA_CC3:
;;;3602       {
;;;3603         /* Set the DMA Period elapsed callback */
;;;3604         htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3605   
;;;3606         /* Set the DMA error callback */
;;;3607         htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
;;;3608   
;;;3609         /* Enable the DMA channel */
;;;3610         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3611       }
;;;3612       break;
;;;3613       case TIM_DMA_CC4:
;;;3614       {
;;;3615         /* Set the DMA Period elapsed callback */
;;;3616         htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
;;;3617   
;;;3618         /* Set the DMA error callback */
;;;3619         htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
;;;3620   
;;;3621         /* Enable the DMA channel */
;;;3622         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3623       }
;;;3624       break;
;;;3625       case TIM_DMA_COM:
;;;3626       {
;;;3627         /* Set the DMA Period elapsed callback */
;;;3628         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
;;;3629   
;;;3630         /* Set the DMA error callback */
;;;3631         htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
;;;3632   
;;;3633         /* Enable the DMA channel */
;;;3634         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3635       }
;;;3636       break;
;;;3637       case TIM_DMA_TRIGGER:
;;;3638       {
;;;3639         /* Set the DMA Period elapsed callback */
;;;3640         htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
;;;3641   
;;;3642         /* Set the DMA error callback */
;;;3643         htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
;;;3644   
;;;3645         /* Enable the DMA channel */
;;;3646         HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8) + 1);
;;;3647       }
;;;3648       break;
;;;3649       default:
;;;3650       break;
;;;3651     }
;;;3652   
;;;3653     /* configure the DMA Burst Mode */
;;;3654     htim->Instance->DCR = BurstBaseAddress | BurstLength;
;;;3655   
;;;3656     /* Enable the TIM DMA Request */
;;;3657     __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
;;;3658   
;;;3659     htim->State = HAL_TIM_STATE_READY;
;;;3660   
;;;3661     /* Return function status */
;;;3662     return HAL_OK;
;;;3663   }
001ca6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7338|
001caa  f8940039          LDRB     r0,[r4,#0x39]         ;3552
001cae  2801              CMP      r0,#1                 ;3552
001cb0  d105              BNE      |L1.7358|
001cb2  b90f              CBNZ     r7,|L1.7352|
001cb4  b105              CBZ      r5,|L1.7352|
001cb6  e7f6              B        |L1.7334|
                  |L1.7352|
001cb8  2002              MOVS     r0,#2                 ;3560
001cba  f8840039          STRB     r0,[r4,#0x39]         ;3560
                  |L1.7358|
001cbe  f5b66f00          CMP      r6,#0x800             ;3563
001cc2  d047              BEQ      |L1.7508|
001cc4  dc09              BGT      |L1.7386|
001cc6  f5b67f80          CMP      r6,#0x100             ;3563
001cca  d010              BEQ      |L1.7406|
001ccc  f5b67f00          CMP      r6,#0x200             ;3563
001cd0  d01e              BEQ      |L1.7440|
001cd2  f5b66f80          CMP      r6,#0x400             ;3563
001cd6  d170              BNE      |L1.7610|
001cd8  e02b              B        |L1.7474|
                  |L1.7386|
001cda  f5b65f80          CMP      r6,#0x1000            ;3563
001cde  d04a              BEQ      |L1.7542|
001ce0  f5b65f00          CMP      r6,#0x2000            ;3563
001ce4  d058              BEQ      |L1.7576|
001ce6  f5b64f80          CMP      r6,#0x4000            ;3563
001cea  d178              BNE      |L1.7646|
001cec  e066              B        |L1.7612|
                  |L1.7406|
001cee  4892              LDR      r0,|L1.7992|
001cf0  69e1              LDR      r1,[r4,#0x1c]         ;3568
001cf2  6288              STR      r0,[r1,#0x28]         ;3568
001cf4  488d              LDR      r0,|L1.7980|
001cf6  69e1              LDR      r1,[r4,#0x1c]         ;3571
001cf8  6308              STR      r0,[r1,#0x30]         ;3571
001cfa  2201              MOVS     r2,#1                 ;3574
001cfc  eb022315          ADD      r3,r2,r5,LSR #8       ;3574
001d00  6822              LDR      r2,[r4,#0]            ;3574
001d02  f102014c          ADD      r1,r2,#0x4c           ;3574
001d06  463a              MOV      r2,r7                 ;3574
001d08  69e0              LDR      r0,[r4,#0x1c]         ;3574
001d0a  f7fffffe          BL       HAL_DMA_Start_IT
001d0e  e067              B        |L1.7648|
                  |L1.7440|
001d10  498a              LDR      r1,|L1.7996|
001d12  6a20              LDR      r0,[r4,#0x20]         ;3580
001d14  6281              STR      r1,[r0,#0x28]         ;3580
001d16  4985              LDR      r1,|L1.7980|
001d18  6a20              LDR      r0,[r4,#0x20]         ;3583
001d1a  6301              STR      r1,[r0,#0x30]         ;3583
001d1c  2201              MOVS     r2,#1                 ;3586
001d1e  eb022315          ADD      r3,r2,r5,LSR #8       ;3586
001d22  6822              LDR      r2,[r4,#0]            ;3586
001d24  f102014c          ADD      r1,r2,#0x4c           ;3586
001d28  463a              MOV      r2,r7                 ;3586
001d2a  6a20              LDR      r0,[r4,#0x20]         ;3586
001d2c  f7fffffe          BL       HAL_DMA_Start_IT
001d30  e056              B        |L1.7648|
                  |L1.7474|
001d32  4982              LDR      r1,|L1.7996|
001d34  6a60              LDR      r0,[r4,#0x24]         ;3592
001d36  6281              STR      r1,[r0,#0x28]         ;3592
001d38  497c              LDR      r1,|L1.7980|
001d3a  6a60              LDR      r0,[r4,#0x24]         ;3595
001d3c  6301              STR      r1,[r0,#0x30]         ;3595
001d3e  2201              MOVS     r2,#1                 ;3598
001d40  eb022315          ADD      r3,r2,r5,LSR #8       ;3598
001d44  6822              LDR      r2,[r4,#0]            ;3598
001d46  f102014c          ADD      r1,r2,#0x4c           ;3598
001d4a  463a              MOV      r2,r7                 ;3598
001d4c  6a60              LDR      r0,[r4,#0x24]         ;3598
001d4e  f7fffffe          BL       HAL_DMA_Start_IT
001d52  e045              B        |L1.7648|
                  |L1.7508|
001d54  4979              LDR      r1,|L1.7996|
001d56  6aa0              LDR      r0,[r4,#0x28]         ;3604
001d58  6281              STR      r1,[r0,#0x28]         ;3604
001d5a  4974              LDR      r1,|L1.7980|
001d5c  6aa0              LDR      r0,[r4,#0x28]         ;3607
001d5e  6301              STR      r1,[r0,#0x30]         ;3607
001d60  2201              MOVS     r2,#1                 ;3610
001d62  eb022315          ADD      r3,r2,r5,LSR #8       ;3610
001d66  6822              LDR      r2,[r4,#0]            ;3610
001d68  f102014c          ADD      r1,r2,#0x4c           ;3610
001d6c  463a              MOV      r2,r7                 ;3610
001d6e  6aa0              LDR      r0,[r4,#0x28]         ;3610
001d70  f7fffffe          BL       HAL_DMA_Start_IT
001d74  e034              B        |L1.7648|
                  |L1.7542|
001d76  4971              LDR      r1,|L1.7996|
001d78  6ae0              LDR      r0,[r4,#0x2c]         ;3616
001d7a  6281              STR      r1,[r0,#0x28]         ;3616
001d7c  496b              LDR      r1,|L1.7980|
001d7e  6ae0              LDR      r0,[r4,#0x2c]         ;3619
001d80  6301              STR      r1,[r0,#0x30]         ;3619
001d82  2201              MOVS     r2,#1                 ;3622
001d84  eb022315          ADD      r3,r2,r5,LSR #8       ;3622
001d88  6822              LDR      r2,[r4,#0]            ;3622
001d8a  f102014c          ADD      r1,r2,#0x4c           ;3622
001d8e  463a              MOV      r2,r7                 ;3622
001d90  6ae0              LDR      r0,[r4,#0x2c]         ;3622
001d92  f7fffffe          BL       HAL_DMA_Start_IT
001d96  e023              B        |L1.7648|
                  |L1.7576|
001d98  4965              LDR      r1,|L1.7984|
001d9a  6b20              LDR      r0,[r4,#0x30]         ;3628
001d9c  6281              STR      r1,[r0,#0x28]         ;3628
001d9e  4963              LDR      r1,|L1.7980|
001da0  6b20              LDR      r0,[r4,#0x30]         ;3631
001da2  6301              STR      r1,[r0,#0x30]         ;3631
001da4  2201              MOVS     r2,#1                 ;3634
001da6  eb022315          ADD      r3,r2,r5,LSR #8       ;3634
001daa  6822              LDR      r2,[r4,#0]            ;3634
001dac  f102014c          ADD      r1,r2,#0x4c           ;3634
001db0  463a              MOV      r2,r7                 ;3634
001db2  6b20              LDR      r0,[r4,#0x30]         ;3634
001db4  f7fffffe          BL       HAL_DMA_Start_IT
001db8  e012              B        |L1.7648|
                  |L1.7610|
001dba  e010              B        |L1.7646|
                  |L1.7612|
001dbc  495d              LDR      r1,|L1.7988|
001dbe  6b60              LDR      r0,[r4,#0x34]         ;3640
001dc0  6281              STR      r1,[r0,#0x28]         ;3640
001dc2  495a              LDR      r1,|L1.7980|
001dc4  6b60              LDR      r0,[r4,#0x34]         ;3643
001dc6  6301              STR      r1,[r0,#0x30]         ;3643
001dc8  2201              MOVS     r2,#1                 ;3646
001dca  eb022315          ADD      r3,r2,r5,LSR #8       ;3646
001dce  6822              LDR      r2,[r4,#0]            ;3646
001dd0  f102014c          ADD      r1,r2,#0x4c           ;3646
001dd4  463a              MOV      r2,r7                 ;3646
001dd6  6b60              LDR      r0,[r4,#0x34]         ;3646
001dd8  f7fffffe          BL       HAL_DMA_Start_IT
001ddc  e000              B        |L1.7648|
                  |L1.7646|
001dde  bf00              NOP                            ;3650
                  |L1.7648|
001de0  bf00              NOP                            ;3576
001de2  ea480005          ORR      r0,r8,r5              ;3654
001de6  6821              LDR      r1,[r4,#0]            ;3654
001de8  6488              STR      r0,[r1,#0x48]         ;3654
001dea  6820              LDR      r0,[r4,#0]            ;3657
001dec  68c0              LDR      r0,[r0,#0xc]          ;3657
001dee  4330              ORRS     r0,r0,r6              ;3657
001df0  6821              LDR      r1,[r4,#0]            ;3657
001df2  60c8              STR      r0,[r1,#0xc]          ;3657
001df4  2001              MOVS     r0,#1                 ;3659
001df6  f8840039          STRB     r0,[r4,#0x39]         ;3659
001dfa  2000              MOVS     r0,#0                 ;3662
001dfc  e753              B        |L1.7334|
;;;3664   
                          ENDP

                  HAL_TIM_DMABurst_ReadStop PROC
;;;3670     */
;;;3671   HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
001dfe  b570              PUSH     {r4-r6,lr}
;;;3672   {
001e00  4604              MOV      r4,r0
001e02  460d              MOV      r5,r1
;;;3673     /* Check the parameters */
;;;3674     assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
;;;3675   
;;;3676     /* Abort the DMA transfer (at least disable the DMA channel) */
;;;3677     switch(BurstRequestSrc)
001e04  f5b56f00          CMP      r5,#0x800
001e08  d020              BEQ      |L1.7756|
001e0a  dc09              BGT      |L1.7712|
001e0c  f5b57f80          CMP      r5,#0x100
001e10  d010              BEQ      |L1.7732|
001e12  f5b57f00          CMP      r5,#0x200
001e16  d011              BEQ      |L1.7740|
001e18  f5b56f80          CMP      r5,#0x400
001e1c  d126              BNE      |L1.7788|
001e1e  e011              B        |L1.7748|
                  |L1.7712|
001e20  f5b55f80          CMP      r5,#0x1000
001e24  d016              BEQ      |L1.7764|
001e26  f5b55f00          CMP      r5,#0x2000
001e2a  d017              BEQ      |L1.7772|
001e2c  f5b54f80          CMP      r5,#0x4000
001e30  d11c              BNE      |L1.7788|
001e32  e017              B        |L1.7780|
                  |L1.7732|
;;;3678     {
;;;3679       case TIM_DMA_UPDATE:
;;;3680       {
;;;3681         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
001e34  69e0              LDR      r0,[r4,#0x1c]
001e36  f7fffffe          BL       HAL_DMA_Abort
;;;3682       }
;;;3683       break;
001e3a  e018              B        |L1.7790|
                  |L1.7740|
;;;3684       case TIM_DMA_CC1:
;;;3685       {
;;;3686         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
001e3c  6a20              LDR      r0,[r4,#0x20]
001e3e  f7fffffe          BL       HAL_DMA_Abort
;;;3687       }
;;;3688       break;
001e42  e014              B        |L1.7790|
                  |L1.7748|
;;;3689       case TIM_DMA_CC2:
;;;3690       {
;;;3691         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
001e44  6a60              LDR      r0,[r4,#0x24]
001e46  f7fffffe          BL       HAL_DMA_Abort
;;;3692       }
;;;3693       break;
001e4a  e010              B        |L1.7790|
                  |L1.7756|
;;;3694       case TIM_DMA_CC3:
;;;3695       {
;;;3696         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
001e4c  6aa0              LDR      r0,[r4,#0x28]
001e4e  f7fffffe          BL       HAL_DMA_Abort
;;;3697       }
;;;3698       break;
001e52  e00c              B        |L1.7790|
                  |L1.7764|
;;;3699       case TIM_DMA_CC4:
;;;3700       {
;;;3701         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
001e54  6ae0              LDR      r0,[r4,#0x2c]
001e56  f7fffffe          BL       HAL_DMA_Abort
;;;3702       }
;;;3703       break;
001e5a  e008              B        |L1.7790|
                  |L1.7772|
;;;3704       case TIM_DMA_COM:
;;;3705       {
;;;3706         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
001e5c  6b20              LDR      r0,[r4,#0x30]
001e5e  f7fffffe          BL       HAL_DMA_Abort
;;;3707       }
;;;3708       break;
001e62  e004              B        |L1.7790|
                  |L1.7780|
;;;3709       case TIM_DMA_TRIGGER:
;;;3710       {
;;;3711         HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
001e64  6b60              LDR      r0,[r4,#0x34]
001e66  f7fffffe          BL       HAL_DMA_Abort
;;;3712       }
;;;3713       break;
001e6a  e000              B        |L1.7790|
                  |L1.7788|
;;;3714       default:
;;;3715       break;
001e6c  bf00              NOP      
                  |L1.7790|
001e6e  bf00              NOP                            ;3683
;;;3716     }
;;;3717   
;;;3718     /* Disable the TIM Update DMA request */
;;;3719     __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
001e70  6820              LDR      r0,[r4,#0]
001e72  68c0              LDR      r0,[r0,#0xc]
001e74  43a8              BICS     r0,r0,r5
001e76  6821              LDR      r1,[r4,#0]
001e78  60c8              STR      r0,[r1,#0xc]
;;;3720   
;;;3721     /* Return function status */
;;;3722     return HAL_OK;
001e7a  2000              MOVS     r0,#0
;;;3723   }
001e7c  bd70              POP      {r4-r6,pc}
;;;3724   
                          ENDP

                  HAL_TIM_GenerateEvent PROC
;;;3742   
;;;3743   HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
001e7e  4602              MOV      r2,r0
;;;3744   {
;;;3745     /* Check the parameters */
;;;3746     assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3747     assert_param(IS_TIM_EVENT_SOURCE(EventSource));
;;;3748   
;;;3749     /* Process Locked */
;;;3750     __HAL_LOCK(htim);
001e80  bf00              NOP      
001e82  f8920038          LDRB     r0,[r2,#0x38]
001e86  2801              CMP      r0,#1
001e88  d101              BNE      |L1.7822|
001e8a  2002              MOVS     r0,#2
                  |L1.7820|
;;;3751   
;;;3752     /* Change the TIM state */
;;;3753     htim->State = HAL_TIM_STATE_BUSY;
;;;3754   
;;;3755     /* Set the event sources */
;;;3756     htim->Instance->EGR = EventSource;
;;;3757   
;;;3758     /* Change the TIM state */
;;;3759     htim->State = HAL_TIM_STATE_READY;
;;;3760   
;;;3761     __HAL_UNLOCK(htim);
;;;3762   
;;;3763     /* Return function status */
;;;3764     return HAL_OK;
;;;3765   }
001e8c  4770              BX       lr
                  |L1.7822|
001e8e  2001              MOVS     r0,#1                 ;3750
001e90  f8820038          STRB     r0,[r2,#0x38]         ;3750
001e94  bf00              NOP                            ;3750
001e96  2002              MOVS     r0,#2                 ;3753
001e98  f8820039          STRB     r0,[r2,#0x39]         ;3753
001e9c  6810              LDR      r0,[r2,#0]            ;3756
001e9e  6141              STR      r1,[r0,#0x14]         ;3756
001ea0  2001              MOVS     r0,#1                 ;3759
001ea2  f8820039          STRB     r0,[r2,#0x39]         ;3759
001ea6  bf00              NOP                            ;3761
001ea8  2000              MOVS     r0,#0                 ;3761
001eaa  f8820038          STRB     r0,[r2,#0x38]         ;3761
001eae  bf00              NOP                            ;3761
001eb0  bf00              NOP                            ;3764
001eb2  e7eb              B        |L1.7820|
;;;3766   
                          ENDP

                  TIM_ETR_SetConfig PROC
;;;5319     */
;;;5320   static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
001eb4  b530              PUSH     {r4,r5,lr}
;;;5321                          uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
;;;5322   {
001eb6  460c              MOV      r4,r1
;;;5323     uint32_t tmpsmcr = 0;
001eb8  2100              MOVS     r1,#0
;;;5324   
;;;5325     tmpsmcr = TIMx->SMCR;
001eba  6881              LDR      r1,[r0,#8]
;;;5326   
;;;5327     /* Reset the ETR Bits */
;;;5328     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
001ebc  f421417f          BIC      r1,r1,#0xff00
;;;5329   
;;;5330     /* Set the Prescaler, the Filter value and the Polarity */
;;;5331     tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8)));
001ec0  ea422503          ORR      r5,r2,r3,LSL #8
001ec4  4325              ORRS     r5,r5,r4
001ec6  4329              ORRS     r1,r1,r5
;;;5332   
;;;5333     /* Write to TIMx SMCR */
;;;5334     TIMx->SMCR = tmpsmcr;
001ec8  6081              STR      r1,[r0,#8]
;;;5335   }
001eca  bd30              POP      {r4,r5,pc}
;;;5336   
                          ENDP

                  HAL_TIM_ConfigOCrefClear PROC
;;;3779     */ 
;;;3780   HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
001ecc  e92d41f0          PUSH     {r4-r8,lr}
;;;3781   {
001ed0  4604              MOV      r4,r0
001ed2  460d              MOV      r5,r1
001ed4  4617              MOV      r7,r2
;;;3782     uint32_t tmpsmcr = 0;
001ed6  2600              MOVS     r6,#0
;;;3783   
;;;3784     /* Check the parameters */
;;;3785     assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
;;;3786     assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
;;;3787     assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
;;;3788     assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
;;;3789     assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
;;;3790   
;;;3791     /* Process Locked */
;;;3792     __HAL_LOCK(htim);
001ed8  bf00              NOP      
001eda  f8940038          LDRB     r0,[r4,#0x38]
001ede  2801              CMP      r0,#1
001ee0  d102              BNE      |L1.7912|
001ee2  2002              MOVS     r0,#2
                  |L1.7908|
;;;3793   
;;;3794     htim->State = HAL_TIM_STATE_BUSY;
;;;3795   
;;;3796     switch (sClearInputConfig->ClearInputSource)
;;;3797     {
;;;3798       case TIM_CLEARINPUTSOURCE_NONE:
;;;3799       {
;;;3800         /* Clear the OCREF clear selection bit */
;;;3801         tmpsmcr &= ~TIM_SMCR_OCCS;
;;;3802   
;;;3803         /* Clear the ETR Bits */
;;;3804         tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3805   
;;;3806         /* Set TIMx_SMCR */
;;;3807         htim->Instance->SMCR = tmpsmcr;
;;;3808      }
;;;3809       break;
;;;3810   
;;;3811       case TIM_CLEARINPUTSOURCE_ETR:
;;;3812       {
;;;3813         TIM_ETR_SetConfig(htim->Instance,
;;;3814                           sClearInputConfig->ClearInputPrescaler,
;;;3815                           sClearInputConfig->ClearInputPolarity,
;;;3816                           sClearInputConfig->ClearInputFilter);
;;;3817   
;;;3818         /* Set the OCREF clear selection bit */
;;;3819         htim->Instance->SMCR |= TIM_SMCR_OCCS;
;;;3820       }
;;;3821       break;
;;;3822       default:
;;;3823       break;
;;;3824     }
;;;3825   
;;;3826     switch (Channel)
;;;3827     {
;;;3828       case TIM_CHANNEL_1:
;;;3829         {
;;;3830           if(sClearInputConfig->ClearInputState != RESET)
;;;3831           {
;;;3832             /* Enable the Ocref clear feature for Channel 1 */
;;;3833             htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
;;;3834           }
;;;3835           else
;;;3836           {
;;;3837             /* Disable the Ocref clear feature for Channel 1 */
;;;3838           htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
;;;3839           }
;;;3840         }
;;;3841         break;
;;;3842       case TIM_CHANNEL_2:
;;;3843         {
;;;3844           assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;3845           if(sClearInputConfig->ClearInputState != RESET)
;;;3846           {
;;;3847             /* Enable the Ocref clear feature for Channel 2 */
;;;3848             htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
;;;3849           }
;;;3850           else
;;;3851           {
;;;3852             /* Disable the Ocref clear feature for Channel 2 */
;;;3853             htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
;;;3854           }
;;;3855         }
;;;3856       break;
;;;3857       case TIM_CHANNEL_3:
;;;3858         {
;;;3859           assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;3860           if(sClearInputConfig->ClearInputState != RESET)
;;;3861           {
;;;3862             /* Enable the Ocref clear feature for Channel 3 */
;;;3863             htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
;;;3864           }
;;;3865           else
;;;3866           {
;;;3867             /* Disable the Ocref clear feature for Channel 3 */
;;;3868           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
;;;3869           }
;;;3870         }
;;;3871       break;
;;;3872       case TIM_CHANNEL_4:
;;;3873         {
;;;3874           assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;3875           if(sClearInputConfig->ClearInputState != RESET)
;;;3876           {
;;;3877             /* Enable the Ocref clear feature for Channel 4 */
;;;3878             htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
;;;3879           }
;;;3880           else
;;;3881           {
;;;3882             /* Disable the Ocref clear feature for Channel 4 */
;;;3883           htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
;;;3884           }
;;;3885         }
;;;3886       break;
;;;3887       default:
;;;3888       break;
;;;3889     }
;;;3890   
;;;3891     htim->State = HAL_TIM_STATE_READY;
;;;3892   
;;;3893     __HAL_UNLOCK(htim);
;;;3894   
;;;3895     return HAL_OK;
;;;3896   }
001ee4  e8bd81f0          POP      {r4-r8,pc}
                  |L1.7912|
001ee8  2001              MOVS     r0,#1                 ;3792
001eea  f8840038          STRB     r0,[r4,#0x38]         ;3792
001eee  bf00              NOP                            ;3792
001ef0  2002              MOVS     r0,#2                 ;3794
001ef2  f8840039          STRB     r0,[r4,#0x39]         ;3794
001ef6  6868              LDR      r0,[r5,#4]            ;3796
001ef8  b110              CBZ      r0,|L1.7936|
001efa  2801              CMP      r0,#1                 ;3796
001efc  d120              BNE      |L1.8000|
001efe  e006              B        |L1.7950|
                  |L1.7936|
001f00  f0260608          BIC      r6,r6,#8              ;3801
001f04  f426467f          BIC      r6,r6,#0xff00         ;3804
001f08  6820              LDR      r0,[r4,#0]            ;3807
001f0a  6086              STR      r6,[r0,#8]            ;3807
001f0c  e019              B        |L1.8002|
                  |L1.7950|
001f0e  e9d51303          LDRD     r1,r3,[r5,#0xc]       ;3813
001f12  68aa              LDR      r2,[r5,#8]            ;3813
001f14  6820              LDR      r0,[r4,#0]            ;3813
001f16  f7fffffe          BL       TIM_ETR_SetConfig
001f1a  6820              LDR      r0,[r4,#0]            ;3819
001f1c  6880              LDR      r0,[r0,#8]            ;3819
001f1e  f0400008          ORR      r0,r0,#8              ;3819
001f22  6821              LDR      r1,[r4,#0]            ;3819
001f24  6088              STR      r0,[r1,#8]            ;3819
001f26  e00c              B        |L1.8002|
                  |L1.7976|
                          DCD      TIM_DMADelayPulseCplt
                  |L1.7980|
                          DCD      TIM_DMAError
                  |L1.7984|
                          DCD      TIMEx_DMACommutationCplt
                  |L1.7988|
                          DCD      TIM_DMATriggerCplt
                  |L1.7992|
                          DCD      TIM_DMAPeriodElapsedCplt
                  |L1.7996|
                          DCD      TIM_DMACaptureCplt
                  |L1.8000|
001f40  bf00              NOP                            ;3823
                  |L1.8002|
001f42  bf00              NOP                            ;3809
001f44  b137              CBZ      r7,|L1.8020|
001f46  2f04              CMP      r7,#4                 ;3826
001f48  d014              BEQ      |L1.8052|
001f4a  2f08              CMP      r7,#8                 ;3826
001f4c  d022              BEQ      |L1.8084|
001f4e  2f0c              CMP      r7,#0xc               ;3826
001f50  d140              BNE      |L1.8148|
001f52  e02f              B        |L1.8116|
                  |L1.8020|
001f54  6828              LDR      r0,[r5,#0]            ;3830
001f56  b130              CBZ      r0,|L1.8038|
001f58  6820              LDR      r0,[r4,#0]            ;3833
001f5a  6980              LDR      r0,[r0,#0x18]         ;3833
001f5c  f0400080          ORR      r0,r0,#0x80           ;3833
001f60  6821              LDR      r1,[r4,#0]            ;3833
001f62  6188              STR      r0,[r1,#0x18]         ;3833
001f64  e005              B        |L1.8050|
                  |L1.8038|
001f66  6820              LDR      r0,[r4,#0]            ;3838
001f68  6980              LDR      r0,[r0,#0x18]         ;3838
001f6a  f0200080          BIC      r0,r0,#0x80           ;3838
001f6e  6821              LDR      r1,[r4,#0]            ;3838
001f70  6188              STR      r0,[r1,#0x18]         ;3838
                  |L1.8050|
001f72  e030              B        |L1.8150|
                  |L1.8052|
001f74  6828              LDR      r0,[r5,#0]            ;3845
001f76  b130              CBZ      r0,|L1.8070|
001f78  6820              LDR      r0,[r4,#0]            ;3848
001f7a  6980              LDR      r0,[r0,#0x18]         ;3848
001f7c  f4404000          ORR      r0,r0,#0x8000         ;3848
001f80  6821              LDR      r1,[r4,#0]            ;3848
001f82  6188              STR      r0,[r1,#0x18]         ;3848
001f84  e005              B        |L1.8082|
                  |L1.8070|
001f86  6820              LDR      r0,[r4,#0]            ;3853
001f88  6980              LDR      r0,[r0,#0x18]         ;3853
001f8a  f4204000          BIC      r0,r0,#0x8000         ;3853
001f8e  6821              LDR      r1,[r4,#0]            ;3853
001f90  6188              STR      r0,[r1,#0x18]         ;3853
                  |L1.8082|
001f92  e020              B        |L1.8150|
                  |L1.8084|
001f94  6828              LDR      r0,[r5,#0]            ;3860
001f96  b130              CBZ      r0,|L1.8102|
001f98  6820              LDR      r0,[r4,#0]            ;3863
001f9a  69c0              LDR      r0,[r0,#0x1c]         ;3863
001f9c  f0400080          ORR      r0,r0,#0x80           ;3863
001fa0  6821              LDR      r1,[r4,#0]            ;3863
001fa2  61c8              STR      r0,[r1,#0x1c]         ;3863
001fa4  e005              B        |L1.8114|
                  |L1.8102|
001fa6  6820              LDR      r0,[r4,#0]            ;3868
001fa8  69c0              LDR      r0,[r0,#0x1c]         ;3868
001faa  f0200080          BIC      r0,r0,#0x80           ;3868
001fae  6821              LDR      r1,[r4,#0]            ;3868
001fb0  61c8              STR      r0,[r1,#0x1c]         ;3868
                  |L1.8114|
001fb2  e010              B        |L1.8150|
                  |L1.8116|
001fb4  6828              LDR      r0,[r5,#0]            ;3875
001fb6  b130              CBZ      r0,|L1.8134|
001fb8  6820              LDR      r0,[r4,#0]            ;3878
001fba  69c0              LDR      r0,[r0,#0x1c]         ;3878
001fbc  f4404000          ORR      r0,r0,#0x8000         ;3878
001fc0  6821              LDR      r1,[r4,#0]            ;3878
001fc2  61c8              STR      r0,[r1,#0x1c]         ;3878
001fc4  e005              B        |L1.8146|
                  |L1.8134|
001fc6  6820              LDR      r0,[r4,#0]            ;3883
001fc8  69c0              LDR      r0,[r0,#0x1c]         ;3883
001fca  f4204000          BIC      r0,r0,#0x8000         ;3883
001fce  6821              LDR      r1,[r4,#0]            ;3883
001fd0  61c8              STR      r0,[r1,#0x1c]         ;3883
                  |L1.8146|
001fd2  e000              B        |L1.8150|
                  |L1.8148|
001fd4  bf00              NOP                            ;3888
                  |L1.8150|
001fd6  bf00              NOP                            ;3841
001fd8  2001              MOVS     r0,#1                 ;3891
001fda  f8840039          STRB     r0,[r4,#0x39]         ;3891
001fde  bf00              NOP                            ;3893
001fe0  2000              MOVS     r0,#0                 ;3893
001fe2  f8840038          STRB     r0,[r4,#0x38]         ;3893
001fe6  bf00              NOP                            ;3893
001fe8  bf00              NOP                            ;3895
001fea  e77b              B        |L1.7908|
;;;3897   
                          ENDP

                  TIM_ITRx_SetConfig PROC
;;;5289     */
;;;5290   static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
001fec  460a              MOV      r2,r1
;;;5291   {
;;;5292     uint32_t tmpsmcr = 0;
001fee  2100              MOVS     r1,#0
;;;5293   
;;;5294      /* Get the TIMx SMCR register value */
;;;5295      tmpsmcr = TIMx->SMCR;
001ff0  6881              LDR      r1,[r0,#8]
;;;5296      /* Reset the TS Bits */
;;;5297      tmpsmcr &= ~TIM_SMCR_TS;
001ff2  f0210170          BIC      r1,r1,#0x70
;;;5298      /* Set the Input Trigger source and the slave mode*/
;;;5299      tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
001ff6  f0420307          ORR      r3,r2,#7
001ffa  4319              ORRS     r1,r1,r3
;;;5300      /* Write to TIMx SMCR */
;;;5301      TIMx->SMCR = tmpsmcr;
001ffc  6081              STR      r1,[r0,#8]
;;;5302   }
001ffe  4770              BX       lr
;;;5303   /**
                          ENDP

                  TIM_TI1_ConfigInputStage PROC
;;;5072     */
;;;5073   static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
002000  b530              PUSH     {r4,r5,lr}
;;;5074   {
002002  460b              MOV      r3,r1
002004  4614              MOV      r4,r2
;;;5075     uint32_t tmpccmr1 = 0;
002006  2100              MOVS     r1,#0
;;;5076     uint32_t tmpccer = 0;
002008  2200              MOVS     r2,#0
;;;5077   
;;;5078     /* Disable the Channel 1: Reset the CC1E Bit */
;;;5079     tmpccer = TIMx->CCER;
00200a  6a02              LDR      r2,[r0,#0x20]
;;;5080     TIMx->CCER &= ~TIM_CCER_CC1E;
00200c  6a05              LDR      r5,[r0,#0x20]
00200e  f0250501          BIC      r5,r5,#1
002012  6205              STR      r5,[r0,#0x20]
;;;5081     tmpccmr1 = TIMx->CCMR1;
002014  6981              LDR      r1,[r0,#0x18]
;;;5082   
;;;5083     /* Set the filter */
;;;5084     tmpccmr1 &= ~TIM_CCMR1_IC1F;
002016  f02101f0          BIC      r1,r1,#0xf0
;;;5085     tmpccmr1 |= (TIM_ICFilter << 4);
00201a  ea411104          ORR      r1,r1,r4,LSL #4
;;;5086   
;;;5087     /* Select the Polarity and set the CC1E Bit */
;;;5088     tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00201e  f022020a          BIC      r2,r2,#0xa
;;;5089     tmpccer |= TIM_ICPolarity;
002022  431a              ORRS     r2,r2,r3
;;;5090   
;;;5091     /* Write to TIMx CCMR1 and CCER registers */
;;;5092     TIMx->CCMR1 = tmpccmr1;
002024  6181              STR      r1,[r0,#0x18]
;;;5093     TIMx->CCER = tmpccer;
002026  6202              STR      r2,[r0,#0x20]
;;;5094   }
002028  bd30              POP      {r4,r5,pc}
;;;5095   
                          ENDP

                  TIM_TI2_ConfigInputStage PROC
;;;5155     */
;;;5156   static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
00202a  b530              PUSH     {r4,r5,lr}
;;;5157   {
00202c  460b              MOV      r3,r1
00202e  4614              MOV      r4,r2
;;;5158     uint32_t tmpccmr1 = 0;
002030  2100              MOVS     r1,#0
;;;5159     uint32_t tmpccer = 0;
002032  2200              MOVS     r2,#0
;;;5160   
;;;5161     /* Disable the Channel 2: Reset the CC2E Bit */
;;;5162     TIMx->CCER &= ~TIM_CCER_CC2E;
002034  6a05              LDR      r5,[r0,#0x20]
002036  f0250510          BIC      r5,r5,#0x10
00203a  6205              STR      r5,[r0,#0x20]
;;;5163     tmpccmr1 = TIMx->CCMR1;
00203c  6981              LDR      r1,[r0,#0x18]
;;;5164     tmpccer = TIMx->CCER;
00203e  6a02              LDR      r2,[r0,#0x20]
;;;5165   
;;;5166     /* Set the filter */
;;;5167     tmpccmr1 &= ~TIM_CCMR1_IC2F;
002040  f4214170          BIC      r1,r1,#0xf000
;;;5168     tmpccmr1 |= (TIM_ICFilter << 12);
002044  ea413104          ORR      r1,r1,r4,LSL #12
;;;5169   
;;;5170     /* Select the Polarity and set the CC2E Bit */
;;;5171     tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
002048  f02202a0          BIC      r2,r2,#0xa0
;;;5172     tmpccer |= (TIM_ICPolarity << 4);
00204c  ea421203          ORR      r2,r2,r3,LSL #4
;;;5173   
;;;5174     /* Write to TIMx CCMR1 and CCER registers */
;;;5175     TIMx->CCMR1 = tmpccmr1 ;
002050  6181              STR      r1,[r0,#0x18]
;;;5176     TIMx->CCER = tmpccer;
002052  6202              STR      r2,[r0,#0x20]
;;;5177   }
002054  bd30              POP      {r4,r5,pc}
;;;5178   
                          ENDP

                  HAL_TIM_ConfigClockSource PROC
;;;3904     */ 
;;;3905   HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
002056  e92d41f0          PUSH     {r4-r8,lr}
;;;3906   {
00205a  4604              MOV      r4,r0
00205c  460d              MOV      r5,r1
;;;3907     uint32_t tmpsmcr = 0;
00205e  2600              MOVS     r6,#0
;;;3908   
;;;3909     /* Process Locked */
;;;3910     __HAL_LOCK(htim);
002060  bf00              NOP      
002062  f8940038          LDRB     r0,[r4,#0x38]
002066  2801              CMP      r0,#1
002068  d102              BNE      |L1.8304|
00206a  2002              MOVS     r0,#2
                  |L1.8300|
;;;3911   
;;;3912     htim->State = HAL_TIM_STATE_BUSY;
;;;3913   
;;;3914     /* Check the parameters */
;;;3915     assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
;;;3916   
;;;3917     /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
;;;3918     tmpsmcr = htim->Instance->SMCR;
;;;3919     tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3920     tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
;;;3921     htim->Instance->SMCR = tmpsmcr;
;;;3922   
;;;3923     switch (sClockSourceConfig->ClockSource)
;;;3924     {
;;;3925     case TIM_CLOCKSOURCE_INTERNAL:
;;;3926       {
;;;3927         assert_param(IS_TIM_INSTANCE(htim->Instance));
;;;3928         /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;3929         htim->Instance->SMCR &= ~TIM_SMCR_SMS;
;;;3930       }
;;;3931       break;
;;;3932   
;;;3933     case TIM_CLOCKSOURCE_ETRMODE1:
;;;3934       {
;;;3935         /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
;;;3936         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;3937   
;;;3938         /* Check ETR input conditioning related parameters */
;;;3939         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3940         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3941         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3942         
;;;3943         /* Configure the ETR Clock source */
;;;3944         TIM_ETR_SetConfig(htim->Instance,
;;;3945                           sClockSourceConfig->ClockPrescaler,
;;;3946                           sClockSourceConfig->ClockPolarity,
;;;3947                           sClockSourceConfig->ClockFilter);
;;;3948         /* Get the TIMx SMCR register value */
;;;3949         tmpsmcr = htim->Instance->SMCR;
;;;3950         /* Reset the SMS and TS Bits */
;;;3951         tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
;;;3952         /* Select the External clock mode1 and the ETRF trigger */
;;;3953         tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
;;;3954         /* Write to TIMx SMCR */
;;;3955         htim->Instance->SMCR = tmpsmcr;
;;;3956       }
;;;3957       break;
;;;3958   
;;;3959     case TIM_CLOCKSOURCE_ETRMODE2:
;;;3960       {
;;;3961         /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
;;;3962         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
;;;3963   
;;;3964         /* Check ETR input conditioning related parameters */
;;;3965         assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
;;;3966         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3967         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3968         
;;;3969         /* Configure the ETR Clock source */
;;;3970         TIM_ETR_SetConfig(htim->Instance,
;;;3971                           sClockSourceConfig->ClockPrescaler,
;;;3972                           sClockSourceConfig->ClockPolarity,
;;;3973                           sClockSourceConfig->ClockFilter);
;;;3974         /* Enable the External clock mode2 */
;;;3975         htim->Instance->SMCR |= TIM_SMCR_ECE;
;;;3976       }
;;;3977       break;
;;;3978   
;;;3979     case TIM_CLOCKSOURCE_TI1:
;;;3980       {
;;;3981         /* Check whether or not the timer instance supports external clock mode 1 */
;;;3982         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3983   
;;;3984         /* Check TI1 input conditioning related parameters */
;;;3985         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;3986         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;3987         
;;;3988         TIM_TI1_ConfigInputStage(htim->Instance,
;;;3989                                  sClockSourceConfig->ClockPolarity,
;;;3990                                  sClockSourceConfig->ClockFilter);
;;;3991         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
;;;3992       }
;;;3993       break;
;;;3994     case TIM_CLOCKSOURCE_TI2:
;;;3995       {
;;;3996         /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
;;;3997         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;3998   
;;;3999          /* Check TI2 input conditioning related parameters */
;;;4000         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4001         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4002   
;;;4003         TIM_TI2_ConfigInputStage(htim->Instance,
;;;4004                                  sClockSourceConfig->ClockPolarity,
;;;4005                                  sClockSourceConfig->ClockFilter);
;;;4006         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
;;;4007       }
;;;4008       break;
;;;4009     case TIM_CLOCKSOURCE_TI1ED:
;;;4010       {
;;;4011         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4012         assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
;;;4013   
;;;4014         /* Check TI1 input conditioning related parameters */
;;;4015         assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
;;;4016         assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
;;;4017   
;;;4018         TIM_TI1_ConfigInputStage(htim->Instance,
;;;4019                                  sClockSourceConfig->ClockPolarity,
;;;4020                                  sClockSourceConfig->ClockFilter);
;;;4021         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
;;;4022       }
;;;4023       break;
;;;4024     case TIM_CLOCKSOURCE_ITR0:
;;;4025       {
;;;4026         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4027         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4028   
;;;4029         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
;;;4030       }
;;;4031       break;
;;;4032     case TIM_CLOCKSOURCE_ITR1:
;;;4033       {
;;;4034         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4035         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4036   
;;;4037         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
;;;4038       }
;;;4039       break;
;;;4040     case TIM_CLOCKSOURCE_ITR2:
;;;4041       {
;;;4042         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4043         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4044   
;;;4045         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
;;;4046       }
;;;4047       break;
;;;4048     case TIM_CLOCKSOURCE_ITR3:
;;;4049       {
;;;4050         /* Check whether or not the timer instance supports external clock mode 1 */
;;;4051         assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
;;;4052   
;;;4053         TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
;;;4054       }
;;;4055       break;
;;;4056   
;;;4057     default:
;;;4058       break;
;;;4059     }
;;;4060     htim->State = HAL_TIM_STATE_READY;
;;;4061   
;;;4062     __HAL_UNLOCK(htim);
;;;4063   
;;;4064     return HAL_OK;
;;;4065   }
00206c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.8304|
002070  2001              MOVS     r0,#1                 ;3910
002072  f8840038          STRB     r0,[r4,#0x38]         ;3910
002076  bf00              NOP                            ;3910
002078  2002              MOVS     r0,#2                 ;3912
00207a  f8840039          STRB     r0,[r4,#0x39]         ;3912
00207e  6820              LDR      r0,[r4,#0]            ;3918
002080  6886              LDR      r6,[r0,#8]            ;3918
002082  f0260677          BIC      r6,r6,#0x77           ;3919
002086  f426467f          BIC      r6,r6,#0xff00         ;3920
00208a  6820              LDR      r0,[r4,#0]            ;3921
00208c  6086              STR      r6,[r0,#8]            ;3921
00208e  6828              LDR      r0,[r5,#0]            ;3923
002090  2850              CMP      r0,#0x50              ;3923
002092  d03b              BEQ      |L1.8460|
002094  dc0c              BGT      |L1.8368|
002096  2820              CMP      r0,#0x20              ;3923
002098  d060              BEQ      |L1.8540|
00209a  dc04              BGT      |L1.8358|
00209c  2800              CMP      r0,#0                 ;3923
00209e  d053              BEQ      |L1.8520|
0020a0  2810              CMP      r0,#0x10              ;3923
0020a2  d165              BNE      |L1.8560|
0020a4  e055              B        |L1.8530|
                  |L1.8358|
0020a6  2830              CMP      r0,#0x30              ;3923
0020a8  d05d              BEQ      |L1.8550|
0020aa  2840              CMP      r0,#0x40              ;3923
0020ac  d160              BNE      |L1.8560|
0020ae  e041              B        |L1.8500|
                  |L1.8368|
0020b0  2860              CMP      r0,#0x60              ;3923
0020b2  d035              BEQ      |L1.8480|
0020b4  2870              CMP      r0,#0x70              ;3923
0020b6  d00d              BEQ      |L1.8404|
0020b8  f5b05f80          CMP      r0,#0x1000            ;3923
0020bc  d003              BEQ      |L1.8390|
0020be  f5b05f00          CMP      r0,#0x2000            ;3923
0020c2  d155              BNE      |L1.8560|
0020c4  e015              B        |L1.8434|
                  |L1.8390|
0020c6  6820              LDR      r0,[r4,#0]            ;3929
0020c8  6880              LDR      r0,[r0,#8]            ;3929
0020ca  f0200007          BIC      r0,r0,#7              ;3929
0020ce  6821              LDR      r1,[r4,#0]            ;3929
0020d0  6088              STR      r0,[r1,#8]            ;3929
0020d2  e04e              B        |L1.8562|
                  |L1.8404|
0020d4  e9d51302          LDRD     r1,r3,[r5,#8]         ;3944
0020d8  686a              LDR      r2,[r5,#4]            ;3944
0020da  6820              LDR      r0,[r4,#0]            ;3944
0020dc  f7fffffe          BL       TIM_ETR_SetConfig
0020e0  6820              LDR      r0,[r4,#0]            ;3949
0020e2  6886              LDR      r6,[r0,#8]            ;3949
0020e4  f0260677          BIC      r6,r6,#0x77           ;3951
0020e8  f0460677          ORR      r6,r6,#0x77           ;3953
0020ec  6820              LDR      r0,[r4,#0]            ;3955
0020ee  6086              STR      r6,[r0,#8]            ;3955
0020f0  e03f              B        |L1.8562|
                  |L1.8434|
0020f2  e9d51302          LDRD     r1,r3,[r5,#8]         ;3970
0020f6  686a              LDR      r2,[r5,#4]            ;3970
0020f8  6820              LDR      r0,[r4,#0]            ;3970
0020fa  f7fffffe          BL       TIM_ETR_SetConfig
0020fe  6820              LDR      r0,[r4,#0]            ;3975
002100  6880              LDR      r0,[r0,#8]            ;3975
002102  f4404080          ORR      r0,r0,#0x4000         ;3975
002106  6821              LDR      r1,[r4,#0]            ;3975
002108  6088              STR      r0,[r1,#8]            ;3975
00210a  e032              B        |L1.8562|
                  |L1.8460|
00210c  68ea              LDR      r2,[r5,#0xc]          ;3988
00210e  6869              LDR      r1,[r5,#4]            ;3988
002110  6820              LDR      r0,[r4,#0]            ;3988
002112  f7fffffe          BL       TIM_TI1_ConfigInputStage
002116  2150              MOVS     r1,#0x50              ;3991
002118  6820              LDR      r0,[r4,#0]            ;3991
00211a  f7fffffe          BL       TIM_ITRx_SetConfig
00211e  e028              B        |L1.8562|
                  |L1.8480|
002120  68ea              LDR      r2,[r5,#0xc]          ;4003
002122  6869              LDR      r1,[r5,#4]            ;4003
002124  6820              LDR      r0,[r4,#0]            ;4003
002126  f7fffffe          BL       TIM_TI2_ConfigInputStage
00212a  2160              MOVS     r1,#0x60              ;4006
00212c  6820              LDR      r0,[r4,#0]            ;4006
00212e  f7fffffe          BL       TIM_ITRx_SetConfig
002132  e01e              B        |L1.8562|
                  |L1.8500|
002134  68ea              LDR      r2,[r5,#0xc]          ;4018
002136  6869              LDR      r1,[r5,#4]            ;4018
002138  6820              LDR      r0,[r4,#0]            ;4018
00213a  f7fffffe          BL       TIM_TI1_ConfigInputStage
00213e  2140              MOVS     r1,#0x40              ;4021
002140  6820              LDR      r0,[r4,#0]            ;4021
002142  f7fffffe          BL       TIM_ITRx_SetConfig
002146  e014              B        |L1.8562|
                  |L1.8520|
002148  2100              MOVS     r1,#0                 ;4029
00214a  6820              LDR      r0,[r4,#0]            ;4029
00214c  f7fffffe          BL       TIM_ITRx_SetConfig
002150  e00f              B        |L1.8562|
                  |L1.8530|
002152  2110              MOVS     r1,#0x10              ;4037
002154  6820              LDR      r0,[r4,#0]            ;4037
002156  f7fffffe          BL       TIM_ITRx_SetConfig
00215a  e00a              B        |L1.8562|
                  |L1.8540|
00215c  2120              MOVS     r1,#0x20              ;4045
00215e  6820              LDR      r0,[r4,#0]            ;4045
002160  f7fffffe          BL       TIM_ITRx_SetConfig
002164  e005              B        |L1.8562|
                  |L1.8550|
002166  2130              MOVS     r1,#0x30              ;4053
002168  6820              LDR      r0,[r4,#0]            ;4053
00216a  f7fffffe          BL       TIM_ITRx_SetConfig
00216e  e000              B        |L1.8562|
                  |L1.8560|
002170  bf00              NOP                            ;4058
                  |L1.8562|
002172  bf00              NOP                            ;3931
002174  2001              MOVS     r0,#1                 ;4060
002176  f8840039          STRB     r0,[r4,#0x39]         ;4060
00217a  bf00              NOP                            ;4062
00217c  2000              MOVS     r0,#0                 ;4062
00217e  f8840038          STRB     r0,[r4,#0x38]         ;4062
002182  bf00              NOP                            ;4062
002184  bf00              NOP                            ;4064
002186  e771              B        |L1.8300|
;;;4066   
                          ENDP

                  HAL_TIM_ConfigTI1Input PROC
;;;4078     */
;;;4079   HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
002188  4602              MOV      r2,r0
;;;4080   {
00218a  460b              MOV      r3,r1
;;;4081     uint32_t tmpcr2 = 0;
00218c  2100              MOVS     r1,#0
;;;4082   
;;;4083     /* Check the parameters */
;;;4084     assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
;;;4085     assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
;;;4086   
;;;4087     /* Get the TIMx CR2 register value */
;;;4088     tmpcr2 = htim->Instance->CR2;
00218e  6810              LDR      r0,[r2,#0]
002190  6841              LDR      r1,[r0,#4]
;;;4089   
;;;4090     /* Reset the TI1 selection */
;;;4091     tmpcr2 &= ~TIM_CR2_TI1S;
002192  f0210180          BIC      r1,r1,#0x80
;;;4092   
;;;4093     /* Set the the TI1 selection */
;;;4094     tmpcr2 |= TI1_Selection;
002196  4319              ORRS     r1,r1,r3
;;;4095   
;;;4096     /* Write to TIMxCR2 */
;;;4097     htim->Instance->CR2 = tmpcr2;
002198  6810              LDR      r0,[r2,#0]
00219a  6041              STR      r1,[r0,#4]
;;;4098   
;;;4099     return HAL_OK;
00219c  2000              MOVS     r0,#0
;;;4100   }
00219e  4770              BX       lr
;;;4101   
                          ENDP

                  TIM_SlaveTimer_SetConfig PROC
;;;4881     */
;;;4882   static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
0021a0  e92d41f0          PUSH     {r4-r8,lr}
;;;4883                                 TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4884   {
0021a4  4604              MOV      r4,r0
0021a6  460d              MOV      r5,r1
;;;4885     uint32_t tmpsmcr = 0;
0021a8  2600              MOVS     r6,#0
;;;4886     uint32_t tmpccmr1 = 0;
0021aa  2700              MOVS     r7,#0
;;;4887     uint32_t tmpccer = 0;
0021ac  46b0              MOV      r8,r6
;;;4888   
;;;4889     /* Get the TIMx SMCR register value */
;;;4890     tmpsmcr = htim->Instance->SMCR;
0021ae  6820              LDR      r0,[r4,#0]
0021b0  6886              LDR      r6,[r0,#8]
;;;4891   
;;;4892     /* Reset the Trigger Selection Bits */
;;;4893     tmpsmcr &= ~TIM_SMCR_TS;
0021b2  f0260670          BIC      r6,r6,#0x70
;;;4894     /* Set the Input Trigger source */
;;;4895     tmpsmcr |= sSlaveConfig->InputTrigger;
0021b6  6868              LDR      r0,[r5,#4]
0021b8  4306              ORRS     r6,r6,r0
;;;4896   
;;;4897     /* Reset the slave mode Bits */
;;;4898     tmpsmcr &= ~TIM_SMCR_SMS;
0021ba  f0260607          BIC      r6,r6,#7
;;;4899     /* Set the slave mode */
;;;4900     tmpsmcr |= sSlaveConfig->SlaveMode;
0021be  6828              LDR      r0,[r5,#0]
0021c0  4306              ORRS     r6,r6,r0
;;;4901   
;;;4902     /* Write to TIMx SMCR */
;;;4903     htim->Instance->SMCR = tmpsmcr;
0021c2  6820              LDR      r0,[r4,#0]
0021c4  6086              STR      r6,[r0,#8]
;;;4904   
;;;4905     /* Configure the trigger prescaler, filter, and polarity */
;;;4906     switch (sSlaveConfig->InputTrigger)
0021c6  6868              LDR      r0,[r5,#4]
0021c8  f000010f          AND      r1,r0,#0xf
0021cc  2900              CMP      r1,#0
0021ce  d135              BNE      |L1.8764|
0021d0  1100              ASRS     r0,r0,#4
0021d2  2808              CMP      r0,#8
0021d4  d232              BCS      |L1.8764|
0021d6  e8dff000          TBB      [pc,r0]
0021da  2d2e              DCB      0x2d,0x2e
0021dc  2f300b21          DCB      0x2f,0x30,0x0b,0x21
0021e0  2704              DCB      0x27,0x04
;;;4907     {
;;;4908     case TIM_TS_ETRF:
;;;4909       {
;;;4910         /* Check the parameters */
;;;4911         assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
;;;4912         assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
;;;4913         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4914         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4915         /* Configure the ETR Trigger source */
;;;4916         TIM_ETR_SetConfig(htim->Instance,
0021e2  e9d51303          LDRD     r1,r3,[r5,#0xc]
0021e6  68aa              LDR      r2,[r5,#8]
0021e8  6820              LDR      r0,[r4,#0]
0021ea  f7fffffe          BL       TIM_ETR_SetConfig
;;;4917                           sSlaveConfig->TriggerPrescaler,
;;;4918                           sSlaveConfig->TriggerPolarity,
;;;4919                           sSlaveConfig->TriggerFilter);
;;;4920       }
;;;4921       break;
0021ee  e026              B        |L1.8766|
;;;4922   
;;;4923     case TIM_TS_TI1F_ED:
;;;4924       {
;;;4925         /* Check the parameters */
;;;4926         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4927         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4928   
;;;4929         /* Disable the Channel 1: Reset the CC1E Bit */
;;;4930         tmpccer = htim->Instance->CCER;
0021f0  6820              LDR      r0,[r4,#0]
0021f2  f8d08020          LDR      r8,[r0,#0x20]
;;;4931         htim->Instance->CCER &= ~TIM_CCER_CC1E;
0021f6  6820              LDR      r0,[r4,#0]
0021f8  6a00              LDR      r0,[r0,#0x20]
0021fa  f0200001          BIC      r0,r0,#1
0021fe  6821              LDR      r1,[r4,#0]
002200  6208              STR      r0,[r1,#0x20]
;;;4932         tmpccmr1 = htim->Instance->CCMR1;
002202  6820              LDR      r0,[r4,#0]
002204  6987              LDR      r7,[r0,#0x18]
;;;4933   
;;;4934         /* Set the filter */
;;;4935         tmpccmr1 &= ~TIM_CCMR1_IC1F;
002206  f02707f0          BIC      r7,r7,#0xf0
;;;4936         tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4);
00220a  6928              LDR      r0,[r5,#0x10]
00220c  ea471700          ORR      r7,r7,r0,LSL #4
;;;4937   
;;;4938         /* Write to TIMx CCMR1 and CCER registers */
;;;4939         htim->Instance->CCMR1 = tmpccmr1;
002210  6820              LDR      r0,[r4,#0]
002212  6187              STR      r7,[r0,#0x18]
;;;4940         htim->Instance->CCER = tmpccer;
002214  6820              LDR      r0,[r4,#0]
002216  f8c08020          STR      r8,[r0,#0x20]
;;;4941   
;;;4942       }
;;;4943       break;
00221a  e010              B        |L1.8766|
;;;4944   
;;;4945     case TIM_TS_TI1FP1:
;;;4946       {
;;;4947         /* Check the parameters */
;;;4948         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4949         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4950         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4951   
;;;4952         /* Configure TI1 Filter and Polarity */
;;;4953         TIM_TI1_ConfigInputStage(htim->Instance,
00221c  692a              LDR      r2,[r5,#0x10]
00221e  68a9              LDR      r1,[r5,#8]
002220  6820              LDR      r0,[r4,#0]
002222  f7fffffe          BL       TIM_TI1_ConfigInputStage
;;;4954                                  sSlaveConfig->TriggerPolarity,
;;;4955                                  sSlaveConfig->TriggerFilter);
;;;4956       }
;;;4957       break;
002226  e00a              B        |L1.8766|
;;;4958   
;;;4959     case TIM_TS_TI2FP2:
;;;4960       {
;;;4961         /* Check the parameters */
;;;4962         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4963         assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
;;;4964         assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
;;;4965   
;;;4966         /* Configure TI2 Filter and Polarity */
;;;4967         TIM_TI2_ConfigInputStage(htim->Instance,
002228  692a              LDR      r2,[r5,#0x10]
00222a  68a9              LDR      r1,[r5,#8]
00222c  6820              LDR      r0,[r4,#0]
00222e  f7fffffe          BL       TIM_TI2_ConfigInputStage
;;;4968                                   sSlaveConfig->TriggerPolarity,
;;;4969                                   sSlaveConfig->TriggerFilter);
;;;4970       }
;;;4971       break;
002232  e004              B        |L1.8766|
;;;4972   
;;;4973     case TIM_TS_ITR0:
;;;4974       {
;;;4975         /* Check the parameter */
;;;4976         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4977       }
;;;4978       break;
002234  e003              B        |L1.8766|
;;;4979   
;;;4980     case TIM_TS_ITR1:
;;;4981       {
;;;4982         /* Check the parameter */
;;;4983         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4984       }
;;;4985       break;
002236  e002              B        |L1.8766|
;;;4986   
;;;4987     case TIM_TS_ITR2:
;;;4988       {
;;;4989         /* Check the parameter */
;;;4990         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4991       }
;;;4992       break;
002238  e001              B        |L1.8766|
;;;4993   
;;;4994     case TIM_TS_ITR3:
;;;4995       {
;;;4996         /* Check the parameter */
;;;4997         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4998       }
;;;4999       break;
00223a  e000              B        |L1.8766|
                  |L1.8764|
;;;5000   
;;;5001     default:
;;;5002       break;
00223c  bf00              NOP      
                  |L1.8766|
00223e  bf00              NOP                            ;4921
;;;5003     }
;;;5004   }
002240  e8bd81f0          POP      {r4-r8,pc}
;;;5005   
                          ENDP

                  HAL_TIM_SlaveConfigSynchronization PROC
;;;4110     */
;;;4111   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
002244  b570              PUSH     {r4-r6,lr}
;;;4112   {
002246  4604              MOV      r4,r0
002248  460d              MOV      r5,r1
;;;4113     /* Check the parameters */
;;;4114     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4115     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4116     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4117   
;;;4118     __HAL_LOCK(htim);
00224a  bf00              NOP      
00224c  f8940038          LDRB     r0,[r4,#0x38]
002250  2801              CMP      r0,#1
002252  d101              BNE      |L1.8792|
002254  2002              MOVS     r0,#2
                  |L1.8790|
;;;4119   
;;;4120     htim->State = HAL_TIM_STATE_BUSY;
;;;4121   
;;;4122     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4123   
;;;4124     /* Disable Trigger Interrupt */
;;;4125     __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
;;;4126   
;;;4127     /* Disable Trigger DMA request */
;;;4128     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4129   
;;;4130     htim->State = HAL_TIM_STATE_READY;
;;;4131   
;;;4132     __HAL_UNLOCK(htim);
;;;4133   
;;;4134     return HAL_OK;
;;;4135       }
002256  bd70              POP      {r4-r6,pc}
                  |L1.8792|
002258  2001              MOVS     r0,#1                 ;4118
00225a  f8840038          STRB     r0,[r4,#0x38]         ;4118
00225e  bf00              NOP                            ;4118
002260  2002              MOVS     r0,#2                 ;4120
002262  f8840039          STRB     r0,[r4,#0x39]         ;4120
002266  4629              MOV      r1,r5                 ;4122
002268  4620              MOV      r0,r4                 ;4122
00226a  f7fffffe          BL       TIM_SlaveTimer_SetConfig
00226e  6820              LDR      r0,[r4,#0]            ;4125
002270  68c0              LDR      r0,[r0,#0xc]          ;4125
002272  f0200040          BIC      r0,r0,#0x40           ;4125
002276  6821              LDR      r1,[r4,#0]            ;4125
002278  60c8              STR      r0,[r1,#0xc]          ;4125
00227a  6820              LDR      r0,[r4,#0]            ;4128
00227c  68c0              LDR      r0,[r0,#0xc]          ;4128
00227e  f4204080          BIC      r0,r0,#0x4000         ;4128
002282  6821              LDR      r1,[r4,#0]            ;4128
002284  60c8              STR      r0,[r1,#0xc]          ;4128
002286  2001              MOVS     r0,#1                 ;4130
002288  f8840039          STRB     r0,[r4,#0x39]         ;4130
00228c  bf00              NOP                            ;4132
00228e  2000              MOVS     r0,#0                 ;4132
002290  f8840038          STRB     r0,[r4,#0x38]         ;4132
002294  bf00              NOP                            ;4132
002296  bf00              NOP                            ;4134
002298  e7dd              B        |L1.8790|
;;;4136   
                          ENDP

                  HAL_TIM_SlaveConfigSynchronization_IT PROC
;;;4145     */
;;;4146   HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
00229a  b570              PUSH     {r4-r6,lr}
;;;4147                                                           TIM_SlaveConfigTypeDef * sSlaveConfig)
;;;4148       {
00229c  4604              MOV      r4,r0
00229e  460d              MOV      r5,r1
;;;4149         /* Check the parameters */
;;;4150     assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
;;;4151     assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
;;;4152     assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
;;;4153   
;;;4154     __HAL_LOCK(htim);
0022a0  bf00              NOP      
0022a2  f8940038          LDRB     r0,[r4,#0x38]
0022a6  2801              CMP      r0,#1
0022a8  d101              BNE      |L1.8878|
0022aa  2002              MOVS     r0,#2
                  |L1.8876|
;;;4155   
;;;4156     htim->State = HAL_TIM_STATE_BUSY;
;;;4157   
;;;4158     TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
;;;4159   
;;;4160     /* Enable Trigger Interrupt */
;;;4161     __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
;;;4162   
;;;4163     /* Disable Trigger DMA request */
;;;4164     __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
;;;4165   
;;;4166     htim->State = HAL_TIM_STATE_READY;
;;;4167   
;;;4168     __HAL_UNLOCK(htim);
;;;4169   
;;;4170     return HAL_OK;
;;;4171   }
0022ac  bd70              POP      {r4-r6,pc}
                  |L1.8878|
0022ae  2001              MOVS     r0,#1                 ;4154
0022b0  f8840038          STRB     r0,[r4,#0x38]         ;4154
0022b4  bf00              NOP                            ;4154
0022b6  2002              MOVS     r0,#2                 ;4156
0022b8  f8840039          STRB     r0,[r4,#0x39]         ;4156
0022bc  4629              MOV      r1,r5                 ;4158
0022be  4620              MOV      r0,r4                 ;4158
0022c0  f7fffffe          BL       TIM_SlaveTimer_SetConfig
0022c4  6820              LDR      r0,[r4,#0]            ;4161
0022c6  68c0              LDR      r0,[r0,#0xc]          ;4161
0022c8  f0400040          ORR      r0,r0,#0x40           ;4161
0022cc  6821              LDR      r1,[r4,#0]            ;4161
0022ce  60c8              STR      r0,[r1,#0xc]          ;4161
0022d0  6820              LDR      r0,[r4,#0]            ;4164
0022d2  68c0              LDR      r0,[r0,#0xc]          ;4164
0022d4  f4204080          BIC      r0,r0,#0x4000         ;4164
0022d8  6821              LDR      r1,[r4,#0]            ;4164
0022da  60c8              STR      r0,[r1,#0xc]          ;4164
0022dc  2001              MOVS     r0,#1                 ;4166
0022de  f8840039          STRB     r0,[r4,#0x39]         ;4166
0022e2  bf00              NOP                            ;4168
0022e4  2000              MOVS     r0,#0                 ;4168
0022e6  f8840038          STRB     r0,[r4,#0x38]         ;4168
0022ea  bf00              NOP                            ;4168
0022ec  bf00              NOP                            ;4170
0022ee  e7dd              B        |L1.8876|
;;;4172   
                          ENDP

                  HAL_TIM_ReadCapturedValue PROC
;;;4183     */
;;;4184   uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
0022f0  4602              MOV      r2,r0
;;;4185   {
;;;4186     uint32_t tmpreg = 0;
0022f2  2300              MOVS     r3,#0
;;;4187   
;;;4188     __HAL_LOCK(htim);
0022f4  bf00              NOP      
0022f6  f8920038          LDRB     r0,[r2,#0x38]
0022fa  2801              CMP      r0,#1
0022fc  d101              BNE      |L1.8962|
0022fe  2002              MOVS     r0,#2
                  |L1.8960|
;;;4189   
;;;4190     switch (Channel)
;;;4191     {
;;;4192     case TIM_CHANNEL_1:
;;;4193       {
;;;4194         /* Check the parameters */
;;;4195         assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
;;;4196   
;;;4197         /* Return the capture 1 value */
;;;4198         tmpreg =  htim->Instance->CCR1;
;;;4199   
;;;4200         break;
;;;4201       }
;;;4202     case TIM_CHANNEL_2:
;;;4203       {
;;;4204         /* Check the parameters */
;;;4205         assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
;;;4206   
;;;4207         /* Return the capture 2 value */
;;;4208         tmpreg =   htim->Instance->CCR2;
;;;4209   
;;;4210         break;
;;;4211       }
;;;4212   
;;;4213     case TIM_CHANNEL_3:
;;;4214       {
;;;4215         /* Check the parameters */
;;;4216         assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
;;;4217   
;;;4218         /* Return the capture 3 value */
;;;4219         tmpreg =   htim->Instance->CCR3;
;;;4220   
;;;4221         break;
;;;4222       }
;;;4223   
;;;4224     case TIM_CHANNEL_4:
;;;4225       {
;;;4226         /* Check the parameters */
;;;4227         assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
;;;4228   
;;;4229         /* Return the capture 4 value */
;;;4230         tmpreg =   htim->Instance->CCR4;
;;;4231   
;;;4232         break;
;;;4233       }
;;;4234   
;;;4235     default:
;;;4236       break;
;;;4237     }
;;;4238   
;;;4239     __HAL_UNLOCK(htim);
;;;4240     return tmpreg;
;;;4241   }
002300  4770              BX       lr
                  |L1.8962|
002302  2001              MOVS     r0,#1                 ;4188
002304  f8820038          STRB     r0,[r2,#0x38]         ;4188
002308  bf00              NOP                            ;4188
00230a  b131              CBZ      r1,|L1.8986|
00230c  2904              CMP      r1,#4                 ;4190
00230e  d007              BEQ      |L1.8992|
002310  2908              CMP      r1,#8                 ;4190
002312  d008              BEQ      |L1.8998|
002314  290c              CMP      r1,#0xc               ;4190
002316  d10c              BNE      |L1.9010|
002318  e008              B        |L1.9004|
                  |L1.8986|
00231a  6810              LDR      r0,[r2,#0]            ;4198
00231c  6b43              LDR      r3,[r0,#0x34]         ;4198
00231e  e009              B        |L1.9012|
                  |L1.8992|
002320  6810              LDR      r0,[r2,#0]            ;4208
002322  6b83              LDR      r3,[r0,#0x38]         ;4208
002324  e006              B        |L1.9012|
                  |L1.8998|
002326  6810              LDR      r0,[r2,#0]            ;4219
002328  6bc3              LDR      r3,[r0,#0x3c]         ;4219
00232a  e003              B        |L1.9012|
                  |L1.9004|
00232c  6810              LDR      r0,[r2,#0]            ;4230
00232e  6c03              LDR      r3,[r0,#0x40]         ;4230
002330  e000              B        |L1.9012|
                  |L1.9010|
002332  bf00              NOP                            ;4236
                  |L1.9012|
002334  bf00              NOP                            ;4200
002336  bf00              NOP                            ;4239
002338  2000              MOVS     r0,#0                 ;4239
00233a  f8820038          STRB     r0,[r2,#0x38]         ;4239
00233e  bf00              NOP                            ;4239
002340  4618              MOV      r0,r3                 ;4240
002342  e7dd              B        |L1.8960|
;;;4242   
                          ENDP

                  HAL_TIM_Base_GetState PROC
;;;4372     */
;;;4373   HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
002344  4601              MOV      r1,r0
;;;4374   {
;;;4375     return htim->State;
002346  f8910039          LDRB     r0,[r1,#0x39]
;;;4376   }
00234a  4770              BX       lr
;;;4377   
                          ENDP

                  HAL_TIM_OC_GetState PROC
;;;4382     */
;;;4383   HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
00234c  4601              MOV      r1,r0
;;;4384   {
;;;4385     return htim->State;
00234e  f8910039          LDRB     r0,[r1,#0x39]
;;;4386   }
002352  4770              BX       lr
;;;4387   
                          ENDP

                  HAL_TIM_PWM_GetState PROC
;;;4392     */
;;;4393   HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
002354  4601              MOV      r1,r0
;;;4394   {
;;;4395     return htim->State;
002356  f8910039          LDRB     r0,[r1,#0x39]
;;;4396   }
00235a  4770              BX       lr
;;;4397   
                          ENDP

                  HAL_TIM_IC_GetState PROC
;;;4402     */
;;;4403   HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
00235c  4601              MOV      r1,r0
;;;4404   {
;;;4405     return htim->State;
00235e  f8910039          LDRB     r0,[r1,#0x39]
;;;4406   }
002362  4770              BX       lr
;;;4407   
                          ENDP

                  HAL_TIM_OnePulse_GetState PROC
;;;4412     */
;;;4413   HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
002364  4601              MOV      r1,r0
;;;4414   {
;;;4415     return htim->State;
002366  f8910039          LDRB     r0,[r1,#0x39]
;;;4416   }
00236a  4770              BX       lr
;;;4417   
                          ENDP

                  HAL_TIM_Encoder_GetState PROC
;;;4422     */
;;;4423   HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
00236c  4601              MOV      r1,r0
;;;4424   {
;;;4425     return htim->State;
00236e  f8910039          LDRB     r0,[r1,#0x39]
;;;4426   }
002372  4770              BX       lr
;;;4427   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH|
#line 402
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX|
#line 587
|__asm___19_stm32f1xx_hal_tim_c_a9d95b52____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
