; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_rcc_ex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_rcc_ex.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_rcc_ex.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;117      */
;;;118    HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  b5f8              PUSH     {r3-r7,lr}
;;;119    {
000002  4604              MOV      r4,r0
;;;120      uint32_t tickstart = 0, temp_reg = 0;
000004  2600              MOVS     r6,#0
000006  2500              MOVS     r5,#0
;;;121    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;122      uint32_t  pllactive = 0;
;;;123    #endif /* STM32F105xC || STM32F107xC */
;;;124    
;;;125      /* Check the parameters */
;;;126      assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;127      
;;;128      /*------------------------------- RTC/LCD Configuration ------------------------*/ 
;;;129      if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
000008  7820              LDRB     r0,[r4,#0]
00000a  f0000001          AND      r0,r0,#1
00000e  2800              CMP      r0,#0
000010  d076              BEQ      |L1.256|
;;;130      {
;;;131        /* check for RTC Parameters used to output RTCCLK */
;;;132        assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;133    
;;;134        /* Enable Power Clock*/
;;;135        __HAL_RCC_PWR_CLK_ENABLE();
000012  bf00              NOP      
000014  487c              LDR      r0,|L1.520|
000016  69c0              LDR      r0,[r0,#0x1c]
000018  f0405080          ORR      r0,r0,#0x10000000
00001c  497a              LDR      r1,|L1.520|
00001e  61c8              STR      r0,[r1,#0x1c]
000020  4608              MOV      r0,r1
000022  69c0              LDR      r0,[r0,#0x1c]
000024  f0005080          AND      r0,r0,#0x10000000
000028  9000              STR      r0,[sp,#0]
00002a  bf00              NOP      
00002c  bf00              NOP      
;;;136        
;;;137        /* Enable write access to Backup domain */
;;;138        SET_BIT(PWR->CR, PWR_CR_DBP);
00002e  4877              LDR      r0,|L1.524|
000030  6800              LDR      r0,[r0,#0]
000032  f4407080          ORR      r0,r0,#0x100
000036  4975              LDR      r1,|L1.524|
000038  6008              STR      r0,[r1,#0]
;;;139        
;;;140        /* Wait for Backup domain Write protection disable */
;;;141        tickstart = HAL_GetTick();
00003a  f7fffffe          BL       HAL_GetTick
00003e  4606              MOV      r6,r0
;;;142        
;;;143        while((PWR->CR & PWR_CR_DBP) == RESET)
000040  e006              B        |L1.80|
                  |L1.66|
;;;144        {
;;;145          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
000042  f7fffffe          BL       HAL_GetTick
000046  1b80              SUBS     r0,r0,r6
000048  2864              CMP      r0,#0x64
00004a  d901              BLS      |L1.80|
;;;146          {
;;;147            return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
                  |L1.78|
;;;148          }      
;;;149        }
;;;150          
;;;151        /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
;;;152        temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
;;;153        if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
;;;154        {
;;;155          /* Store the content of BDCR register before the reset of Backup Domain */
;;;156          temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
;;;157          /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;158          __HAL_RCC_BACKUPRESET_FORCE();
;;;159          __HAL_RCC_BACKUPRESET_RELEASE();
;;;160          /* Restore the Content of BDCR register */
;;;161          RCC->BDCR = temp_reg;
;;;162    
;;;163          /* Wait for LSERDY if LSE was enabled */
;;;164          if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
;;;165          {
;;;166            /* Get timeout */
;;;167            tickstart = HAL_GetTick();
;;;168          
;;;169            /* Wait till LSE is ready */  
;;;170            while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
;;;171            {
;;;172              if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
;;;173              {
;;;174                return HAL_TIMEOUT;
;;;175              }      
;;;176            }  
;;;177          }
;;;178        }
;;;179        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
;;;180      }
;;;181    
;;;182      /*------------------------------ ADC clock Configuration ------------------*/ 
;;;183      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
;;;184      {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));
;;;187        
;;;188        /* Configure the ADC clock source */
;;;189        __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
;;;190      }
;;;191    
;;;192    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;193      /*------------------------------ I2S2 Configuration ------------------------*/ 
;;;194      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == RCC_PERIPHCLK_I2S2)
;;;195      {
;;;196        /* Check the parameters */
;;;197        assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));
;;;198    
;;;199        /* Configure the I2S2 clock source */
;;;200        __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);
;;;201      }
;;;202    
;;;203      /*------------------------------ I2S3 Configuration ------------------------*/ 
;;;204      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S3) == RCC_PERIPHCLK_I2S3)
;;;205      {
;;;206        /* Check the parameters */
;;;207        assert_param(IS_RCC_I2S3CLKSOURCE(PeriphClkInit->I2s3ClockSelection));
;;;208        
;;;209        /* Configure the I2S3 clock source */
;;;210        __HAL_RCC_I2S3_CONFIG(PeriphClkInit->I2s3ClockSelection);
;;;211      }
;;;212    
;;;213      /*------------------------------ PLL I2S Configuration ----------------------*/ 
;;;214      /* Check that PLLI2S need to be enabled */
;;;215      if (HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S2SRC) || HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_I2S3SRC))
;;;216      {
;;;217        /* Update flag to indicate that PLL I2S should be active */
;;;218        pllactive = 1;
;;;219      }
;;;220    
;;;221      /* Check if PLL I2S need to be enabled */
;;;222      if (pllactive == 1)
;;;223      {
;;;224        /* Enable PLL I2S only if not active */
;;;225        if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_PLL3ON))
;;;226        {
;;;227          /* Check the parameters */
;;;228          assert_param(IS_RCC_PLLI2S_MUL(PeriphClkInit->PLLI2S.PLLI2SMUL));
;;;229          assert_param(IS_RCC_HSE_PREDIV2(PeriphClkInit->PLLI2S.HSEPrediv2Value));
;;;230    
;;;231          /* Prediv2 can be written only when the PLL2 is disabled. */
;;;232          /* Return an error only if new value is different from the programmed value */
;;;233          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLL2ON) && \
;;;234            (__HAL_RCC_HSE_GET_PREDIV2() != PeriphClkInit->PLLI2S.HSEPrediv2Value))
;;;235          {
;;;236            return HAL_ERROR;
;;;237          }
;;;238    
;;;239          /* Configure the HSE prediv2 factor --------------------------------*/
;;;240          __HAL_RCC_HSE_PREDIV2_CONFIG(PeriphClkInit->PLLI2S.HSEPrediv2Value);
;;;241    
;;;242          /* Configure the main PLLI2S multiplication factors. */
;;;243          __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SMUL);
;;;244          
;;;245          /* Enable the main PLLI2S. */
;;;246          __HAL_RCC_PLLI2S_ENABLE();
;;;247          
;;;248          /* Get Start Tick*/
;;;249          tickstart = HAL_GetTick();
;;;250          
;;;251          /* Wait till PLLI2S is ready */
;;;252          while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
;;;253          {
;;;254            if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;255            {
;;;256              return HAL_TIMEOUT;
;;;257            }
;;;258          }
;;;259        }
;;;260        else
;;;261        {
;;;262          /* Return an error only if user wants to change the PLLI2SMUL whereas PLLI2S is active */
;;;263          if (READ_BIT(RCC->CFGR2, RCC_CFGR2_PLL3MUL) != PeriphClkInit->PLLI2S.PLLI2SMUL)
;;;264          {
;;;265              return HAL_ERROR;
;;;266          }
;;;267        }
;;;268      }
;;;269    #endif /* STM32F105xC || STM32F107xC */
;;;270    
;;;271    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;272     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;273     || defined(STM32F105xC) || defined(STM32F107xC)
;;;274      /*------------------------------ USB clock Configuration ------------------*/ 
;;;275      if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
;;;276      {
;;;277        /* Check the parameters */
;;;278        assert_param(IS_RCC_USBPLLCLK_DIV(PeriphClkInit->UsbClockSelection));
;;;279        
;;;280        /* Configure the USB clock source */
;;;281        __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
;;;282      }
;;;283    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;284    
;;;285      return HAL_OK;
;;;286    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L1.80|
000050  486e              LDR      r0,|L1.524|
000052  6800              LDR      r0,[r0,#0]            ;143
000054  f4007080          AND      r0,r0,#0x100          ;143
000058  2800              CMP      r0,#0                 ;143
00005a  d0f2              BEQ      |L1.66|
00005c  486a              LDR      r0,|L1.520|
00005e  6a00              LDR      r0,[r0,#0x20]         ;152
000060  f4007540          AND      r5,r0,#0x300          ;152
000064  2d00              CMP      r5,#0                 ;153
000066  d05d              BEQ      |L1.292|
000068  88a0              LDRH     r0,[r4,#4]            ;153
00006a  f4007040          AND      r0,r0,#0x300          ;153
00006e  42a8              CMP      r0,r5                 ;153
000070  d058              BEQ      |L1.292|
000072  4865              LDR      r0,|L1.520|
000074  6a00              LDR      r0,[r0,#0x20]         ;156
000076  f4207540          BIC      r5,r0,#0x300          ;156
00007a  2101              MOVS     r1,#1                 ;158
00007c  0408              LSLS     r0,r1,#16             ;158
00007e  fa90f0a0          RBIT     r0,r0                 ;158
000082  fab0f080          CLZ      r0,r0                 ;158
000086  4a62              LDR      r2,|L1.528|
000088  eb020080          ADD      r0,r2,r0,LSL #2       ;158
00008c  f8c01400          STR      r1,[r0,#0x400]        ;158
000090  2000              MOVS     r0,#0                 ;159
000092  0409              LSLS     r1,r1,#16             ;159
000094  fa91f1a1          RBIT     r1,r1                 ;159
000098  fab1f181          CLZ      r1,r1                 ;159
00009c  eb020181          ADD      r1,r2,r1,LSL #2       ;159
0000a0  f8c10400          STR      r0,[r1,#0x400]        ;159
0000a4  4858              LDR      r0,|L1.520|
0000a6  6205              STR      r5,[r0,#0x20]         ;161
0000a8  f0050001          AND      r0,r5,#1              ;164
0000ac  b348              CBZ      r0,|L1.258|
0000ae  f7fffffe          BL       HAL_GetTick
0000b2  4606              MOV      r6,r0                 ;167
0000b4  e008              B        |L1.200|
                  |L1.182|
0000b6  f7fffffe          BL       HAL_GetTick
0000ba  1b80              SUBS     r0,r0,r6              ;172
0000bc  f2413188          MOV      r1,#0x1388            ;172
0000c0  4288              CMP      r0,r1                 ;172
0000c2  d901              BLS      |L1.200|
0000c4  2003              MOVS     r0,#3                 ;174
0000c6  e7c2              B        |L1.78|
                  |L1.200|
0000c8  2040              MOVS     r0,#0x40              ;170
0000ca  2102              MOVS     r1,#2                 ;170
0000cc  fa91f1a1          RBIT     r1,r1                 ;170
0000d0  fab1f181          CLZ      r1,r1                 ;170
0000d4  4308              ORRS     r0,r0,r1              ;170
0000d6  2101              MOVS     r1,#1                 ;170
0000d8  ebb11f60          CMP      r1,r0,ASR #5          ;170
0000dc  d102              BNE      |L1.228|
0000de  484a              LDR      r0,|L1.520|
0000e0  6800              LDR      r0,[r0,#0]            ;170
0000e2  e011              B        |L1.264|
                  |L1.228|
0000e4  2040              MOVS     r0,#0x40              ;170
0000e6  2102              MOVS     r1,#2                 ;170
0000e8  fa91f1a1          RBIT     r1,r1                 ;170
0000ec  fab1f181          CLZ      r1,r1                 ;170
0000f0  4308              ORRS     r0,r0,r1              ;170
0000f2  2102              MOVS     r1,#2                 ;170
0000f4  ebb11f60          CMP      r1,r0,ASR #5          ;170
0000f8  d104              BNE      |L1.260|
0000fa  4843              LDR      r0,|L1.520|
0000fc  6a00              LDR      r0,[r0,#0x20]         ;170
0000fe  e003              B        |L1.264|
                  |L1.256|
000100  e018              B        |L1.308|
                  |L1.258|
000102  e00f              B        |L1.292|
                  |L1.260|
000104  4840              LDR      r0,|L1.520|
000106  6a40              LDR      r0,[r0,#0x24]         ;170
                  |L1.264|
000108  2140              MOVS     r1,#0x40              ;170
00010a  2202              MOVS     r2,#2                 ;170
00010c  fa92f2a2          RBIT     r2,r2                 ;170
000110  fab2f282          CLZ      r2,r2                 ;170
000114  4311              ORRS     r1,r1,r2              ;170
000116  f001021f          AND      r2,r1,#0x1f           ;170
00011a  2101              MOVS     r1,#1                 ;170
00011c  4091              LSLS     r1,r1,r2              ;170
00011e  4008              ANDS     r0,r0,r1              ;170
000120  2800              CMP      r0,#0                 ;170
000122  d0c8              BEQ      |L1.182|
                  |L1.292|
000124  4838              LDR      r0,|L1.520|
000126  6a00              LDR      r0,[r0,#0x20]         ;179
000128  f4207040          BIC      r0,r0,#0x300          ;179
00012c  6861              LDR      r1,[r4,#4]            ;179
00012e  4308              ORRS     r0,r0,r1              ;179
000130  4935              LDR      r1,|L1.520|
000132  6208              STR      r0,[r1,#0x20]         ;179
                  |L1.308|
000134  7820              LDRB     r0,[r4,#0]            ;183
000136  f0000002          AND      r0,r0,#2              ;183
00013a  2802              CMP      r0,#2                 ;183
00013c  d107              BNE      |L1.334|
00013e  4832              LDR      r0,|L1.520|
000140  6840              LDR      r0,[r0,#4]            ;189
000142  f4204040          BIC      r0,r0,#0xc000         ;189
000146  68a1              LDR      r1,[r4,#8]            ;189
000148  4308              ORRS     r0,r0,r1              ;189
00014a  492f              LDR      r1,|L1.520|
00014c  6048              STR      r0,[r1,#4]            ;189
                  |L1.334|
00014e  2000              MOVS     r0,#0                 ;285
000150  e77d              B        |L1.78|
;;;287    
                          ENDP

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;294      */
;;;295    void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000152  2100              MOVS     r1,#0
;;;296    {
;;;297      uint32_t srcclk = 0;
;;;298      
;;;299      /* Set all possible values for the extended clock type parameter------------*/
;;;300      PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_RTC;
000154  2201              MOVS     r2,#1
000156  6002              STR      r2,[r0,#0]
;;;301    
;;;302      /* Get the RTC configuration -----------------------------------------------*/
;;;303      srcclk = __HAL_RCC_GET_RTC_SOURCE();
000158  4a2b              LDR      r2,|L1.520|
00015a  6a12              LDR      r2,[r2,#0x20]
00015c  f4027140          AND      r1,r2,#0x300
;;;304      /* Source clock is LSE or LSI*/
;;;305      PeriphClkInit->RTCClockSelection = srcclk;
000160  6041              STR      r1,[r0,#4]
;;;306    
;;;307      /* Get the ADC clock configuration -----------------------------------------*/
;;;308      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_ADC;
000162  6802              LDR      r2,[r0,#0]
000164  f0420202          ORR      r2,r2,#2
000168  6002              STR      r2,[r0,#0]
;;;309      PeriphClkInit->AdcClockSelection = __HAL_RCC_GET_ADC_SOURCE();
00016a  4a27              LDR      r2,|L1.520|
00016c  6852              LDR      r2,[r2,#4]
00016e  f4024240          AND      r2,r2,#0xc000
000172  6082              STR      r2,[r0,#8]
;;;310    
;;;311    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;312      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;313      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;314      PeriphClkInit->I2s2ClockSelection = __HAL_RCC_GET_I2S2_SOURCE();
;;;315    
;;;316      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;317      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;318      PeriphClkInit->I2s3ClockSelection = __HAL_RCC_GET_I2S3_SOURCE();
;;;319    
;;;320    #endif /* STM32F105xC || STM32F107xC */
;;;321    
;;;322    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;323      /* Get the I2S2 clock configuration -----------------------------------------*/
;;;324      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S2;
;;;325      PeriphClkInit->I2s2ClockSelection = RCC_I2S2CLKSOURCE_SYSCLK;
;;;326    
;;;327      /* Get the I2S3 clock configuration -----------------------------------------*/
;;;328      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2S3;
;;;329      PeriphClkInit->I2s3ClockSelection = RCC_I2S3CLKSOURCE_SYSCLK;
;;;330    
;;;331    #endif /* STM32F103xE || STM32F103xG */
;;;332    
;;;333    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;334     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;335     || defined(STM32F105xC) || defined(STM32F107xC)
;;;336      /* Get the USB clock configuration -----------------------------------------*/
;;;337      PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_USB;
;;;338      PeriphClkInit->UsbClockSelection = __HAL_RCC_GET_USB_SOURCE();
;;;339    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;340    }
000174  4770              BX       lr
;;;341    
                          ENDP

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;387      */
;;;388    uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000176  b570              PUSH     {r4-r6,lr}
;;;389    {
000178  4605              MOV      r5,r0
;;;390    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;391     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;392     || defined(STM32F105xC) || defined(STM32F107xC)
;;;393    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;394      const uint8_t aPLLMULFactorTable[12] = {0, 0, 4,  5,  6,  7,  8,  9, 0, 0, 0, 13};
;;;395      const uint8_t aPredivFactorTable[16] = { 1, 2,  3,  4,  5,  6,  7,  8, 9,10, 11, 12, 13, 14, 15, 16};
;;;396    #else
;;;397      const uint8_t aPLLMULFactorTable[16] = { 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 16};
;;;398      const uint8_t aPredivFactorTable[2] = { 1, 2};
;;;399    #endif
;;;400    #endif
;;;401      uint32_t temp_reg = 0, frequency = 0;
00017a  2400              MOVS     r4,#0
00017c  2600              MOVS     r6,#0
;;;402    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;403     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;404     || defined(STM32F105xC) || defined(STM32F107xC)
;;;405      uint32_t prediv1 = 0, pllclk = 0, pllmul = 0;
;;;406    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;407    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;408      uint32_t pll2mul = 0, pll3mul = 0, prediv2 = 0;
;;;409    #endif /* STM32F105xC || STM32F107xC */
;;;410    
;;;411      /* Check the parameters */
;;;412      assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));
;;;413      
;;;414      switch (PeriphClk)
00017e  2d01              CMP      r5,#1
000180  d002              BEQ      |L1.392|
000182  2d02              CMP      r5,#2
000184  d13b              BNE      |L1.510|
000186  e027              B        |L1.472|
                  |L1.392|
;;;415      {
;;;416    #if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
;;;417     || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
;;;418     || defined(STM32F105xC) || defined(STM32F107xC)
;;;419      case RCC_PERIPHCLK_USB:  
;;;420        {
;;;421          /* Get RCC configuration ------------------------------------------------------*/
;;;422          temp_reg = RCC->CFGR;
;;;423      
;;;424          /* Check if PLL is enabled */
;;;425          if (HAL_IS_BIT_SET(RCC->CR,RCC_CR_PLLON))
;;;426          {
;;;427            pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> POSITION_VAL(RCC_CFGR_PLLMULL)];
;;;428            if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;429            {
;;;430    #if defined(STM32F105xC) || defined(STM32F107xC) || defined(STM32F100xB)\
;;;431     || defined(STM32F100xE)
;;;432              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV1) >> POSITION_VAL(RCC_CFGR2_PREDIV1)];
;;;433    #else
;;;434              prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> POSITION_VAL(RCC_CFGR_PLLXTPRE)];
;;;435    #endif /* STM32F105xC || STM32F107xC || STM32F100xB || STM32F100xE */
;;;436    
;;;437    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;438              if(HAL_IS_BIT_SET(RCC->CFGR2, RCC_CFGR2_PREDIV1SRC))
;;;439              {
;;;440                /* PLL2 selected as Prediv1 source */
;;;441                /* PLLCLK = PLL2CLK / PREDIV1 * PLLMUL with PLL2CLK = HSE/PREDIV2 * PLL2MUL */
;;;442                prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;443                pll2mul = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> POSITION_VAL(RCC_CFGR2_PLL2MUL)) + 2;
;;;444                pllclk = (uint32_t)((((HSE_VALUE / prediv2) * pll2mul) / prediv1) * pllmul);
;;;445              }
;;;446              else
;;;447              {
;;;448                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;449                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;450              }
;;;451              
;;;452              /* If PLLMUL was set to 13 means that it was to cover the case PLLMUL 6.5 (avoid using float) */
;;;453              /* In this case need to divide pllclk by 2 */
;;;454              if (pllmul == aPLLMULFactorTable[(uint32_t)(RCC_CFGR_PLLMULL6_5) >> POSITION_VAL(RCC_CFGR_PLLMULL)])
;;;455              {
;;;456                  pllclk = pllclk / 2;
;;;457              }
;;;458    #else
;;;459              if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
;;;460              {
;;;461                /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV1 * PLLMUL */
;;;462                pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
;;;463              }
;;;464    #endif /* STM32F105xC || STM32F107xC */
;;;465            }
;;;466            else
;;;467            {
;;;468              /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
;;;469              pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
;;;470            }
;;;471    
;;;472            /* Calcul of the USB frequency*/
;;;473    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;474            /* USBCLK = PLLVCO = (2 x PLLCLK) / USB prescaler */
;;;475            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL_DIV2)
;;;476            {
;;;477              /* Prescaler of 2 selected for USB */ 
;;;478              frequency = pllclk;
;;;479            }
;;;480            else
;;;481            {
;;;482              /* Prescaler of 3 selected for USB */ 
;;;483              frequency = (2 * pllclk) / 3;
;;;484            }
;;;485    #else
;;;486            /* USBCLK = PLLCLK / USB prescaler */
;;;487            if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
;;;488            {
;;;489              /* No prescaler selected for USB */
;;;490              frequency = pllclk;
;;;491            }
;;;492            else
;;;493            {
;;;494              /* Prescaler of 1.5 selected for USB */ 
;;;495              frequency = (pllclk * 2) / 3;
;;;496            }
;;;497    #endif
;;;498          }
;;;499          break;
;;;500        }
;;;501    #endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;502    #if defined(STM32F103xE) || defined(STM32F103xG) || defined(STM32F105xC)\
;;;503     || defined(STM32F107xC)
;;;504      case RCC_PERIPHCLK_I2S2:  
;;;505        {
;;;506    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;507          /* SYSCLK used as source clock for I2S2 */
;;;508          frequency = HAL_RCC_GetSysClockFreq();
;;;509    #else
;;;510          if (__HAL_RCC_GET_I2S2_SOURCE() == RCC_I2S2CLKSOURCE_SYSCLK)
;;;511          {
;;;512            /* SYSCLK used as source clock for I2S2 */
;;;513            frequency = HAL_RCC_GetSysClockFreq();
;;;514          }
;;;515          else
;;;516          {
;;;517             /* Check if PLLI2S is enabled */
;;;518            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;519            {
;;;520              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;521              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;522              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;523              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;524            }
;;;525          }
;;;526    #endif /* STM32F103xE || STM32F103xG */
;;;527          break;
;;;528        }
;;;529      case RCC_PERIPHCLK_I2S3:
;;;530        {
;;;531    #if defined(STM32F103xE) || defined(STM32F103xG)
;;;532          /* SYSCLK used as source clock for I2S3 */
;;;533          frequency = HAL_RCC_GetSysClockFreq();
;;;534    #else
;;;535          if (__HAL_RCC_GET_I2S3_SOURCE() == RCC_I2S3CLKSOURCE_SYSCLK)
;;;536          {
;;;537            /* SYSCLK used as source clock for I2S3 */
;;;538            frequency = HAL_RCC_GetSysClockFreq();
;;;539          }
;;;540          else
;;;541          {
;;;542             /* Check if PLLI2S is enabled */
;;;543            if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3ON))
;;;544            {
;;;545              /* PLLI2SVCO = 2 * PLLI2SCLK = 2 * (HSE/PREDIV2 * PLL3MUL) */
;;;546              prediv2 = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> POSITION_VAL(RCC_CFGR2_PREDIV2)) + 1;
;;;547              pll3mul = ((RCC->CFGR2 & RCC_CFGR2_PLL3MUL) >> POSITION_VAL(RCC_CFGR2_PLL3MUL)) + 2;
;;;548              frequency = (uint32_t)(2 * ((HSE_VALUE / prediv2) * pll3mul));
;;;549            }
;;;550          }
;;;551    #endif /* STM32F103xE || STM32F103xG */
;;;552          break;
;;;553        }
;;;554    #endif /* STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */
;;;555      case RCC_PERIPHCLK_RTC:  
;;;556        {
;;;557          /* Get RCC BDCR configuration ------------------------------------------------------*/
;;;558          temp_reg = RCC->BDCR;
000188  481f              LDR      r0,|L1.520|
00018a  6a04              LDR      r4,[r0,#0x20]
;;;559    
;;;560          /* Check if LSE is ready if RTC clock selection is LSE */
;;;561          if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
00018c  f4047040          AND      r0,r4,#0x300
000190  f5b07f80          CMP      r0,#0x100
000194  d105              BNE      |L1.418|
000196  f0040002          AND      r0,r4,#2
00019a  b110              CBZ      r0,|L1.418|
;;;562          {
;;;563            frequency = LSE_VALUE;
00019c  f44f4600          MOV      r6,#0x8000
0001a0  e019              B        |L1.470|
                  |L1.418|
;;;564          }
;;;565          /* Check if LSI is ready if RTC clock selection is LSI */
;;;566          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
0001a2  f4047040          AND      r0,r4,#0x300
0001a6  f5b07f00          CMP      r0,#0x200
0001aa  d107              BNE      |L1.444|
0001ac  4816              LDR      r0,|L1.520|
0001ae  6a40              LDR      r0,[r0,#0x24]
0001b0  f0000002          AND      r0,r0,#2
0001b4  b110              CBZ      r0,|L1.444|
;;;567          {
;;;568            frequency = LSI_VALUE;
0001b6  f6494640          MOV      r6,#0x9c40
0001ba  e00c              B        |L1.470|
                  |L1.444|
;;;569          }
;;;570          else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
0001bc  f4047040          AND      r0,r4,#0x300
0001c0  f5b07f40          CMP      r0,#0x300
0001c4  d106              BNE      |L1.468|
0001c6  4810              LDR      r0,|L1.520|
0001c8  6800              LDR      r0,[r0,#0]
0001ca  f4003000          AND      r0,r0,#0x20000
0001ce  b108              CBZ      r0,|L1.468|
;;;571          {
;;;572            frequency = HSE_VALUE / 128;
0001d0  4e10              LDR      r6,|L1.532|
0001d2  e000              B        |L1.470|
                  |L1.468|
;;;573          }
;;;574          /* Clock not enabled for RTC*/
;;;575          else
;;;576          {
;;;577            frequency = 0;
0001d4  2600              MOVS     r6,#0
                  |L1.470|
;;;578          }
;;;579          break;
0001d6  e013              B        |L1.512|
                  |L1.472|
;;;580        }
;;;581      case RCC_PERIPHCLK_ADC:  
;;;582        {
;;;583          frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> POSITION_VAL(RCC_CFGR_ADCPRE_DIV4)) + 1) * 2);
0001d8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0001dc  4601              MOV      r1,r0
0001de  480a              LDR      r0,|L1.520|
0001e0  6840              LDR      r0,[r0,#4]
0001e2  f4004040          AND      r0,r0,#0xc000
0001e6  f44f4280          MOV      r2,#0x4000
0001ea  fa92f2a2          RBIT     r2,r2
0001ee  fab2f282          CLZ      r2,r2
0001f2  40d0              LSRS     r0,r0,r2
0001f4  1c40              ADDS     r0,r0,#1
0001f6  0040              LSLS     r0,r0,#1
0001f8  fbb1f6f0          UDIV     r6,r1,r0
;;;584          break;
0001fc  e000              B        |L1.512|
                  |L1.510|
;;;585        }
;;;586      default: 
;;;587        {
;;;588          break;
0001fe  bf00              NOP      
                  |L1.512|
000200  bf00              NOP                            ;579
;;;589        }
;;;590      }
;;;591      return(frequency);
000202  4630              MOV      r0,r6
;;;592    }
000204  bd70              POP      {r4-r6,pc}
;;;593    
                          ENDP

000206  0000              DCW      0x0000
                  |L1.520|
                          DCD      0x40021000
                  |L1.524|
                          DCD      0x40007000
                  |L1.528|
                          DCD      0x42420000
                  |L1.532|
                          DCD      0x0002faf0

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f1xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
