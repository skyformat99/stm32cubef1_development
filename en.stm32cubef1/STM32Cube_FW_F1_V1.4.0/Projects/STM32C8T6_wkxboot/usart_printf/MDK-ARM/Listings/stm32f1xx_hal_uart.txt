; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_uart.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;1868     */
;;;1869   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1870   {
000004  4604              MOV      r4,r0
;;;1871     uint32_t tmpreg = 0x00;
000006  2500              MOVS     r5,#0
;;;1872     
;;;1873     /* Check the parameters */
;;;1874     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));  
;;;1875     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;1876     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;1877     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;1878   
;;;1879     /*------- UART-associated USART registers setting : CR2 Configuration ------*/
;;;1880     /* Configure the UART Stop Bits: Set STOP[13:12] bits according 
;;;1881      * to huart->Init.StopBits value */
;;;1882     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000008  6820              LDR      r0,[r4,#0]
00000a  6900              LDR      r0,[r0,#0x10]
00000c  f4205040          BIC      r0,r0,#0x3000
000010  68e1              LDR      r1,[r4,#0xc]
000012  4308              ORRS     r0,r0,r1
000014  6821              LDR      r1,[r4,#0]
000016  6108              STR      r0,[r1,#0x10]
;;;1883   
;;;1884     /*------- UART-associated USART registers setting : CR1 Configuration ------*/
;;;1885     /* Configure the UART Word Length, Parity and mode: 
;;;1886        Set the M bits according to huart->Init.WordLength value 
;;;1887        Set PCE and PS bits according to huart->Init.Parity value
;;;1888        Set TE and RE bits according to huart->Init.Mode value */
;;;1889     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode ;
000018  6921              LDR      r1,[r4,#0x10]
00001a  68a0              LDR      r0,[r4,#8]
00001c  4308              ORRS     r0,r0,r1
00001e  6961              LDR      r1,[r4,#0x14]
000020  ea400501          ORR      r5,r0,r1
;;;1890     MODIFY_REG(huart->Instance->CR1, 
000024  6820              LDR      r0,[r4,#0]
000026  68c0              LDR      r0,[r0,#0xc]
000028  f241610c          MOV      r1,#0x160c
00002c  4388              BICS     r0,r0,r1
00002e  4328              ORRS     r0,r0,r5
000030  6821              LDR      r1,[r4,#0]
000032  60c8              STR      r0,[r1,#0xc]
;;;1891                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE), 
;;;1892                tmpreg);
;;;1893     
;;;1894     /*------- UART-associated USART registers setting : CR3 Configuration ------*/
;;;1895     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;1896     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
000034  6820              LDR      r0,[r4,#0]
000036  6940              LDR      r0,[r0,#0x14]
000038  f4207040          BIC      r0,r0,#0x300
00003c  69a1              LDR      r1,[r4,#0x18]
00003e  4308              ORRS     r0,r0,r1
000040  6821              LDR      r1,[r4,#0]
000042  6148              STR      r0,[r1,#0x14]
;;;1897     
;;;1898     /*------- UART-associated USART registers setting : BRR Configuration ------*/
;;;1899     if((huart->Instance == USART1))
000044  49fe              LDR      r1,|L1.1088|
000046  6820              LDR      r0,[r4,#0]
000048  4288              CMP      r0,r1
00004a  d15c              BNE      |L1.262|
;;;1900     {
;;;1901       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
00004c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000050  eb0001c0          ADD      r1,r0,r0,LSL #3
000054  eb011000          ADD      r0,r1,r0,LSL #4
000058  6861              LDR      r1,[r4,#4]
00005a  0089              LSLS     r1,r1,#2
00005c  fbb0f6f1          UDIV     r6,r0,r1
000060  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000064  eb0001c0          ADD      r1,r0,r0,LSL #3
000068  eb011000          ADD      r0,r1,r0,LSL #4
00006c  6861              LDR      r1,[r4,#4]
00006e  0089              LSLS     r1,r1,#2
000070  fbb0f0f1          UDIV     r0,r0,r1
000074  2164              MOVS     r1,#0x64
000076  fbb0f0f1          UDIV     r0,r0,r1
00007a  eb0001c0          ADD      r1,r0,r0,LSL #3
00007e  eb011000          ADD      r0,r1,r0,LSL #4
000082  eba60080          SUB      r0,r6,r0,LSL #2
000086  2132              MOVS     r1,#0x32
000088  eb011000          ADD      r0,r1,r0,LSL #4
00008c  2164              MOVS     r1,#0x64
00008e  fbb0f0f1          UDIV     r0,r0,r1
000092  f00006f0          AND      r6,r0,#0xf0
000096  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00009a  eb0001c0          ADD      r1,r0,r0,LSL #3
00009e  eb011000          ADD      r0,r1,r0,LSL #4
0000a2  6861              LDR      r1,[r4,#4]
0000a4  0089              LSLS     r1,r1,#2
0000a6  fbb0f0f1          UDIV     r0,r0,r1
0000aa  2164              MOVS     r1,#0x64
0000ac  fbb0f0f1          UDIV     r0,r0,r1
0000b0  eb061600          ADD      r6,r6,r0,LSL #4
0000b4  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000b8  eb0001c0          ADD      r1,r0,r0,LSL #3
0000bc  eb011000          ADD      r0,r1,r0,LSL #4
0000c0  6861              LDR      r1,[r4,#4]
0000c2  0089              LSLS     r1,r1,#2
0000c4  fbb0f7f1          UDIV     r7,r0,r1
0000c8  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
0000cc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000d0  eb011000          ADD      r0,r1,r0,LSL #4
0000d4  6861              LDR      r1,[r4,#4]
0000d6  0089              LSLS     r1,r1,#2
0000d8  fbb0f0f1          UDIV     r0,r0,r1
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f0f1          UDIV     r0,r0,r1
0000e2  eb0001c0          ADD      r1,r0,r0,LSL #3
0000e6  eb011000          ADD      r0,r1,r0,LSL #4
0000ea  eba70080          SUB      r0,r7,r0,LSL #2
0000ee  2132              MOVS     r1,#0x32
0000f0  eb011000          ADD      r0,r1,r0,LSL #4
0000f4  2164              MOVS     r1,#0x64
0000f6  fbb0f0f1          UDIV     r0,r0,r1
0000fa  f000000f          AND      r0,r0,#0xf
0000fe  4430              ADD      r0,r0,r6
000100  6821              LDR      r1,[r4,#0]
000102  6088              STR      r0,[r1,#8]
000104  e05b              B        |L1.446|
                  |L1.262|
;;;1902     }
;;;1903     else
;;;1904     {
;;;1905       huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
000106  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00010a  eb0001c0          ADD      r1,r0,r0,LSL #3
00010e  eb011000          ADD      r0,r1,r0,LSL #4
000112  6861              LDR      r1,[r4,#4]
000114  0089              LSLS     r1,r1,#2
000116  fbb0f6f1          UDIV     r6,r0,r1
00011a  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
00011e  eb0001c0          ADD      r1,r0,r0,LSL #3
000122  eb011000          ADD      r0,r1,r0,LSL #4
000126  6861              LDR      r1,[r4,#4]
000128  0089              LSLS     r1,r1,#2
00012a  fbb0f0f1          UDIV     r0,r0,r1
00012e  2164              MOVS     r1,#0x64
000130  fbb0f0f1          UDIV     r0,r0,r1
000134  eb0001c0          ADD      r1,r0,r0,LSL #3
000138  eb011000          ADD      r0,r1,r0,LSL #4
00013c  eba60080          SUB      r0,r6,r0,LSL #2
000140  2132              MOVS     r1,#0x32
000142  eb011000          ADD      r0,r1,r0,LSL #4
000146  2164              MOVS     r1,#0x64
000148  fbb0f0f1          UDIV     r0,r0,r1
00014c  f00006f0          AND      r6,r0,#0xf0
000150  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000154  eb0001c0          ADD      r1,r0,r0,LSL #3
000158  eb011000          ADD      r0,r1,r0,LSL #4
00015c  6861              LDR      r1,[r4,#4]
00015e  0089              LSLS     r1,r1,#2
000160  fbb0f0f1          UDIV     r0,r0,r1
000164  2164              MOVS     r1,#0x64
000166  fbb0f0f1          UDIV     r0,r0,r1
00016a  eb061600          ADD      r6,r6,r0,LSL #4
00016e  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000172  eb0001c0          ADD      r1,r0,r0,LSL #3
000176  eb011000          ADD      r0,r1,r0,LSL #4
00017a  6861              LDR      r1,[r4,#4]
00017c  0089              LSLS     r1,r1,#2
00017e  fbb0f7f1          UDIV     r7,r0,r1
000182  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
000186  eb0001c0          ADD      r1,r0,r0,LSL #3
00018a  eb011000          ADD      r0,r1,r0,LSL #4
00018e  6861              LDR      r1,[r4,#4]
000190  0089              LSLS     r1,r1,#2
000192  fbb0f0f1          UDIV     r0,r0,r1
000196  2164              MOVS     r1,#0x64
000198  fbb0f0f1          UDIV     r0,r0,r1
00019c  eb0001c0          ADD      r1,r0,r0,LSL #3
0001a0  eb011000          ADD      r0,r1,r0,LSL #4
0001a4  eba70080          SUB      r0,r7,r0,LSL #2
0001a8  2132              MOVS     r1,#0x32
0001aa  eb011000          ADD      r0,r1,r0,LSL #4
0001ae  2164              MOVS     r1,#0x64
0001b0  fbb0f0f1          UDIV     r0,r0,r1
0001b4  f000000f          AND      r0,r0,#0xf
0001b8  4430              ADD      r0,r0,r6
0001ba  6821              LDR      r1,[r4,#0]
0001bc  6088              STR      r0,[r1,#8]
                  |L1.446|
;;;1906     }
;;;1907   }
0001be  e8bd81f0          POP      {r4-r8,pc}
;;;1908   /**
                          ENDP

                  HAL_UART_MspInit PROC
;;;538      */
;;;539     __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
0001c2  4770              BX       lr
;;;540    {
;;;541      /* Prevent unused argument(s) compilation warning */
;;;542      UNUSED(huart);
;;;543      /* NOTE: This function should not be modified, when the callback is needed,
;;;544               the HAL_UART_MspInit can be implemented in the user file
;;;545       */ 
;;;546    }
;;;547    
                          ENDP

                  HAL_UART_Init PROC
;;;250      */
;;;251    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
0001c4  b510              PUSH     {r4,lr}
;;;252    {
0001c6  4604              MOV      r4,r0
;;;253      /* Check the UART handle allocation */
;;;254      if(huart == NULL)
0001c8  b90c              CBNZ     r4,|L1.462|
;;;255      {
;;;256        return HAL_ERROR;
0001ca  2001              MOVS     r0,#1
                  |L1.460|
;;;257      }
;;;258    
;;;259      /* Check the parameters */
;;;260      if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;261      {
;;;262        /* The hardware flow control is available only for USART1, USART2, USART3 */
;;;263        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;264        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;265      }
;;;266      else
;;;267      {
;;;268        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;269      }
;;;270      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;271      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;272      
;;;273      if(huart->State == HAL_UART_STATE_RESET)
;;;274      {  
;;;275        /* Allocate lock resource and initialize it */
;;;276        huart->Lock = HAL_UNLOCKED;
;;;277        
;;;278        /* Init the low level hardware */
;;;279        HAL_UART_MspInit(huart);
;;;280      }
;;;281    
;;;282      huart->State = HAL_UART_STATE_BUSY;
;;;283    
;;;284      /* Disable the peripheral */
;;;285      __HAL_UART_DISABLE(huart);
;;;286      
;;;287      /* Set the UART Communication parameters */
;;;288      UART_SetConfig(huart);
;;;289      
;;;290      /* In asynchronous mode, the following bits must be kept cleared: 
;;;291         - LINEN and CLKEN bits in the USART_CR2 register,
;;;292         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;293      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;294      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;295      
;;;296      /* Enable the peripheral */
;;;297      __HAL_UART_ENABLE(huart);
;;;298      
;;;299      /* Initialize the UART state */
;;;300      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;301      huart->State= HAL_UART_STATE_READY;
;;;302      
;;;303      return HAL_OK;
;;;304    }
0001cc  bd10              POP      {r4,pc}
                  |L1.462|
0001ce  69a0              LDR      r0,[r4,#0x18]         ;260
0001d0  b100              CBZ      r0,|L1.468|
0001d2  e000              B        |L1.470|
                  |L1.468|
0001d4  bf00              NOP                            ;268
                  |L1.470|
0001d6  f8940039          LDRB     r0,[r4,#0x39]         ;273
0001da  b928              CBNZ     r0,|L1.488|
0001dc  2000              MOVS     r0,#0                 ;276
0001de  f8840038          STRB     r0,[r4,#0x38]         ;276
0001e2  4620              MOV      r0,r4                 ;279
0001e4  f7fffffe          BL       HAL_UART_MspInit
                  |L1.488|
0001e8  2002              MOVS     r0,#2                 ;282
0001ea  f8840039          STRB     r0,[r4,#0x39]         ;282
0001ee  6820              LDR      r0,[r4,#0]            ;285
0001f0  68c0              LDR      r0,[r0,#0xc]          ;285
0001f2  f4205000          BIC      r0,r0,#0x2000         ;285
0001f6  6821              LDR      r1,[r4,#0]            ;285
0001f8  60c8              STR      r0,[r1,#0xc]          ;285
0001fa  4620              MOV      r0,r4                 ;288
0001fc  f7fffffe          BL       UART_SetConfig
000200  6820              LDR      r0,[r4,#0]            ;293
000202  6900              LDR      r0,[r0,#0x10]         ;293
000204  f4204090          BIC      r0,r0,#0x4800         ;293
000208  6821              LDR      r1,[r4,#0]            ;293
00020a  6108              STR      r0,[r1,#0x10]         ;293
00020c  6820              LDR      r0,[r4,#0]            ;294
00020e  6940              LDR      r0,[r0,#0x14]         ;294
000210  f020002a          BIC      r0,r0,#0x2a           ;294
000214  6821              LDR      r1,[r4,#0]            ;294
000216  6148              STR      r0,[r1,#0x14]         ;294
000218  6820              LDR      r0,[r4,#0]            ;297
00021a  68c0              LDR      r0,[r0,#0xc]          ;297
00021c  f4405000          ORR      r0,r0,#0x2000         ;297
000220  6821              LDR      r1,[r4,#0]            ;297
000222  60c8              STR      r0,[r1,#0xc]          ;297
000224  2000              MOVS     r0,#0                 ;300
000226  63e0              STR      r0,[r4,#0x3c]         ;300
000228  2001              MOVS     r0,#1                 ;301
00022a  f8840039          STRB     r0,[r4,#0x39]         ;301
00022e  2000              MOVS     r0,#0                 ;303
000230  e7cc              B        |L1.460|
;;;305    
                          ENDP

                  HAL_HalfDuplex_Init PROC
;;;312      */
;;;313    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000232  b510              PUSH     {r4,lr}
;;;314    {
000234  4604              MOV      r4,r0
;;;315      /* Check the UART handle allocation */
;;;316      if(huart == NULL)
000236  b90c              CBNZ     r4,|L1.572|
;;;317      {
;;;318        return HAL_ERROR;
000238  2001              MOVS     r0,#1
                  |L1.570|
;;;319      }
;;;320      
;;;321      /* Check UART instance */
;;;322      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;323      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;324      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;325    
;;;326      if(huart->State == HAL_UART_STATE_RESET)
;;;327      {   
;;;328        /* Allocate lock resource and initialize it */
;;;329        huart->Lock = HAL_UNLOCKED;
;;;330    
;;;331        /* Init the low level hardware */
;;;332        HAL_UART_MspInit(huart);
;;;333      }
;;;334    
;;;335      huart->State = HAL_UART_STATE_BUSY;
;;;336    
;;;337      /* Disable the peripheral */
;;;338      __HAL_UART_DISABLE(huart);
;;;339      
;;;340      /* Set the UART Communication parameters */
;;;341      UART_SetConfig(huart);
;;;342      
;;;343      /* In half-duplex mode, the following bits must be kept cleared: 
;;;344         - LINEN and CLKEN bits in the USART_CR2 register,
;;;345         - SCEN and IREN bits in the USART_CR3 register.*/
;;;346      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;347      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;348      
;;;349      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;350      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;351     
;;;352      /* Enable the peripheral */
;;;353      __HAL_UART_ENABLE(huart);
;;;354      
;;;355      /* Initialize the UART state*/
;;;356      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;357      huart->State= HAL_UART_STATE_READY;
;;;358      
;;;359      return HAL_OK;
;;;360    }
00023a  bd10              POP      {r4,pc}
                  |L1.572|
00023c  f8940039          LDRB     r0,[r4,#0x39]         ;326
000240  b928              CBNZ     r0,|L1.590|
000242  2000              MOVS     r0,#0                 ;329
000244  f8840038          STRB     r0,[r4,#0x38]         ;329
000248  4620              MOV      r0,r4                 ;332
00024a  f7fffffe          BL       HAL_UART_MspInit
                  |L1.590|
00024e  2002              MOVS     r0,#2                 ;335
000250  f8840039          STRB     r0,[r4,#0x39]         ;335
000254  6820              LDR      r0,[r4,#0]            ;338
000256  68c0              LDR      r0,[r0,#0xc]          ;338
000258  f4205000          BIC      r0,r0,#0x2000         ;338
00025c  6821              LDR      r1,[r4,#0]            ;338
00025e  60c8              STR      r0,[r1,#0xc]          ;338
000260  4620              MOV      r0,r4                 ;341
000262  f7fffffe          BL       UART_SetConfig
000266  6820              LDR      r0,[r4,#0]            ;346
000268  6900              LDR      r0,[r0,#0x10]         ;346
00026a  f4204090          BIC      r0,r0,#0x4800         ;346
00026e  6821              LDR      r1,[r4,#0]            ;346
000270  6108              STR      r0,[r1,#0x10]         ;346
000272  6820              LDR      r0,[r4,#0]            ;347
000274  6940              LDR      r0,[r0,#0x14]         ;347
000276  f0200022          BIC      r0,r0,#0x22           ;347
00027a  6821              LDR      r1,[r4,#0]            ;347
00027c  6148              STR      r0,[r1,#0x14]         ;347
00027e  6820              LDR      r0,[r4,#0]            ;350
000280  6940              LDR      r0,[r0,#0x14]         ;350
000282  f0400008          ORR      r0,r0,#8              ;350
000286  6821              LDR      r1,[r4,#0]            ;350
000288  6148              STR      r0,[r1,#0x14]         ;350
00028a  6820              LDR      r0,[r4,#0]            ;353
00028c  68c0              LDR      r0,[r0,#0xc]          ;353
00028e  f4405000          ORR      r0,r0,#0x2000         ;353
000292  6821              LDR      r1,[r4,#0]            ;353
000294  60c8              STR      r0,[r1,#0xc]          ;353
000296  2000              MOVS     r0,#0                 ;356
000298  63e0              STR      r0,[r4,#0x3c]         ;356
00029a  2001              MOVS     r0,#1                 ;357
00029c  f8840039          STRB     r0,[r4,#0x39]         ;357
0002a0  2000              MOVS     r0,#0                 ;359
0002a2  e7ca              B        |L1.570|
;;;361    
                          ENDP

                  HAL_LIN_Init PROC
;;;372      */
;;;373    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
0002a4  b570              PUSH     {r4-r6,lr}
;;;374    {
0002a6  4604              MOV      r4,r0
0002a8  460d              MOV      r5,r1
;;;375      /* Check the UART handle allocation */
;;;376      if(huart == NULL)
0002aa  b90c              CBNZ     r4,|L1.688|
;;;377      {
;;;378        return HAL_ERROR;
0002ac  2001              MOVS     r0,#1
                  |L1.686|
;;;379      }
;;;380      
;;;381      /* Check the LIN UART instance */  
;;;382      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;383      /* Check the Break detection length parameter */
;;;384      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;385      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;386      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;387      
;;;388      if(huart->State == HAL_UART_STATE_RESET)
;;;389      {   
;;;390        /* Allocate lock resource and initialize it */
;;;391        huart->Lock = HAL_UNLOCKED;  
;;;392    
;;;393        /* Init the low level hardware */
;;;394        HAL_UART_MspInit(huart);
;;;395      }
;;;396    
;;;397      huart->State = HAL_UART_STATE_BUSY;
;;;398    
;;;399      /* Disable the peripheral */
;;;400      __HAL_UART_DISABLE(huart);
;;;401      
;;;402      /* Set the UART Communication parameters */
;;;403      UART_SetConfig(huart);
;;;404      
;;;405      /* In LIN mode, the following bits must be kept cleared: 
;;;406         - CLKEN bits in the USART_CR2 register,
;;;407         - SCEN and IREN bits in the USART_CR3 register.*/
;;;408      CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
;;;409      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;410      
;;;411      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;412      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;413      
;;;414      /* Set the USART LIN Break detection length. */
;;;415      MODIFY_REG(huart->Instance->CR2, USART_CR2_LBDL, BreakDetectLength);
;;;416      
;;;417      /* Enable the peripheral */
;;;418      __HAL_UART_ENABLE(huart);
;;;419      
;;;420      /* Initialize the UART state*/
;;;421      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;422      huart->State= HAL_UART_STATE_READY;
;;;423      
;;;424      return HAL_OK;
;;;425    }
0002ae  bd70              POP      {r4-r6,pc}
                  |L1.688|
0002b0  f8940039          LDRB     r0,[r4,#0x39]         ;388
0002b4  b928              CBNZ     r0,|L1.706|
0002b6  2000              MOVS     r0,#0                 ;391
0002b8  f8840038          STRB     r0,[r4,#0x38]         ;391
0002bc  4620              MOV      r0,r4                 ;394
0002be  f7fffffe          BL       HAL_UART_MspInit
                  |L1.706|
0002c2  2002              MOVS     r0,#2                 ;397
0002c4  f8840039          STRB     r0,[r4,#0x39]         ;397
0002c8  6820              LDR      r0,[r4,#0]            ;400
0002ca  68c0              LDR      r0,[r0,#0xc]          ;400
0002cc  f4205000          BIC      r0,r0,#0x2000         ;400
0002d0  6821              LDR      r1,[r4,#0]            ;400
0002d2  60c8              STR      r0,[r1,#0xc]          ;400
0002d4  4620              MOV      r0,r4                 ;403
0002d6  f7fffffe          BL       UART_SetConfig
0002da  6820              LDR      r0,[r4,#0]            ;408
0002dc  6900              LDR      r0,[r0,#0x10]         ;408
0002de  f4206000          BIC      r0,r0,#0x800          ;408
0002e2  6821              LDR      r1,[r4,#0]            ;408
0002e4  6108              STR      r0,[r1,#0x10]         ;408
0002e6  6820              LDR      r0,[r4,#0]            ;409
0002e8  6940              LDR      r0,[r0,#0x14]         ;409
0002ea  f020002a          BIC      r0,r0,#0x2a           ;409
0002ee  6821              LDR      r1,[r4,#0]            ;409
0002f0  6148              STR      r0,[r1,#0x14]         ;409
0002f2  6820              LDR      r0,[r4,#0]            ;412
0002f4  6900              LDR      r0,[r0,#0x10]         ;412
0002f6  f4404080          ORR      r0,r0,#0x4000         ;412
0002fa  6821              LDR      r1,[r4,#0]            ;412
0002fc  6108              STR      r0,[r1,#0x10]         ;412
0002fe  6820              LDR      r0,[r4,#0]            ;415
000300  6900              LDR      r0,[r0,#0x10]         ;415
000302  f0200020          BIC      r0,r0,#0x20           ;415
000306  4328              ORRS     r0,r0,r5              ;415
000308  6821              LDR      r1,[r4,#0]            ;415
00030a  6108              STR      r0,[r1,#0x10]         ;415
00030c  6820              LDR      r0,[r4,#0]            ;418
00030e  68c0              LDR      r0,[r0,#0xc]          ;418
000310  f4405000          ORR      r0,r0,#0x2000         ;418
000314  6821              LDR      r1,[r4,#0]            ;418
000316  60c8              STR      r0,[r1,#0xc]          ;418
000318  2000              MOVS     r0,#0                 ;421
00031a  63e0              STR      r0,[r4,#0x3c]         ;421
00031c  2001              MOVS     r0,#1                 ;422
00031e  f8840039          STRB     r0,[r4,#0x39]         ;422
000322  2000              MOVS     r0,#0                 ;424
000324  e7c3              B        |L1.686|
;;;426    
                          ENDP

                  HAL_MultiProcessor_Init PROC
;;;438      */
;;;439    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000326  b570              PUSH     {r4-r6,lr}
;;;440    {
000328  4604              MOV      r4,r0
00032a  460d              MOV      r5,r1
00032c  4616              MOV      r6,r2
;;;441      /* Check the UART handle allocation */
;;;442      if(huart == NULL)
00032e  b90c              CBNZ     r4,|L1.820|
;;;443      {
;;;444        return HAL_ERROR;
000330  2001              MOVS     r0,#1
                  |L1.818|
;;;445      }
;;;446    
;;;447      /* Check UART instance capabilities */  
;;;448      assert_param(IS_UART_MULTIPROCESSOR_INSTANCE(huart->Instance));
;;;449    
;;;450      /* Check the Address & wake up method parameters */
;;;451      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;452      assert_param(IS_UART_ADDRESS(Address));
;;;453      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;454      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;455    
;;;456      if(huart->State == HAL_UART_STATE_RESET)
;;;457      {   
;;;458        /* Allocate lock resource and initialize it */
;;;459        huart->Lock = HAL_UNLOCKED;
;;;460    
;;;461        /* Init the low level hardware */
;;;462        HAL_UART_MspInit(huart);
;;;463      }
;;;464    
;;;465      huart->State = HAL_UART_STATE_BUSY;
;;;466    
;;;467      /* Disable the peripheral */
;;;468      __HAL_UART_DISABLE(huart);
;;;469      
;;;470      /* Set the UART Communication parameters */
;;;471      UART_SetConfig(huart);
;;;472      
;;;473      /* In Multi-Processor mode, the following bits must be kept cleared: 
;;;474         - LINEN and CLKEN bits in the USART_CR2 register,
;;;475         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;476      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;477      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;478      
;;;479      /* Set the USART address node */
;;;480      MODIFY_REG(huart->Instance->CR2, USART_CR2_ADD, Address);
;;;481      
;;;482      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;483      MODIFY_REG(huart->Instance->CR1, USART_CR1_WAKE, WakeUpMethod);
;;;484      
;;;485      /* Enable the peripheral */
;;;486      __HAL_UART_ENABLE(huart);
;;;487      
;;;488      /* Initialize the UART state */
;;;489      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;490      huart->State= HAL_UART_STATE_READY;
;;;491      
;;;492      return HAL_OK;
;;;493    }
000332  bd70              POP      {r4-r6,pc}
                  |L1.820|
000334  f8940039          LDRB     r0,[r4,#0x39]         ;456
000338  b928              CBNZ     r0,|L1.838|
00033a  2000              MOVS     r0,#0                 ;459
00033c  f8840038          STRB     r0,[r4,#0x38]         ;459
000340  4620              MOV      r0,r4                 ;462
000342  f7fffffe          BL       HAL_UART_MspInit
                  |L1.838|
000346  2002              MOVS     r0,#2                 ;465
000348  f8840039          STRB     r0,[r4,#0x39]         ;465
00034c  6820              LDR      r0,[r4,#0]            ;468
00034e  68c0              LDR      r0,[r0,#0xc]          ;468
000350  f4205000          BIC      r0,r0,#0x2000         ;468
000354  6821              LDR      r1,[r4,#0]            ;468
000356  60c8              STR      r0,[r1,#0xc]          ;468
000358  4620              MOV      r0,r4                 ;471
00035a  f7fffffe          BL       UART_SetConfig
00035e  6820              LDR      r0,[r4,#0]            ;476
000360  6900              LDR      r0,[r0,#0x10]         ;476
000362  f4204090          BIC      r0,r0,#0x4800         ;476
000366  6821              LDR      r1,[r4,#0]            ;476
000368  6108              STR      r0,[r1,#0x10]         ;476
00036a  6820              LDR      r0,[r4,#0]            ;477
00036c  6940              LDR      r0,[r0,#0x14]         ;477
00036e  f020002a          BIC      r0,r0,#0x2a           ;477
000372  6821              LDR      r1,[r4,#0]            ;477
000374  6148              STR      r0,[r1,#0x14]         ;477
000376  6820              LDR      r0,[r4,#0]            ;480
000378  6900              LDR      r0,[r0,#0x10]         ;480
00037a  f020000f          BIC      r0,r0,#0xf            ;480
00037e  4328              ORRS     r0,r0,r5              ;480
000380  6821              LDR      r1,[r4,#0]            ;480
000382  6108              STR      r0,[r1,#0x10]         ;480
000384  6820              LDR      r0,[r4,#0]            ;483
000386  68c0              LDR      r0,[r0,#0xc]          ;483
000388  f4206000          BIC      r0,r0,#0x800          ;483
00038c  4330              ORRS     r0,r0,r6              ;483
00038e  6821              LDR      r1,[r4,#0]            ;483
000390  60c8              STR      r0,[r1,#0xc]          ;483
000392  6820              LDR      r0,[r4,#0]            ;486
000394  68c0              LDR      r0,[r0,#0xc]          ;486
000396  f4405000          ORR      r0,r0,#0x2000         ;486
00039a  6821              LDR      r1,[r4,#0]            ;486
00039c  60c8              STR      r0,[r1,#0xc]          ;486
00039e  2000              MOVS     r0,#0                 ;489
0003a0  63e0              STR      r0,[r4,#0x3c]         ;489
0003a2  2001              MOVS     r0,#1                 ;490
0003a4  f8840039          STRB     r0,[r4,#0x39]         ;490
0003a8  2000              MOVS     r0,#0                 ;492
0003aa  e7c2              B        |L1.818|
;;;494    
                          ENDP

                  HAL_UART_MspDeInit PROC
;;;553      */
;;;554     __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
0003ac  4770              BX       lr
;;;555    {
;;;556      /* Prevent unused argument(s) compilation warning */
;;;557      UNUSED(huart);
;;;558      /* NOTE: This function should not be modified, when the callback is needed,
;;;559               the HAL_UART_MspDeInit can be implemented in the user file
;;;560       */ 
;;;561    }
;;;562    
                          ENDP

                  HAL_UART_DeInit PROC
;;;500      */
;;;501    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
0003ae  b510              PUSH     {r4,lr}
;;;502    {
0003b0  4604              MOV      r4,r0
;;;503      /* Check the UART handle allocation */
;;;504      if(huart == NULL)
0003b2  b90c              CBNZ     r4,|L1.952|
;;;505      {
;;;506        return HAL_ERROR;
0003b4  2001              MOVS     r0,#1
                  |L1.950|
;;;507      }
;;;508      
;;;509      /* Check the parameters */
;;;510      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;511    
;;;512      huart->State = HAL_UART_STATE_BUSY;
;;;513      
;;;514      /* Disable the Peripheral */
;;;515      __HAL_UART_DISABLE(huart);
;;;516      
;;;517      huart->Instance->CR1 = 0x0;
;;;518      huart->Instance->CR2 = 0x0;
;;;519      huart->Instance->CR3 = 0x0;
;;;520      
;;;521      /* DeInit the low level hardware */
;;;522      HAL_UART_MspDeInit(huart);
;;;523    
;;;524      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;525      huart->State = HAL_UART_STATE_RESET;
;;;526    
;;;527      /* Process Unlock */
;;;528      __HAL_UNLOCK(huart);
;;;529    
;;;530      return HAL_OK;
;;;531    }
0003b6  bd10              POP      {r4,pc}
                  |L1.952|
0003b8  2002              MOVS     r0,#2                 ;512
0003ba  f8840039          STRB     r0,[r4,#0x39]         ;512
0003be  6820              LDR      r0,[r4,#0]            ;515
0003c0  68c0              LDR      r0,[r0,#0xc]          ;515
0003c2  f4205000          BIC      r0,r0,#0x2000         ;515
0003c6  6821              LDR      r1,[r4,#0]            ;515
0003c8  60c8              STR      r0,[r1,#0xc]          ;515
0003ca  2000              MOVS     r0,#0                 ;517
0003cc  6821              LDR      r1,[r4,#0]            ;517
0003ce  60c8              STR      r0,[r1,#0xc]          ;517
0003d0  6821              LDR      r1,[r4,#0]            ;518
0003d2  6108              STR      r0,[r1,#0x10]         ;518
0003d4  6821              LDR      r1,[r4,#0]            ;519
0003d6  6148              STR      r0,[r1,#0x14]         ;519
0003d8  4620              MOV      r0,r4                 ;522
0003da  f7fffffe          BL       HAL_UART_MspDeInit
0003de  2000              MOVS     r0,#0                 ;524
0003e0  63e0              STR      r0,[r4,#0x3c]         ;524
0003e2  f8840039          STRB     r0,[r4,#0x39]         ;525
0003e6  bf00              NOP                            ;528
0003e8  f8840038          STRB     r0,[r4,#0x38]         ;528
0003ec  bf00              NOP                            ;528
0003ee  bf00              NOP                            ;530
0003f0  e7e1              B        |L1.950|
;;;532    
                          ENDP

                  UART_WaitOnFlagUntilTimeout PROC
;;;1655     */
;;;1656   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
0003f2  e92d41f0          PUSH     {r4-r8,lr}
;;;1657   {
0003f6  4604              MOV      r4,r0
0003f8  460e              MOV      r6,r1
0003fa  4617              MOV      r7,r2
0003fc  461d              MOV      r5,r3
;;;1658     uint32_t tickstart = 0;
0003fe  f04f0800          MOV      r8,#0
;;;1659   
;;;1660     /* Get tick */ 
;;;1661     tickstart = HAL_GetTick();
000402  f7fffffe          BL       HAL_GetTick
000406  4680              MOV      r8,r0
;;;1662   
;;;1663     /* Wait until flag is set */
;;;1664     if(Status == RESET)
000408  bb7f              CBNZ     r7,|L1.1130|
;;;1665     {
;;;1666       while(__HAL_UART_GET_FLAG(huart, Flag) == RESET)
00040a  e030              B        |L1.1134|
                  |L1.1036|
;;;1667       {
;;;1668         /* Check for the Timeout */
;;;1669         if(Timeout != HAL_MAX_DELAY)
00040c  1c68              ADDS     r0,r5,#1
00040e  b368              CBZ      r0,|L1.1132|
;;;1670         {
;;;1671           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
000410  b12d              CBZ      r5,|L1.1054|
000412  f7fffffe          BL       HAL_GetTick
000416  eba00008          SUB      r0,r0,r8
00041a  42a8              CMP      r0,r5
00041c  d927              BLS      |L1.1134|
                  |L1.1054|
;;;1672           {
;;;1673             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1674             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
00041e  6820              LDR      r0,[r4,#0]
000420  68c0              LDR      r0,[r0,#0xc]
000422  f0200080          BIC      r0,r0,#0x80
000426  6821              LDR      r1,[r4,#0]
000428  60c8              STR      r0,[r1,#0xc]
;;;1675             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
00042a  6820              LDR      r0,[r4,#0]
00042c  68c0              LDR      r0,[r0,#0xc]
00042e  f0200020          BIC      r0,r0,#0x20
000432  6821              LDR      r1,[r4,#0]
000434  60c8              STR      r0,[r1,#0xc]
;;;1676             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000436  6820              LDR      r0,[r4,#0]
000438  68c0              LDR      r0,[r0,#0xc]
00043a  f4207080          BIC      r0,r0,#0x100
00043e  e001              B        |L1.1092|
                  |L1.1088|
                          DCD      0x40013800
                  |L1.1092|
000444  6821              LDR      r1,[r4,#0]
000446  60c8              STR      r0,[r1,#0xc]
;;;1677             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000448  6820              LDR      r0,[r4,#0]
00044a  6940              LDR      r0,[r0,#0x14]
00044c  f0200001          BIC      r0,r0,#1
000450  6821              LDR      r1,[r4,#0]
000452  6148              STR      r0,[r1,#0x14]
;;;1678   
;;;1679             huart->State= HAL_UART_STATE_READY;
000454  2001              MOVS     r0,#1
000456  f8840039          STRB     r0,[r4,#0x39]
;;;1680   
;;;1681             /* Process Unlocked */
;;;1682             __HAL_UNLOCK(huart);
00045a  bf00              NOP      
00045c  2000              MOVS     r0,#0
00045e  f8840038          STRB     r0,[r4,#0x38]
000462  bf00              NOP      
;;;1683   
;;;1684             return HAL_TIMEOUT;
000464  2003              MOVS     r0,#3
                  |L1.1126|
;;;1685           }
;;;1686         }
;;;1687       }
;;;1688     }
;;;1689     else
;;;1690     {
;;;1691       while(__HAL_UART_GET_FLAG(huart, Flag) != RESET)
;;;1692       {
;;;1693         /* Check for the Timeout */
;;;1694         if(Timeout != HAL_MAX_DELAY)
;;;1695         {
;;;1696           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1697           {
;;;1698             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1699             __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;1700             __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;1701             __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;1702             __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;1703   
;;;1704             huart->State= HAL_UART_STATE_READY;
;;;1705   
;;;1706             /* Process Unlocked */
;;;1707             __HAL_UNLOCK(huart);
;;;1708   
;;;1709             return HAL_TIMEOUT;
;;;1710           }
;;;1711         }
;;;1712       }
;;;1713     }
;;;1714     return HAL_OK;
;;;1715   }
000466  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1130|
00046a  e00b              B        |L1.1156|
                  |L1.1132|
00046c  e7ff              B        |L1.1134|
                  |L1.1134|
00046e  6820              LDR      r0,[r4,#0]            ;1666
000470  6800              LDR      r0,[r0,#0]            ;1666
000472  4030              ANDS     r0,r0,r6              ;1666
000474  42b0              CMP      r0,r6                 ;1666
000476  d101              BNE      |L1.1148|
000478  2001              MOVS     r0,#1                 ;1666
00047a  e000              B        |L1.1150|
                  |L1.1148|
00047c  2000              MOVS     r0,#0                 ;1666
                  |L1.1150|
00047e  2800              CMP      r0,#0                 ;1666
000480  d0c4              BEQ      |L1.1036|
000482  e035              B        |L1.1264|
                  |L1.1156|
000484  e02a              B        |L1.1244|
                  |L1.1158|
000486  1c68              ADDS     r0,r5,#1              ;1694
000488  b340              CBZ      r0,|L1.1244|
00048a  b12d              CBZ      r5,|L1.1176|
00048c  f7fffffe          BL       HAL_GetTick
000490  eba00008          SUB      r0,r0,r8              ;1696
000494  42a8              CMP      r0,r5                 ;1696
000496  d921              BLS      |L1.1244|
                  |L1.1176|
000498  6820              LDR      r0,[r4,#0]            ;1699
00049a  68c0              LDR      r0,[r0,#0xc]          ;1699
00049c  f0200080          BIC      r0,r0,#0x80           ;1699
0004a0  6821              LDR      r1,[r4,#0]            ;1699
0004a2  60c8              STR      r0,[r1,#0xc]          ;1699
0004a4  6820              LDR      r0,[r4,#0]            ;1700
0004a6  68c0              LDR      r0,[r0,#0xc]          ;1700
0004a8  f0200020          BIC      r0,r0,#0x20           ;1700
0004ac  6821              LDR      r1,[r4,#0]            ;1700
0004ae  60c8              STR      r0,[r1,#0xc]          ;1700
0004b0  6820              LDR      r0,[r4,#0]            ;1701
0004b2  68c0              LDR      r0,[r0,#0xc]          ;1701
0004b4  f4207080          BIC      r0,r0,#0x100          ;1701
0004b8  6821              LDR      r1,[r4,#0]            ;1701
0004ba  60c8              STR      r0,[r1,#0xc]          ;1701
0004bc  6820              LDR      r0,[r4,#0]            ;1702
0004be  6940              LDR      r0,[r0,#0x14]         ;1702
0004c0  f0200001          BIC      r0,r0,#1              ;1702
0004c4  6821              LDR      r1,[r4,#0]            ;1702
0004c6  6148              STR      r0,[r1,#0x14]         ;1702
0004c8  2001              MOVS     r0,#1                 ;1704
0004ca  f8840039          STRB     r0,[r4,#0x39]         ;1704
0004ce  bf00              NOP                            ;1707
0004d0  2000              MOVS     r0,#0                 ;1707
0004d2  f8840038          STRB     r0,[r4,#0x38]         ;1707
0004d6  bf00              NOP                            ;1707
0004d8  2003              MOVS     r0,#3                 ;1709
0004da  e7c4              B        |L1.1126|
                  |L1.1244|
0004dc  6820              LDR      r0,[r4,#0]            ;1691
0004de  6800              LDR      r0,[r0,#0]            ;1691
0004e0  4030              ANDS     r0,r0,r6              ;1691
0004e2  42b0              CMP      r0,r6                 ;1691
0004e4  d101              BNE      |L1.1258|
0004e6  2001              MOVS     r0,#1                 ;1691
0004e8  e000              B        |L1.1260|
                  |L1.1258|
0004ea  2000              MOVS     r0,#0                 ;1691
                  |L1.1260|
0004ec  2800              CMP      r0,#0                 ;1691
0004ee  d1ca              BNE      |L1.1158|
                  |L1.1264|
0004f0  2000              MOVS     r0,#0                 ;1714
0004f2  e7b8              B        |L1.1126|
;;;1716   
                          ENDP

                  HAL_UART_Transmit PROC
;;;632      */
;;;633    HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
0004f4  e92d47f0          PUSH     {r4-r10,lr}
;;;634    {
0004f8  4604              MOV      r4,r0
0004fa  460d              MOV      r5,r1
0004fc  4616              MOV      r6,r2
0004fe  4699              MOV      r9,r3
;;;635      uint16_t* tmp;
;;;636      uint32_t tmp_state = 0;
000500  f04f0800          MOV      r8,#0
;;;637      
;;;638      tmp_state = huart->State;
000504  f8948039          LDRB     r8,[r4,#0x39]
;;;639      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
000508  f1b80f01          CMP      r8,#1
00050c  d002              BEQ      |L1.1300|
00050e  f1b80f22          CMP      r8,#0x22
000512  d165              BNE      |L1.1504|
                  |L1.1300|
;;;640      {
;;;641        if((pData == NULL) || (Size == 0))
000514  b105              CBZ      r5,|L1.1304|
000516  b916              CBNZ     r6,|L1.1310|
                  |L1.1304|
;;;642        {
;;;643          return  HAL_ERROR;
000518  2001              MOVS     r0,#1
                  |L1.1306|
;;;644        }
;;;645    
;;;646        /* Process Locked */
;;;647        __HAL_LOCK(huart);
;;;648    
;;;649        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;650        /* Check if a non-blocking receive process is ongoing or not */
;;;651        if(huart->State == HAL_UART_STATE_BUSY_RX) 
;;;652        {
;;;653          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;654        }
;;;655        else
;;;656        {
;;;657          huart->State = HAL_UART_STATE_BUSY_TX;
;;;658        }
;;;659    
;;;660        huart->TxXferSize = Size;
;;;661        huart->TxXferCount = Size;
;;;662        while(huart->TxXferCount > 0)
;;;663        {
;;;664          huart->TxXferCount--;
;;;665          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;666          {
;;;667            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;668            {
;;;669              return HAL_TIMEOUT;
;;;670            }
;;;671            tmp = (uint16_t*) pData;
;;;672            huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;673            if(huart->Init.Parity == UART_PARITY_NONE)
;;;674            {
;;;675              pData +=2;
;;;676            }
;;;677            else
;;;678            { 
;;;679              pData +=1;
;;;680            }
;;;681          } 
;;;682          else
;;;683          {
;;;684            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;685            {
;;;686              return HAL_TIMEOUT;
;;;687            }
;;;688            huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;689          }
;;;690        }
;;;691    
;;;692        if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;693        { 
;;;694          return HAL_TIMEOUT;
;;;695        }
;;;696    
;;;697        /* Check if a non-blocking receive process is ongoing or not */
;;;698        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;699        {
;;;700          huart->State = HAL_UART_STATE_BUSY_RX;
;;;701        }
;;;702        else
;;;703        {
;;;704          huart->State = HAL_UART_STATE_READY;
;;;705        }
;;;706    
;;;707        /* Process Unlocked */
;;;708        __HAL_UNLOCK(huart);
;;;709    
;;;710        return HAL_OK;
;;;711      }
;;;712      else
;;;713      {
;;;714        return HAL_BUSY;
;;;715      }
;;;716    }
00051a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1310|
00051e  bf00              NOP                            ;647
000520  f8940038          LDRB     r0,[r4,#0x38]         ;647
000524  2801              CMP      r0,#1                 ;647
000526  d101              BNE      |L1.1324|
000528  2002              MOVS     r0,#2                 ;647
00052a  e7f6              B        |L1.1306|
                  |L1.1324|
00052c  2001              MOVS     r0,#1                 ;647
00052e  f8840038          STRB     r0,[r4,#0x38]         ;647
000532  bf00              NOP                            ;647
000534  2000              MOVS     r0,#0                 ;649
000536  63e0              STR      r0,[r4,#0x3c]         ;649
000538  f8940039          LDRB     r0,[r4,#0x39]         ;651
00053c  2822              CMP      r0,#0x22              ;651
00053e  d103              BNE      |L1.1352|
000540  2032              MOVS     r0,#0x32              ;653
000542  f8840039          STRB     r0,[r4,#0x39]         ;653
000546  e002              B        |L1.1358|
                  |L1.1352|
000548  2012              MOVS     r0,#0x12              ;657
00054a  f8840039          STRB     r0,[r4,#0x39]         ;657
                  |L1.1358|
00054e  84a6              STRH     r6,[r4,#0x24]         ;660
000550  84e6              STRH     r6,[r4,#0x26]         ;661
000552  e028              B        |L1.1446|
                  |L1.1364|
000554  8ce0              LDRH     r0,[r4,#0x26]         ;664
000556  1e40              SUBS     r0,r0,#1              ;664
000558  84e0              STRH     r0,[r4,#0x26]         ;664
00055a  68a0              LDR      r0,[r4,#8]            ;665
00055c  f5b05f80          CMP      r0,#0x1000            ;665
000560  d114              BNE      |L1.1420|
000562  464b              MOV      r3,r9                 ;667
000564  2200              MOVS     r2,#0                 ;667
000566  2180              MOVS     r1,#0x80              ;667
000568  4620              MOV      r0,r4                 ;667
00056a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00056e  b108              CBZ      r0,|L1.1396|
000570  2003              MOVS     r0,#3                 ;669
000572  e7d2              B        |L1.1306|
                  |L1.1396|
000574  462f              MOV      r7,r5                 ;671
000576  8838              LDRH     r0,[r7,#0]            ;672
000578  f3c00008          UBFX     r0,r0,#0,#9           ;672
00057c  6821              LDR      r1,[r4,#0]            ;672
00057e  6048              STR      r0,[r1,#4]            ;672
000580  6920              LDR      r0,[r4,#0x10]         ;673
000582  b908              CBNZ     r0,|L1.1416|
000584  1cad              ADDS     r5,r5,#2              ;675
000586  e00e              B        |L1.1446|
                  |L1.1416|
000588  1c6d              ADDS     r5,r5,#1              ;679
00058a  e00c              B        |L1.1446|
                  |L1.1420|
00058c  464b              MOV      r3,r9                 ;684
00058e  2200              MOVS     r2,#0                 ;684
000590  2180              MOVS     r1,#0x80              ;684
000592  4620              MOV      r0,r4                 ;684
000594  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000598  b108              CBZ      r0,|L1.1438|
00059a  2003              MOVS     r0,#3                 ;686
00059c  e7bd              B        |L1.1306|
                  |L1.1438|
00059e  f8150b01          LDRB     r0,[r5],#1            ;688
0005a2  6821              LDR      r1,[r4,#0]            ;688
0005a4  6048              STR      r0,[r1,#4]            ;688
                  |L1.1446|
0005a6  8ce0              LDRH     r0,[r4,#0x26]         ;662
0005a8  2800              CMP      r0,#0                 ;662
0005aa  dcd3              BGT      |L1.1364|
0005ac  464b              MOV      r3,r9                 ;692
0005ae  2200              MOVS     r2,#0                 ;692
0005b0  2140              MOVS     r1,#0x40              ;692
0005b2  4620              MOV      r0,r4                 ;692
0005b4  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0005b8  b108              CBZ      r0,|L1.1470|
0005ba  2003              MOVS     r0,#3                 ;694
0005bc  e7ad              B        |L1.1306|
                  |L1.1470|
0005be  f8940039          LDRB     r0,[r4,#0x39]         ;698
0005c2  2832              CMP      r0,#0x32              ;698
0005c4  d103              BNE      |L1.1486|
0005c6  2022              MOVS     r0,#0x22              ;700
0005c8  f8840039          STRB     r0,[r4,#0x39]         ;700
0005cc  e002              B        |L1.1492|
                  |L1.1486|
0005ce  2001              MOVS     r0,#1                 ;704
0005d0  f8840039          STRB     r0,[r4,#0x39]         ;704
                  |L1.1492|
0005d4  bf00              NOP                            ;708
0005d6  2000              MOVS     r0,#0                 ;708
0005d8  f8840038          STRB     r0,[r4,#0x38]         ;708
0005dc  bf00              NOP                            ;708
0005de  e79c              B        |L1.1306|
                  |L1.1504|
0005e0  2002              MOVS     r0,#2                 ;714
0005e2  e79a              B        |L1.1306|
;;;717    
                          ENDP

                  HAL_UART_Receive PROC
;;;726      */
;;;727    HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
0005e4  e92d47f0          PUSH     {r4-r10,lr}
;;;728    {
0005e8  4604              MOV      r4,r0
0005ea  460d              MOV      r5,r1
0005ec  4616              MOV      r6,r2
0005ee  4699              MOV      r9,r3
;;;729      uint16_t* tmp;
;;;730      uint32_t  tmp_state = 0;
0005f0  f04f0800          MOV      r8,#0
;;;731    
;;;732      tmp_state = huart->State;
0005f4  f8948039          LDRB     r8,[r4,#0x39]
;;;733      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
0005f8  f1b80f01          CMP      r8,#1
0005fc  d002              BEQ      |L1.1540|
0005fe  f1b80f12          CMP      r8,#0x12
000602  d169              BNE      |L1.1752|
                  |L1.1540|
;;;734      {
;;;735        if((pData == NULL ) || (Size == 0))
000604  b105              CBZ      r5,|L1.1544|
000606  b916              CBNZ     r6,|L1.1550|
                  |L1.1544|
;;;736        {
;;;737          return  HAL_ERROR;
000608  2001              MOVS     r0,#1
                  |L1.1546|
;;;738        }
;;;739    
;;;740        /* Process Locked */
;;;741        __HAL_LOCK(huart);
;;;742    
;;;743        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;744        /* Check if a non-blocking transmit process is ongoing or not */
;;;745        if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;746        {
;;;747          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;748        }
;;;749        else
;;;750        {
;;;751          huart->State = HAL_UART_STATE_BUSY_RX;
;;;752        }
;;;753    
;;;754        huart->RxXferSize = Size;
;;;755        huart->RxXferCount = Size;
;;;756    
;;;757        /* Check the remain data to be received */
;;;758        while(huart->RxXferCount > 0)
;;;759        {
;;;760          huart->RxXferCount--;
;;;761          if(huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;762          {
;;;763            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;764            {
;;;765              return HAL_TIMEOUT;
;;;766            }
;;;767            tmp = (uint16_t*) pData ;
;;;768            if(huart->Init.Parity == UART_PARITY_NONE)
;;;769            {
;;;770              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;771              pData +=2;
;;;772            }
;;;773            else
;;;774            {
;;;775              *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;776              pData +=1;
;;;777            }
;;;778    
;;;779          }
;;;780          else
;;;781          {
;;;782            if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;783            {
;;;784              return HAL_TIMEOUT;
;;;785            }
;;;786            if(huart->Init.Parity == UART_PARITY_NONE)
;;;787            {
;;;788              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;789            }
;;;790            else
;;;791            {
;;;792              *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;793            }
;;;794    
;;;795          }
;;;796        }
;;;797    
;;;798        /* Check if a non-blocking transmit process is ongoing or not */
;;;799        if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
;;;800        {
;;;801          huart->State = HAL_UART_STATE_BUSY_TX;
;;;802        }
;;;803        else
;;;804        {
;;;805          huart->State = HAL_UART_STATE_READY;
;;;806        }
;;;807        /* Process Unlocked */
;;;808        __HAL_UNLOCK(huart);
;;;809    
;;;810        return HAL_OK;
;;;811      }
;;;812      else
;;;813      {
;;;814        return HAL_BUSY;
;;;815      }
;;;816    }
00060a  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1550|
00060e  bf00              NOP                            ;741
000610  f8940038          LDRB     r0,[r4,#0x38]         ;741
000614  2801              CMP      r0,#1                 ;741
000616  d101              BNE      |L1.1564|
000618  2002              MOVS     r0,#2                 ;741
00061a  e7f6              B        |L1.1546|
                  |L1.1564|
00061c  2001              MOVS     r0,#1                 ;741
00061e  f8840038          STRB     r0,[r4,#0x38]         ;741
000622  bf00              NOP                            ;741
000624  2000              MOVS     r0,#0                 ;743
000626  63e0              STR      r0,[r4,#0x3c]         ;743
000628  f8940039          LDRB     r0,[r4,#0x39]         ;745
00062c  2812              CMP      r0,#0x12              ;745
00062e  d103              BNE      |L1.1592|
000630  2032              MOVS     r0,#0x32              ;747
000632  f8840039          STRB     r0,[r4,#0x39]         ;747
000636  e002              B        |L1.1598|
                  |L1.1592|
000638  2022              MOVS     r0,#0x22              ;751
00063a  f8840039          STRB     r0,[r4,#0x39]         ;751
                  |L1.1598|
00063e  85a6              STRH     r6,[r4,#0x2c]         ;754
000640  85e6              STRH     r6,[r4,#0x2e]         ;755
000642  e035              B        |L1.1712|
                  |L1.1604|
000644  8de0              LDRH     r0,[r4,#0x2e]         ;760
000646  1e40              SUBS     r0,r0,#1              ;760
000648  85e0              STRH     r0,[r4,#0x2e]         ;760
00064a  68a0              LDR      r0,[r4,#8]            ;761
00064c  f5b05f80          CMP      r0,#0x1000            ;761
000650  d118              BNE      |L1.1668|
000652  464b              MOV      r3,r9                 ;763
000654  2200              MOVS     r2,#0                 ;763
000656  2120              MOVS     r1,#0x20              ;763
000658  4620              MOV      r0,r4                 ;763
00065a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00065e  b108              CBZ      r0,|L1.1636|
000660  2003              MOVS     r0,#3                 ;765
000662  e7d2              B        |L1.1546|
                  |L1.1636|
000664  462f              MOV      r7,r5                 ;767
000666  6920              LDR      r0,[r4,#0x10]         ;768
000668  b930              CBNZ     r0,|L1.1656|
00066a  6820              LDR      r0,[r4,#0]            ;770
00066c  6840              LDR      r0,[r0,#4]            ;770
00066e  f3c00008          UBFX     r0,r0,#0,#9           ;770
000672  8038              STRH     r0,[r7,#0]            ;770
000674  1cad              ADDS     r5,r5,#2              ;771
000676  e01b              B        |L1.1712|
                  |L1.1656|
000678  6820              LDR      r0,[r4,#0]            ;775
00067a  6840              LDR      r0,[r0,#4]            ;775
00067c  b2c0              UXTB     r0,r0                 ;775
00067e  8038              STRH     r0,[r7,#0]            ;775
000680  1c6d              ADDS     r5,r5,#1              ;776
000682  e015              B        |L1.1712|
                  |L1.1668|
000684  464b              MOV      r3,r9                 ;782
000686  2200              MOVS     r2,#0                 ;782
000688  2120              MOVS     r1,#0x20              ;782
00068a  4620              MOV      r0,r4                 ;782
00068c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000690  b108              CBZ      r0,|L1.1686|
000692  2003              MOVS     r0,#3                 ;784
000694  e7b9              B        |L1.1546|
                  |L1.1686|
000696  6920              LDR      r0,[r4,#0x10]         ;786
000698  b920              CBNZ     r0,|L1.1700|
00069a  6820              LDR      r0,[r4,#0]            ;788
00069c  6840              LDR      r0,[r0,#4]            ;788
00069e  f8050b01          STRB     r0,[r5],#1            ;788
0006a2  e005              B        |L1.1712|
                  |L1.1700|
0006a4  6820              LDR      r0,[r4,#0]            ;792
0006a6  6840              LDR      r0,[r0,#4]            ;792
0006a8  f000007f          AND      r0,r0,#0x7f           ;792
0006ac  f8050b01          STRB     r0,[r5],#1            ;792
                  |L1.1712|
0006b0  8de0              LDRH     r0,[r4,#0x2e]         ;758
0006b2  2800              CMP      r0,#0                 ;758
0006b4  dcc6              BGT      |L1.1604|
0006b6  f8940039          LDRB     r0,[r4,#0x39]         ;799
0006ba  2832              CMP      r0,#0x32              ;799
0006bc  d103              BNE      |L1.1734|
0006be  2012              MOVS     r0,#0x12              ;801
0006c0  f8840039          STRB     r0,[r4,#0x39]         ;801
0006c4  e002              B        |L1.1740|
                  |L1.1734|
0006c6  2001              MOVS     r0,#1                 ;805
0006c8  f8840039          STRB     r0,[r4,#0x39]         ;805
                  |L1.1740|
0006cc  bf00              NOP                            ;808
0006ce  2000              MOVS     r0,#0                 ;808
0006d0  f8840038          STRB     r0,[r4,#0x38]         ;808
0006d4  bf00              NOP                            ;808
0006d6  e798              B        |L1.1546|
                  |L1.1752|
0006d8  2002              MOVS     r0,#2                 ;814
0006da  e796              B        |L1.1546|
;;;817    
                          ENDP

                  HAL_UART_Transmit_IT PROC
;;;825      */
;;;826    HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
0006dc  b530              PUSH     {r4,r5,lr}
;;;827    {
0006de  4603              MOV      r3,r0
;;;828      uint32_t tmp_state = 0;
0006e0  2400              MOVS     r4,#0
;;;829    
;;;830      tmp_state = huart->State;
0006e2  f8934039          LDRB     r4,[r3,#0x39]
;;;831      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
0006e6  2c01              CMP      r4,#1
0006e8  d001              BEQ      |L1.1774|
0006ea  2c22              CMP      r4,#0x22
0006ec  d12b              BNE      |L1.1862|
                  |L1.1774|
;;;832      {
;;;833        if((pData == NULL ) || (Size == 0))
0006ee  b101              CBZ      r1,|L1.1778|
0006f0  b90a              CBNZ     r2,|L1.1782|
                  |L1.1778|
;;;834        {
;;;835          return HAL_ERROR;
0006f2  2001              MOVS     r0,#1
                  |L1.1780|
;;;836        }
;;;837        
;;;838        /* Process Locked */
;;;839        __HAL_LOCK(huart);
;;;840        
;;;841        huart->pTxBuffPtr = pData;
;;;842        huart->TxXferSize = Size;
;;;843        huart->TxXferCount = Size;
;;;844    
;;;845        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;846        /* Check if a receive process is ongoing or not */
;;;847        if(huart->State == HAL_UART_STATE_BUSY_RX) 
;;;848        {
;;;849          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;850        }
;;;851        else
;;;852        {
;;;853          huart->State = HAL_UART_STATE_BUSY_TX;
;;;854        }
;;;855    
;;;856        /* Process Unlocked */
;;;857        __HAL_UNLOCK(huart);
;;;858    
;;;859        /* Enable the UART Transmit data register empty Interrupt */
;;;860        __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;861        
;;;862        return HAL_OK;
;;;863      }
;;;864      else
;;;865      {
;;;866        return HAL_BUSY;
;;;867      }
;;;868    }
0006f4  bd30              POP      {r4,r5,pc}
                  |L1.1782|
0006f6  bf00              NOP                            ;839
0006f8  f8930038          LDRB     r0,[r3,#0x38]         ;839
0006fc  2801              CMP      r0,#1                 ;839
0006fe  d101              BNE      |L1.1796|
000700  2002              MOVS     r0,#2                 ;839
000702  e7f7              B        |L1.1780|
                  |L1.1796|
000704  2001              MOVS     r0,#1                 ;839
000706  f8830038          STRB     r0,[r3,#0x38]         ;839
00070a  bf00              NOP                            ;839
00070c  6219              STR      r1,[r3,#0x20]         ;841
00070e  849a              STRH     r2,[r3,#0x24]         ;842
000710  84da              STRH     r2,[r3,#0x26]         ;843
000712  2000              MOVS     r0,#0                 ;845
000714  63d8              STR      r0,[r3,#0x3c]         ;845
000716  f8930039          LDRB     r0,[r3,#0x39]         ;847
00071a  2822              CMP      r0,#0x22              ;847
00071c  d103              BNE      |L1.1830|
00071e  2032              MOVS     r0,#0x32              ;849
000720  f8830039          STRB     r0,[r3,#0x39]         ;849
000724  e002              B        |L1.1836|
                  |L1.1830|
000726  2012              MOVS     r0,#0x12              ;853
000728  f8830039          STRB     r0,[r3,#0x39]         ;853
                  |L1.1836|
00072c  bf00              NOP                            ;857
00072e  2000              MOVS     r0,#0                 ;857
000730  f8830038          STRB     r0,[r3,#0x38]         ;857
000734  bf00              NOP                            ;857
000736  6818              LDR      r0,[r3,#0]            ;860
000738  68c0              LDR      r0,[r0,#0xc]          ;860
00073a  f0400080          ORR      r0,r0,#0x80           ;860
00073e  681d              LDR      r5,[r3,#0]            ;860
000740  60e8              STR      r0,[r5,#0xc]          ;860
000742  2000              MOVS     r0,#0                 ;862
000744  e7d6              B        |L1.1780|
                  |L1.1862|
000746  2002              MOVS     r0,#2                 ;866
000748  e7d4              B        |L1.1780|
;;;869    
                          ENDP

                  HAL_UART_Receive_IT PROC
;;;877      */
;;;878    HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
00074a  b530              PUSH     {r4,r5,lr}
;;;879    {
00074c  4603              MOV      r3,r0
;;;880      uint32_t tmp_state = 0;
00074e  2400              MOVS     r4,#0
;;;881      
;;;882      tmp_state = huart->State;
000750  f8934039          LDRB     r4,[r3,#0x39]
;;;883      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
000754  2c01              CMP      r4,#1
000756  d001              BEQ      |L1.1884|
000758  2c12              CMP      r4,#0x12
00075a  d137              BNE      |L1.1996|
                  |L1.1884|
;;;884      {
;;;885        if((pData == NULL ) || (Size == 0))
00075c  b101              CBZ      r1,|L1.1888|
00075e  b90a              CBNZ     r2,|L1.1892|
                  |L1.1888|
;;;886        {
;;;887          return HAL_ERROR;
000760  2001              MOVS     r0,#1
                  |L1.1890|
;;;888        }
;;;889    
;;;890        /* Process Locked */
;;;891        __HAL_LOCK(huart);
;;;892    
;;;893        huart->pRxBuffPtr = pData;
;;;894        huart->RxXferSize = Size;
;;;895        huart->RxXferCount = Size;
;;;896    
;;;897        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;898        /* Check if a transmit process is ongoing or not */
;;;899        if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;900        {
;;;901          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;902        }
;;;903        else
;;;904        {
;;;905          huart->State = HAL_UART_STATE_BUSY_RX;
;;;906        }
;;;907    
;;;908        /* Process Unlocked */
;;;909        __HAL_UNLOCK(huart);
;;;910    
;;;911        /* Enable the UART Parity Error Interrupt */
;;;912        __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;913    
;;;914        /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;915        __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;916    
;;;917        /* Enable the UART Data Register not empty Interrupt */
;;;918        __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;919    
;;;920        return HAL_OK;
;;;921      }
;;;922      else
;;;923      {
;;;924        return HAL_BUSY;
;;;925      }
;;;926    }
000762  bd30              POP      {r4,r5,pc}
                  |L1.1892|
000764  bf00              NOP                            ;891
000766  f8930038          LDRB     r0,[r3,#0x38]         ;891
00076a  2801              CMP      r0,#1                 ;891
00076c  d101              BNE      |L1.1906|
00076e  2002              MOVS     r0,#2                 ;891
000770  e7f7              B        |L1.1890|
                  |L1.1906|
000772  2001              MOVS     r0,#1                 ;891
000774  f8830038          STRB     r0,[r3,#0x38]         ;891
000778  bf00              NOP                            ;891
00077a  6299              STR      r1,[r3,#0x28]         ;893
00077c  859a              STRH     r2,[r3,#0x2c]         ;894
00077e  85da              STRH     r2,[r3,#0x2e]         ;895
000780  2000              MOVS     r0,#0                 ;897
000782  63d8              STR      r0,[r3,#0x3c]         ;897
000784  f8930039          LDRB     r0,[r3,#0x39]         ;899
000788  2812              CMP      r0,#0x12              ;899
00078a  d103              BNE      |L1.1940|
00078c  2032              MOVS     r0,#0x32              ;901
00078e  f8830039          STRB     r0,[r3,#0x39]         ;901
000792  e002              B        |L1.1946|
                  |L1.1940|
000794  2022              MOVS     r0,#0x22              ;905
000796  f8830039          STRB     r0,[r3,#0x39]         ;905
                  |L1.1946|
00079a  bf00              NOP                            ;909
00079c  2000              MOVS     r0,#0                 ;909
00079e  f8830038          STRB     r0,[r3,#0x38]         ;909
0007a2  bf00              NOP                            ;909
0007a4  6818              LDR      r0,[r3,#0]            ;912
0007a6  68c0              LDR      r0,[r0,#0xc]          ;912
0007a8  f4407080          ORR      r0,r0,#0x100          ;912
0007ac  681d              LDR      r5,[r3,#0]            ;912
0007ae  60e8              STR      r0,[r5,#0xc]          ;912
0007b0  6818              LDR      r0,[r3,#0]            ;915
0007b2  6940              LDR      r0,[r0,#0x14]         ;915
0007b4  f0400001          ORR      r0,r0,#1              ;915
0007b8  681d              LDR      r5,[r3,#0]            ;915
0007ba  6168              STR      r0,[r5,#0x14]         ;915
0007bc  6818              LDR      r0,[r3,#0]            ;918
0007be  68c0              LDR      r0,[r0,#0xc]          ;918
0007c0  f0400020          ORR      r0,r0,#0x20           ;918
0007c4  681d              LDR      r5,[r3,#0]            ;918
0007c6  60e8              STR      r0,[r5,#0xc]          ;918
0007c8  2000              MOVS     r0,#0                 ;920
0007ca  e7ca              B        |L1.1890|
                  |L1.1996|
0007cc  2002              MOVS     r0,#2                 ;924
0007ce  e7c8              B        |L1.1890|
;;;927    
                          ENDP

                  HAL_UART_ErrorCallback PROC
;;;1324     */
;;;1325    __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
0007d0  4770              BX       lr
;;;1326   {
;;;1327     /* Prevent unused argument(s) compilation warning */
;;;1328     UNUSED(huart);
;;;1329     /* NOTE: This function should not be modified, when the callback is needed,
;;;1330              the HAL_UART_ErrorCallback can be implemented in the user file
;;;1331      */ 
;;;1332   }
;;;1333   
                          ENDP

                  UART_DMAError PROC
;;;1636     */
;;;1637   static void UART_DMAError(DMA_HandleTypeDef *hdma)   
0007d2  b570              PUSH     {r4-r6,lr}
;;;1638   {
0007d4  4605              MOV      r5,r0
;;;1639     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
0007d6  6a6c              LDR      r4,[r5,#0x24]
;;;1640     huart->RxXferCount = 0;
0007d8  2000              MOVS     r0,#0
0007da  85e0              STRH     r0,[r4,#0x2e]
;;;1641     huart->TxXferCount = 0;
0007dc  84e0              STRH     r0,[r4,#0x26]
;;;1642     huart->State= HAL_UART_STATE_READY;
0007de  2001              MOVS     r0,#1
0007e0  f8840039          STRB     r0,[r4,#0x39]
;;;1643     huart->ErrorCode |= HAL_UART_ERROR_DMA;
0007e4  6be0              LDR      r0,[r4,#0x3c]
0007e6  f0400010          ORR      r0,r0,#0x10
0007ea  63e0              STR      r0,[r4,#0x3c]
;;;1644     HAL_UART_ErrorCallback(huart);
0007ec  4620              MOV      r0,r4
0007ee  f7fffffe          BL       HAL_UART_ErrorCallback
;;;1645   }
0007f2  bd70              POP      {r4-r6,pc}
;;;1646   
                          ENDP

                  HAL_UART_TxHalfCpltCallback PROC
;;;1279     */
;;;1280    __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
0007f4  4770              BX       lr
;;;1281   {
;;;1282     /* Prevent unused argument(s) compilation warning */
;;;1283     UNUSED(huart);
;;;1284     /* NOTE: This function should not be modified, when the callback is needed,
;;;1285              the HAL_UART_TxHalfCpltCallback can be implemented in the user file
;;;1286      */ 
;;;1287   }
;;;1288   
                          ENDP

                  UART_DMATxHalfCplt PROC
;;;1579     */
;;;1580   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
0007f6  b570              PUSH     {r4-r6,lr}
;;;1581   {
0007f8  4604              MOV      r4,r0
;;;1582     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
0007fa  6a65              LDR      r5,[r4,#0x24]
;;;1583   
;;;1584     HAL_UART_TxHalfCpltCallback(huart);
0007fc  4628              MOV      r0,r5
0007fe  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;1585   }
000802  bd70              POP      {r4-r6,pc}
;;;1586   
                          ENDP

                  HAL_UART_TxCpltCallback PROC
;;;1264     */
;;;1265    __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000804  4770              BX       lr
;;;1266   {
;;;1267     /* Prevent unused argument(s) compilation warning */
;;;1268     UNUSED(huart);
;;;1269     /* NOTE: This function should not be modified, when the callback is needed,
;;;1270              the HAL_UART_TxCpltCallback can be implemented in the user file
;;;1271      */ 
;;;1272   }
;;;1273   
                          ENDP

                  UART_DMATransmitCplt PROC
;;;1551     */
;;;1552   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
000806  b570              PUSH     {r4-r6,lr}
;;;1553   {
000808  4605              MOV      r5,r0
;;;1554     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00080a  6a6c              LDR      r4,[r5,#0x24]
;;;1555     /* DMA Normal mode*/
;;;1556     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
00080c  6828              LDR      r0,[r5,#0]
00080e  6800              LDR      r0,[r0,#0]
000810  f0000020          AND      r0,r0,#0x20
000814  b970              CBNZ     r0,|L1.2100|
;;;1557     {
;;;1558       huart->TxXferCount = 0;
000816  2000              MOVS     r0,#0
000818  84e0              STRH     r0,[r4,#0x26]
;;;1559   
;;;1560       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;1561          in the UART CR3 register */
;;;1562       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00081a  6820              LDR      r0,[r4,#0]
00081c  6940              LDR      r0,[r0,#0x14]
00081e  f0200080          BIC      r0,r0,#0x80
000822  6821              LDR      r1,[r4,#0]
000824  6148              STR      r0,[r1,#0x14]
;;;1563   
;;;1564       /* Enable the UART Transmit Complete Interrupt */    
;;;1565       __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
000826  6820              LDR      r0,[r4,#0]
000828  68c0              LDR      r0,[r0,#0xc]
00082a  f0400040          ORR      r0,r0,#0x40
00082e  6821              LDR      r1,[r4,#0]
000830  60c8              STR      r0,[r1,#0xc]
000832  e002              B        |L1.2106|
                  |L1.2100|
;;;1566     }
;;;1567     /* DMA Circular mode */
;;;1568     else
;;;1569     {
;;;1570       HAL_UART_TxCpltCallback(huart);
000834  4620              MOV      r0,r4
000836  f7fffffe          BL       HAL_UART_TxCpltCallback
                  |L1.2106|
;;;1571     }
;;;1572   }
00083a  bd70              POP      {r4-r6,pc}
;;;1573   
                          ENDP

                  HAL_UART_Transmit_DMA PROC
;;;935      */
;;;936    HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
00083c  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;937    {
00083e  4604              MOV      r4,r0
000840  4615              MOV      r5,r2
;;;938      uint32_t *tmp;
;;;939      uint32_t tmp_state = 0;
000842  2700              MOVS     r7,#0
;;;940    
;;;941      tmp_state = huart->State;
000844  f8947039          LDRB     r7,[r4,#0x39]
;;;942      if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_RX))
000848  2f01              CMP      r7,#1
00084a  d001              BEQ      |L1.2128|
00084c  2f22              CMP      r7,#0x22
00084e  d141              BNE      |L1.2260|
                  |L1.2128|
;;;943      {
;;;944        if((pData == NULL ) || (Size == 0)) 
000850  9801              LDR      r0,[sp,#4]
000852  b100              CBZ      r0,|L1.2134|
000854  b90d              CBNZ     r5,|L1.2138|
                  |L1.2134|
;;;945        {
;;;946          return HAL_ERROR;
000856  2001              MOVS     r0,#1
                  |L1.2136|
;;;947        }
;;;948    
;;;949        /* Process Locked */
;;;950        __HAL_LOCK(huart);
;;;951    
;;;952        huart->pTxBuffPtr = pData;
;;;953        huart->TxXferSize = Size;
;;;954        huart->TxXferCount = Size;
;;;955    
;;;956        huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;957        /* Check if a receive process is ongoing or not */
;;;958        if(huart->State == HAL_UART_STATE_BUSY_RX)
;;;959        {
;;;960          huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;961        }
;;;962        else
;;;963        {
;;;964          huart->State = HAL_UART_STATE_BUSY_TX;
;;;965        }
;;;966    
;;;967        /* Set the UART DMA transfer complete callback */
;;;968        huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;969    
;;;970        /* Set the UART DMA Half transfer complete callback */
;;;971        huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;972    
;;;973        /* Set the DMA error callback */
;;;974        huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;975    
;;;976        /* Enable the UART transmit DMA channel */
;;;977        tmp = (uint32_t*)&pData;
;;;978        HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t*)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;979    
;;;980        /* Clear the TC flag in the SR register by writing 0 to it */
;;;981        __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;982    
;;;983        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;984           in the UART CR3 register */
;;;985        SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;986    
;;;987        /* Process Unlocked */
;;;988        __HAL_UNLOCK(huart);
;;;989    
;;;990        return HAL_OK;
;;;991      }
;;;992      else
;;;993      {
;;;994        return HAL_BUSY;
;;;995      }
;;;996    }
000858  bdfe              POP      {r1-r7,pc}
                  |L1.2138|
00085a  bf00              NOP                            ;950
00085c  f8940038          LDRB     r0,[r4,#0x38]         ;950
000860  2801              CMP      r0,#1                 ;950
000862  d101              BNE      |L1.2152|
000864  2002              MOVS     r0,#2                 ;950
000866  e7f7              B        |L1.2136|
                  |L1.2152|
000868  2001              MOVS     r0,#1                 ;950
00086a  f8840038          STRB     r0,[r4,#0x38]         ;950
00086e  bf00              NOP                            ;950
000870  9801              LDR      r0,[sp,#4]            ;952
000872  6220              STR      r0,[r4,#0x20]         ;952
000874  84a5              STRH     r5,[r4,#0x24]         ;953
000876  84e5              STRH     r5,[r4,#0x26]         ;954
000878  2000              MOVS     r0,#0                 ;956
00087a  63e0              STR      r0,[r4,#0x3c]         ;956
00087c  f8940039          LDRB     r0,[r4,#0x39]         ;958
000880  2822              CMP      r0,#0x22              ;958
000882  d103              BNE      |L1.2188|
000884  2032              MOVS     r0,#0x32              ;960
000886  f8840039          STRB     r0,[r4,#0x39]         ;960
00088a  e002              B        |L1.2194|
                  |L1.2188|
00088c  2012              MOVS     r0,#0x12              ;964
00088e  f8840039          STRB     r0,[r4,#0x39]         ;964
                  |L1.2194|
000892  48fe              LDR      r0,|L1.3212|
000894  6b21              LDR      r1,[r4,#0x30]         ;968
000896  6288              STR      r0,[r1,#0x28]         ;968
000898  48fd              LDR      r0,|L1.3216|
00089a  6b21              LDR      r1,[r4,#0x30]         ;971
00089c  62c8              STR      r0,[r1,#0x2c]         ;971
00089e  48fd              LDR      r0,|L1.3220|
0008a0  6b21              LDR      r1,[r4,#0x30]         ;974
0008a2  6308              STR      r0,[r1,#0x30]         ;974
0008a4  ae01              ADD      r6,sp,#4              ;977
0008a6  6823              LDR      r3,[r4,#0]            ;978
0008a8  1d1a              ADDS     r2,r3,#4              ;978
0008aa  6831              LDR      r1,[r6,#0]            ;978
0008ac  462b              MOV      r3,r5                 ;978
0008ae  6b20              LDR      r0,[r4,#0x30]         ;978
0008b0  f7fffffe          BL       HAL_DMA_Start_IT
0008b4  f06f0040          MVN      r0,#0x40              ;981
0008b8  6821              LDR      r1,[r4,#0]            ;981
0008ba  6008              STR      r0,[r1,#0]            ;981
0008bc  6820              LDR      r0,[r4,#0]            ;985
0008be  6940              LDR      r0,[r0,#0x14]         ;985
0008c0  f0400080          ORR      r0,r0,#0x80           ;985
0008c4  6821              LDR      r1,[r4,#0]            ;985
0008c6  6148              STR      r0,[r1,#0x14]         ;985
0008c8  bf00              NOP                            ;988
0008ca  2000              MOVS     r0,#0                 ;988
0008cc  f8840038          STRB     r0,[r4,#0x38]         ;988
0008d0  bf00              NOP                            ;988
0008d2  e7c1              B        |L1.2136|
                  |L1.2260|
0008d4  2002              MOVS     r0,#2                 ;994
0008d6  e7bf              B        |L1.2136|
;;;997    
                          ENDP

                  HAL_UART_RxHalfCpltCallback PROC
;;;1309     */
;;;1310   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
0008d8  4770              BX       lr
;;;1311   {
;;;1312     /* Prevent unused argument(s) compilation warning */
;;;1313     UNUSED(huart);
;;;1314     /* NOTE: This function should not be modified, when the callback is needed,
;;;1315              the HAL_UART_RxHalfCpltCallback can be implemented in the user file
;;;1316      */
;;;1317   }
;;;1318   
                          ENDP

                  UART_DMARxHalfCplt PROC
;;;1623     */
;;;1624   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
0008da  b570              PUSH     {r4-r6,lr}
;;;1625   {
0008dc  4604              MOV      r4,r0
;;;1626     UART_HandleTypeDef* huart = (UART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
0008de  6a65              LDR      r5,[r4,#0x24]
;;;1627   
;;;1628     HAL_UART_RxHalfCpltCallback(huart); 
0008e0  4628              MOV      r0,r5
0008e2  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;1629   }
0008e6  bd70              POP      {r4-r6,pc}
;;;1630   
                          ENDP

                  HAL_UART_RxCpltCallback PROC
;;;1294     */
;;;1295   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
0008e8  4770              BX       lr
;;;1296   {
;;;1297     /* Prevent unused argument(s) compilation warning */
;;;1298     UNUSED(huart);
;;;1299     /* NOTE: This function should not be modified, when the callback is needed,
;;;1300              the HAL_UART_RxCpltCallback can be implemented in the user file
;;;1301      */
;;;1302   }
;;;1303   
                          ENDP

                  UART_DMAReceiveCplt PROC
;;;1592     */
;;;1593   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
0008ea  b570              PUSH     {r4-r6,lr}
;;;1594   {
0008ec  4605              MOV      r5,r0
;;;1595     UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
0008ee  6a6c              LDR      r4,[r5,#0x24]
;;;1596     /* DMA Normal mode*/
;;;1597     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
0008f0  6828              LDR      r0,[r5,#0]
0008f2  6800              LDR      r0,[r0,#0]
0008f4  f0000020          AND      r0,r0,#0x20
0008f8  b990              CBNZ     r0,|L1.2336|
;;;1598     {
;;;1599       huart->RxXferCount = 0;
0008fa  2000              MOVS     r0,#0
0008fc  85e0              STRH     r0,[r4,#0x2e]
;;;1600     
;;;1601       /* Disable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1602          in the UART CR3 register */
;;;1603       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0008fe  6820              LDR      r0,[r4,#0]
000900  6940              LDR      r0,[r0,#0x14]
000902  f0200040          BIC      r0,r0,#0x40
000906  6821              LDR      r1,[r4,#0]
000908  6148              STR      r0,[r1,#0x14]
;;;1604   
;;;1605       /* Check if a transmit process is ongoing or not */
;;;1606       if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
00090a  f8940039          LDRB     r0,[r4,#0x39]
00090e  2832              CMP      r0,#0x32
000910  d103              BNE      |L1.2330|
;;;1607       {
;;;1608         huart->State = HAL_UART_STATE_BUSY_TX;
000912  2012              MOVS     r0,#0x12
000914  f8840039          STRB     r0,[r4,#0x39]
000918  e002              B        |L1.2336|
                  |L1.2330|
;;;1609       }
;;;1610       else
;;;1611       {
;;;1612         huart->State = HAL_UART_STATE_READY;
00091a  2001              MOVS     r0,#1
00091c  f8840039          STRB     r0,[r4,#0x39]
                  |L1.2336|
;;;1613       }
;;;1614     }
;;;1615     HAL_UART_RxCpltCallback(huart);
000920  4620              MOV      r0,r4
000922  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1616   }
000926  bd70              POP      {r4-r6,pc}
;;;1617   
                          ENDP

                  HAL_UART_Receive_DMA PROC
;;;1007     */
;;;1008   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000928  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1009   {
00092a  4604              MOV      r4,r0
00092c  4615              MOV      r5,r2
;;;1010     uint32_t *tmp;
;;;1011     uint32_t tmp_state = 0;
00092e  2700              MOVS     r7,#0
;;;1012   
;;;1013     tmp_state = huart->State;
000930  f8947039          LDRB     r7,[r4,#0x39]
;;;1014     if((tmp_state == HAL_UART_STATE_READY) || (tmp_state == HAL_UART_STATE_BUSY_TX))
000934  2f01              CMP      r7,#1
000936  d001              BEQ      |L1.2364|
000938  2f12              CMP      r7,#0x12
00093a  d13c              BNE      |L1.2486|
                  |L1.2364|
;;;1015     {
;;;1016       if((pData == NULL ) || (Size == 0))
00093c  9801              LDR      r0,[sp,#4]
00093e  b100              CBZ      r0,|L1.2370|
000940  b90d              CBNZ     r5,|L1.2374|
                  |L1.2370|
;;;1017       {
;;;1018         return HAL_ERROR;
000942  2001              MOVS     r0,#1
                  |L1.2372|
;;;1019       }
;;;1020   
;;;1021       /* Process Locked */
;;;1022       __HAL_LOCK(huart);
;;;1023   
;;;1024       huart->pRxBuffPtr = pData;
;;;1025       huart->RxXferSize = Size;
;;;1026   
;;;1027       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1028       /* Check if a transmit process is ongoing or not */
;;;1029       if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;1030       {
;;;1031         huart->State = HAL_UART_STATE_BUSY_TX_RX;
;;;1032       }
;;;1033       else
;;;1034       {
;;;1035         huart->State = HAL_UART_STATE_BUSY_RX;
;;;1036       }
;;;1037   
;;;1038       /* Set the UART DMA transfer complete callback */
;;;1039       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1040   
;;;1041       /* Set the UART DMA Half transfer complete callback */
;;;1042       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1043   
;;;1044       /* Set the DMA error callback */
;;;1045       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1046   
;;;1047       /* Enable the DMA channel */
;;;1048       tmp = (uint32_t*)&pData;
;;;1049       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1050   
;;;1051       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1052          in the UART CR3 register */
;;;1053       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1054   
;;;1055       /* Process Unlocked */
;;;1056       __HAL_UNLOCK(huart);
;;;1057   
;;;1058       return HAL_OK;
;;;1059     }
;;;1060     else
;;;1061     {
;;;1062       return HAL_BUSY;
;;;1063     }
;;;1064   }
000944  bdfe              POP      {r1-r7,pc}
                  |L1.2374|
000946  bf00              NOP                            ;1022
000948  f8940038          LDRB     r0,[r4,#0x38]         ;1022
00094c  2801              CMP      r0,#1                 ;1022
00094e  d101              BNE      |L1.2388|
000950  2002              MOVS     r0,#2                 ;1022
000952  e7f7              B        |L1.2372|
                  |L1.2388|
000954  2001              MOVS     r0,#1                 ;1022
000956  f8840038          STRB     r0,[r4,#0x38]         ;1022
00095a  bf00              NOP                            ;1022
00095c  9801              LDR      r0,[sp,#4]            ;1024
00095e  62a0              STR      r0,[r4,#0x28]         ;1024
000960  85a5              STRH     r5,[r4,#0x2c]         ;1025
000962  2000              MOVS     r0,#0                 ;1027
000964  63e0              STR      r0,[r4,#0x3c]         ;1027
000966  f8940039          LDRB     r0,[r4,#0x39]         ;1029
00096a  2812              CMP      r0,#0x12              ;1029
00096c  d103              BNE      |L1.2422|
00096e  2032              MOVS     r0,#0x32              ;1031
000970  f8840039          STRB     r0,[r4,#0x39]         ;1031
000974  e002              B        |L1.2428|
                  |L1.2422|
000976  2022              MOVS     r0,#0x22              ;1035
000978  f8840039          STRB     r0,[r4,#0x39]         ;1035
                  |L1.2428|
00097c  48c6              LDR      r0,|L1.3224|
00097e  6b61              LDR      r1,[r4,#0x34]         ;1039
000980  6288              STR      r0,[r1,#0x28]         ;1039
000982  48c6              LDR      r0,|L1.3228|
000984  6b61              LDR      r1,[r4,#0x34]         ;1042
000986  62c8              STR      r0,[r1,#0x2c]         ;1042
000988  48c2              LDR      r0,|L1.3220|
00098a  6b61              LDR      r1,[r4,#0x34]         ;1045
00098c  6308              STR      r0,[r1,#0x30]         ;1045
00098e  ae01              ADD      r6,sp,#4              ;1048
000990  6832              LDR      r2,[r6,#0]            ;1049
000992  6823              LDR      r3,[r4,#0]            ;1049
000994  1d19              ADDS     r1,r3,#4              ;1049
000996  462b              MOV      r3,r5                 ;1049
000998  6b60              LDR      r0,[r4,#0x34]         ;1049
00099a  f7fffffe          BL       HAL_DMA_Start_IT
00099e  6820              LDR      r0,[r4,#0]            ;1053
0009a0  6940              LDR      r0,[r0,#0x14]         ;1053
0009a2  f0400040          ORR      r0,r0,#0x40           ;1053
0009a6  6821              LDR      r1,[r4,#0]            ;1053
0009a8  6148              STR      r0,[r1,#0x14]         ;1053
0009aa  bf00              NOP                            ;1056
0009ac  2000              MOVS     r0,#0                 ;1056
0009ae  f8840038          STRB     r0,[r4,#0x38]         ;1056
0009b2  bf00              NOP                            ;1056
0009b4  e7c6              B        |L1.2372|
                  |L1.2486|
0009b6  2002              MOVS     r0,#2                 ;1062
0009b8  e7c4              B        |L1.2372|
;;;1065       
                          ENDP

                  HAL_UART_DMAPause PROC
;;;1071     */
;;;1072   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
0009ba  4601              MOV      r1,r0
;;;1073   {
;;;1074     /* Process Locked */
;;;1075     __HAL_LOCK(huart);
0009bc  bf00              NOP      
0009be  f8910038          LDRB     r0,[r1,#0x38]
0009c2  2801              CMP      r0,#1
0009c4  d101              BNE      |L1.2506|
0009c6  2002              MOVS     r0,#2
                  |L1.2504|
;;;1076     
;;;1077     if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;1078     {
;;;1079       /* Disable the UART DMA Tx request */
;;;1080       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1081     }
;;;1082     else if(huart->State == HAL_UART_STATE_BUSY_RX)
;;;1083     {
;;;1084       /* Disable the UART DMA Rx request */
;;;1085       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1086     }
;;;1087     else if (huart->State == HAL_UART_STATE_BUSY_TX_RX)
;;;1088     {
;;;1089       /* Disable the UART DMA Tx & Rx requests */
;;;1090       CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
;;;1091     }
;;;1092     else
;;;1093     {
;;;1094       /* Process Unlocked */
;;;1095       __HAL_UNLOCK(huart);
;;;1096     
;;;1097       return HAL_ERROR; 
;;;1098     }
;;;1099     
;;;1100     /* Process Unlocked */
;;;1101     __HAL_UNLOCK(huart);
;;;1102   
;;;1103     return HAL_OK; 
;;;1104   }
0009c8  4770              BX       lr
                  |L1.2506|
0009ca  2001              MOVS     r0,#1                 ;1075
0009cc  f8810038          STRB     r0,[r1,#0x38]         ;1075
0009d0  bf00              NOP                            ;1075
0009d2  f8910039          LDRB     r0,[r1,#0x39]         ;1077
0009d6  2812              CMP      r0,#0x12              ;1077
0009d8  d106              BNE      |L1.2536|
0009da  6808              LDR      r0,[r1,#0]            ;1080
0009dc  6940              LDR      r0,[r0,#0x14]         ;1080
0009de  f0200080          BIC      r0,r0,#0x80           ;1080
0009e2  680a              LDR      r2,[r1,#0]            ;1080
0009e4  6150              STR      r0,[r2,#0x14]         ;1080
0009e6  e01c              B        |L1.2594|
                  |L1.2536|
0009e8  f8910039          LDRB     r0,[r1,#0x39]         ;1082
0009ec  2822              CMP      r0,#0x22              ;1082
0009ee  d106              BNE      |L1.2558|
0009f0  6808              LDR      r0,[r1,#0]            ;1085
0009f2  6940              LDR      r0,[r0,#0x14]         ;1085
0009f4  f0200040          BIC      r0,r0,#0x40           ;1085
0009f8  680a              LDR      r2,[r1,#0]            ;1085
0009fa  6150              STR      r0,[r2,#0x14]         ;1085
0009fc  e011              B        |L1.2594|
                  |L1.2558|
0009fe  f8910039          LDRB     r0,[r1,#0x39]         ;1087
000a02  2832              CMP      r0,#0x32              ;1087
000a04  d106              BNE      |L1.2580|
000a06  6808              LDR      r0,[r1,#0]            ;1090
000a08  6940              LDR      r0,[r0,#0x14]         ;1090
000a0a  f02000c0          BIC      r0,r0,#0xc0           ;1090
000a0e  680a              LDR      r2,[r1,#0]            ;1090
000a10  6150              STR      r0,[r2,#0x14]         ;1090
000a12  e006              B        |L1.2594|
                  |L1.2580|
000a14  bf00              NOP                            ;1095
000a16  2000              MOVS     r0,#0                 ;1095
000a18  f8810038          STRB     r0,[r1,#0x38]         ;1095
000a1c  bf00              NOP                            ;1095
000a1e  2001              MOVS     r0,#1                 ;1097
000a20  e7d2              B        |L1.2504|
                  |L1.2594|
000a22  bf00              NOP                            ;1101
000a24  2000              MOVS     r0,#0                 ;1101
000a26  f8810038          STRB     r0,[r1,#0x38]         ;1101
000a2a  bf00              NOP                            ;1101
000a2c  bf00              NOP                            ;1103
000a2e  e7cb              B        |L1.2504|
;;;1105   
                          ENDP

                  HAL_UART_DMAResume PROC
;;;1111     */
;;;1112   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000a30  b508              PUSH     {r3,lr}
;;;1113   {
000a32  4601              MOV      r1,r0
;;;1114     /* Process Locked */
;;;1115     __HAL_LOCK(huart);
000a34  bf00              NOP      
000a36  f8910038          LDRB     r0,[r1,#0x38]
000a3a  2801              CMP      r0,#1
000a3c  d101              BNE      |L1.2626|
000a3e  2002              MOVS     r0,#2
                  |L1.2624|
;;;1116   
;;;1117     if(huart->State == HAL_UART_STATE_BUSY_TX)
;;;1118     {
;;;1119       /* Enable the UART DMA Tx request */
;;;1120       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1121     }
;;;1122     else if(huart->State == HAL_UART_STATE_BUSY_RX)
;;;1123     {
;;;1124       /* Clear the Overrun flag before resumming the Rx transfer*/
;;;1125       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1126       /* Enable the UART DMA Rx request */
;;;1127       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1128     }
;;;1129     else if(huart->State == HAL_UART_STATE_BUSY_TX_RX)
;;;1130     {
;;;1131       /* Clear the Overrun flag before resumming the Rx transfer*/
;;;1132       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1133       /* Enable the UART DMA Tx & Rx request */
;;;1134       SET_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
;;;1135     }
;;;1136     else
;;;1137     {
;;;1138       /* Process Unlocked */
;;;1139       __HAL_UNLOCK(huart);
;;;1140   
;;;1141       return HAL_ERROR; 
;;;1142     }
;;;1143   
;;;1144     /* Process Unlocked */
;;;1145     __HAL_UNLOCK(huart);
;;;1146   
;;;1147     return HAL_OK;
;;;1148   }
000a40  bd08              POP      {r3,pc}
                  |L1.2626|
000a42  2001              MOVS     r0,#1                 ;1115
000a44  f8810038          STRB     r0,[r1,#0x38]         ;1115
000a48  bf00              NOP                            ;1115
000a4a  f8910039          LDRB     r0,[r1,#0x39]         ;1117
000a4e  2812              CMP      r0,#0x12              ;1117
000a50  d106              BNE      |L1.2656|
000a52  6808              LDR      r0,[r1,#0]            ;1120
000a54  6940              LDR      r0,[r0,#0x14]         ;1120
000a56  f0400080          ORR      r0,r0,#0x80           ;1120
000a5a  680a              LDR      r2,[r1,#0]            ;1120
000a5c  6150              STR      r0,[r2,#0x14]         ;1120
000a5e  e02e              B        |L1.2750|
                  |L1.2656|
000a60  f8910039          LDRB     r0,[r1,#0x39]         ;1122
000a64  2822              CMP      r0,#0x22              ;1122
000a66  d10f              BNE      |L1.2696|
000a68  bf00              NOP                            ;1125
000a6a  6808              LDR      r0,[r1,#0]            ;1125
000a6c  6800              LDR      r0,[r0,#0]            ;1125
000a6e  9000              STR      r0,[sp,#0]            ;1125
000a70  6808              LDR      r0,[r1,#0]            ;1125
000a72  6840              LDR      r0,[r0,#4]            ;1125
000a74  9000              STR      r0,[sp,#0]            ;1125
000a76  bf00              NOP                            ;1125
000a78  bf00              NOP                            ;1125
000a7a  6808              LDR      r0,[r1,#0]            ;1127
000a7c  6940              LDR      r0,[r0,#0x14]         ;1127
000a7e  f0400040          ORR      r0,r0,#0x40           ;1127
000a82  680a              LDR      r2,[r1,#0]            ;1127
000a84  6150              STR      r0,[r2,#0x14]         ;1127
000a86  e01a              B        |L1.2750|
                  |L1.2696|
000a88  f8910039          LDRB     r0,[r1,#0x39]         ;1129
000a8c  2832              CMP      r0,#0x32              ;1129
000a8e  d10f              BNE      |L1.2736|
000a90  bf00              NOP                            ;1132
000a92  6808              LDR      r0,[r1,#0]            ;1132
000a94  6800              LDR      r0,[r0,#0]            ;1132
000a96  9000              STR      r0,[sp,#0]            ;1132
000a98  6808              LDR      r0,[r1,#0]            ;1132
000a9a  6840              LDR      r0,[r0,#4]            ;1132
000a9c  9000              STR      r0,[sp,#0]            ;1132
000a9e  bf00              NOP                            ;1132
000aa0  bf00              NOP                            ;1132
000aa2  6808              LDR      r0,[r1,#0]            ;1134
000aa4  6940              LDR      r0,[r0,#0x14]         ;1134
000aa6  f04000c0          ORR      r0,r0,#0xc0           ;1134
000aaa  680a              LDR      r2,[r1,#0]            ;1134
000aac  6150              STR      r0,[r2,#0x14]         ;1134
000aae  e006              B        |L1.2750|
                  |L1.2736|
000ab0  bf00              NOP                            ;1139
000ab2  2000              MOVS     r0,#0                 ;1139
000ab4  f8810038          STRB     r0,[r1,#0x38]         ;1139
000ab8  bf00              NOP                            ;1139
000aba  2001              MOVS     r0,#1                 ;1141
000abc  e7c0              B        |L1.2624|
                  |L1.2750|
000abe  bf00              NOP                            ;1145
000ac0  2000              MOVS     r0,#0                 ;1145
000ac2  f8810038          STRB     r0,[r1,#0x38]         ;1145
000ac6  bf00              NOP                            ;1145
000ac8  bf00              NOP                            ;1147
000aca  e7b9              B        |L1.2624|
;;;1149   
                          ENDP

                  HAL_UART_DMAStop PROC
;;;1155     */
;;;1156   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000acc  b510              PUSH     {r4,lr}
;;;1157   {
000ace  4604              MOV      r4,r0
;;;1158     /* The Lock is not implemented on this API to allow the user application
;;;1159        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1160        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1161        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1162        */
;;;1163     
;;;1164     /* Disable the UART Tx/Rx DMA requests */
;;;1165     CLEAR_BIT(huart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
000ad0  6820              LDR      r0,[r4,#0]
000ad2  6940              LDR      r0,[r0,#0x14]
000ad4  f02000c0          BIC      r0,r0,#0xc0
000ad8  6821              LDR      r1,[r4,#0]
000ada  6148              STR      r0,[r1,#0x14]
;;;1166     
;;;1167     /* Abort the UART DMA tx channel */
;;;1168     if(huart->hdmatx != NULL)
000adc  6b20              LDR      r0,[r4,#0x30]
000ade  b110              CBZ      r0,|L1.2790|
;;;1169     {
;;;1170       HAL_DMA_Abort(huart->hdmatx);
000ae0  6b20              LDR      r0,[r4,#0x30]
000ae2  f7fffffe          BL       HAL_DMA_Abort
                  |L1.2790|
;;;1171     }
;;;1172     /* Abort the UART DMA rx channel */
;;;1173     if(huart->hdmarx != NULL)
000ae6  6b60              LDR      r0,[r4,#0x34]
000ae8  b110              CBZ      r0,|L1.2800|
;;;1174     {
;;;1175       HAL_DMA_Abort(huart->hdmarx);
000aea  6b60              LDR      r0,[r4,#0x34]
000aec  f7fffffe          BL       HAL_DMA_Abort
                  |L1.2800|
;;;1176     }
;;;1177     
;;;1178     huart->State = HAL_UART_STATE_READY;
000af0  2001              MOVS     r0,#1
000af2  f8840039          STRB     r0,[r4,#0x39]
;;;1179     
;;;1180     return HAL_OK;
000af6  2000              MOVS     r0,#0
;;;1181   }
000af8  bd10              POP      {r4,pc}
;;;1182   
                          ENDP

                  UART_EndTransmit_IT PROC
;;;1771     */
;;;1772   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000afa  b510              PUSH     {r4,lr}
;;;1773   {
000afc  4604              MOV      r4,r0
;;;1774     /* Disable the UART Transmit Complete Interrupt */    
;;;1775     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000afe  6820              LDR      r0,[r4,#0]
000b00  68c0              LDR      r0,[r0,#0xc]
000b02  f0200040          BIC      r0,r0,#0x40
000b06  6821              LDR      r1,[r4,#0]
000b08  60c8              STR      r0,[r1,#0xc]
;;;1776     
;;;1777     /* Check if a receive process is ongoing or not */
;;;1778     if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
000b0a  f8940039          LDRB     r0,[r4,#0x39]
000b0e  2832              CMP      r0,#0x32
000b10  d103              BNE      |L1.2842|
;;;1779     {
;;;1780       huart->State = HAL_UART_STATE_BUSY_RX;
000b12  2022              MOVS     r0,#0x22
000b14  f8840039          STRB     r0,[r4,#0x39]
000b18  e002              B        |L1.2848|
                  |L1.2842|
;;;1781     }
;;;1782     else
;;;1783     {
;;;1784       huart->State = HAL_UART_STATE_READY;
000b1a  2001              MOVS     r0,#1
000b1c  f8840039          STRB     r0,[r4,#0x39]
                  |L1.2848|
;;;1785     }
;;;1786     
;;;1787     HAL_UART_TxCpltCallback(huart);
000b20  4620              MOV      r0,r4
000b22  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;1788     
;;;1789     return HAL_OK;
000b26  2000              MOVS     r0,#0
;;;1790   }
000b28  bd10              POP      {r4,pc}
;;;1791   
                          ENDP

                  UART_Transmit_IT PROC
;;;1722     */
;;;1723   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000b2a  b510              PUSH     {r4,lr}
;;;1724   {
000b2c  4601              MOV      r1,r0
;;;1725     uint16_t* tmp;
;;;1726     uint32_t tmp_state = 0;
000b2e  2300              MOVS     r3,#0
;;;1727     
;;;1728     tmp_state = huart->State;
000b30  f8913039          LDRB     r3,[r1,#0x39]
;;;1729     if((tmp_state == HAL_UART_STATE_BUSY_TX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
000b34  2b12              CMP      r3,#0x12
000b36  d001              BEQ      |L1.2876|
000b38  2b32              CMP      r3,#0x32
000b3a  d12c              BNE      |L1.2966|
                  |L1.2876|
;;;1730     {
;;;1731       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000b3c  6888              LDR      r0,[r1,#8]
000b3e  f5b05f80          CMP      r0,#0x1000
000b42  d10f              BNE      |L1.2916|
;;;1732       {
;;;1733         tmp = (uint16_t*) huart->pTxBuffPtr;
000b44  6a0a              LDR      r2,[r1,#0x20]
;;;1734         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
000b46  8810              LDRH     r0,[r2,#0]
000b48  f3c00008          UBFX     r0,r0,#0,#9
000b4c  680c              LDR      r4,[r1,#0]
000b4e  6060              STR      r0,[r4,#4]
;;;1735         if(huart->Init.Parity == UART_PARITY_NONE)
000b50  6908              LDR      r0,[r1,#0x10]
000b52  b918              CBNZ     r0,|L1.2908|
;;;1736         {
;;;1737           huart->pTxBuffPtr += 2;
000b54  6a08              LDR      r0,[r1,#0x20]
000b56  1c80              ADDS     r0,r0,#2
000b58  6208              STR      r0,[r1,#0x20]
000b5a  e009              B        |L1.2928|
                  |L1.2908|
;;;1738         }
;;;1739         else
;;;1740         {
;;;1741           huart->pTxBuffPtr += 1;
000b5c  6a08              LDR      r0,[r1,#0x20]
000b5e  1c40              ADDS     r0,r0,#1
000b60  6208              STR      r0,[r1,#0x20]
000b62  e005              B        |L1.2928|
                  |L1.2916|
;;;1742         }
;;;1743       } 
;;;1744       else
;;;1745       {
;;;1746         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
000b64  6a0c              LDR      r4,[r1,#0x20]
000b66  1c60              ADDS     r0,r4,#1
000b68  6208              STR      r0,[r1,#0x20]
000b6a  7820              LDRB     r0,[r4,#0]
000b6c  680c              LDR      r4,[r1,#0]
000b6e  6060              STR      r0,[r4,#4]
                  |L1.2928|
;;;1747       }
;;;1748   
;;;1749       if(--huart->TxXferCount == 0)
000b70  8cc8              LDRH     r0,[r1,#0x26]
000b72  1e40              SUBS     r0,r0,#1
000b74  b280              UXTH     r0,r0
000b76  84c8              STRH     r0,[r1,#0x26]
000b78  b958              CBNZ     r0,|L1.2962|
;;;1750       {
;;;1751         /* Disable the UART Transmit Complete Interrupt */
;;;1752         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
000b7a  6808              LDR      r0,[r1,#0]
000b7c  68c0              LDR      r0,[r0,#0xc]
000b7e  f0200080          BIC      r0,r0,#0x80
000b82  680c              LDR      r4,[r1,#0]
000b84  60e0              STR      r0,[r4,#0xc]
;;;1753   
;;;1754         /* Enable the UART Transmit Complete Interrupt */    
;;;1755         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
000b86  6808              LDR      r0,[r1,#0]
000b88  68c0              LDR      r0,[r0,#0xc]
000b8a  f0400040          ORR      r0,r0,#0x40
000b8e  680c              LDR      r4,[r1,#0]
000b90  60e0              STR      r0,[r4,#0xc]
                  |L1.2962|
;;;1756       }
;;;1757       return HAL_OK;
000b92  2000              MOVS     r0,#0
                  |L1.2964|
;;;1758     }
;;;1759     else
;;;1760     {
;;;1761       return HAL_BUSY;
;;;1762     }
;;;1763   }
000b94  bd10              POP      {r4,pc}
                  |L1.2966|
000b96  2002              MOVS     r0,#2                 ;1761
000b98  e7fc              B        |L1.2964|
;;;1764   
                          ENDP

                  UART_Receive_IT PROC
;;;1797     */
;;;1798   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000b9a  b570              PUSH     {r4-r6,lr}
;;;1799   {
000b9c  4604              MOV      r4,r0
;;;1800     uint16_t* tmp;
;;;1801     uint32_t tmp_state = 0;
000b9e  2600              MOVS     r6,#0
;;;1802     
;;;1803     tmp_state = huart->State; 
000ba0  f8946039          LDRB     r6,[r4,#0x39]
;;;1804     if((tmp_state == HAL_UART_STATE_BUSY_RX) || (tmp_state == HAL_UART_STATE_BUSY_TX_RX))
000ba4  2e22              CMP      r6,#0x22
000ba6  d001              BEQ      |L1.2988|
000ba8  2e32              CMP      r6,#0x32
000baa  d152              BNE      |L1.3154|
                  |L1.2988|
;;;1805     {
;;;1806       if(huart->Init.WordLength == UART_WORDLENGTH_9B)
000bac  68a0              LDR      r0,[r4,#8]
000bae  f5b05f80          CMP      r0,#0x1000
000bb2  d113              BNE      |L1.3036|
;;;1807       {
;;;1808         tmp = (uint16_t*) huart->pRxBuffPtr;
000bb4  6aa5              LDR      r5,[r4,#0x28]
;;;1809         if(huart->Init.Parity == UART_PARITY_NONE)
000bb6  6920              LDR      r0,[r4,#0x10]
000bb8  b940              CBNZ     r0,|L1.3020|
;;;1810         {
;;;1811           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
000bba  6820              LDR      r0,[r4,#0]
000bbc  6840              LDR      r0,[r0,#4]
000bbe  f3c00008          UBFX     r0,r0,#0,#9
000bc2  8028              STRH     r0,[r5,#0]
;;;1812           huart->pRxBuffPtr += 2;
000bc4  6aa0              LDR      r0,[r4,#0x28]
000bc6  1c80              ADDS     r0,r0,#2
000bc8  62a0              STR      r0,[r4,#0x28]
000bca  e019              B        |L1.3072|
                  |L1.3020|
;;;1813         }
;;;1814         else
;;;1815         {
;;;1816           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
000bcc  6820              LDR      r0,[r4,#0]
000bce  6840              LDR      r0,[r0,#4]
000bd0  b2c0              UXTB     r0,r0
000bd2  8028              STRH     r0,[r5,#0]
;;;1817           huart->pRxBuffPtr += 1;
000bd4  6aa0              LDR      r0,[r4,#0x28]
000bd6  1c40              ADDS     r0,r0,#1
000bd8  62a0              STR      r0,[r4,#0x28]
000bda  e011              B        |L1.3072|
                  |L1.3036|
;;;1818         }
;;;1819       }
;;;1820       else
;;;1821       {
;;;1822         if(huart->Init.Parity == UART_PARITY_NONE)
000bdc  6920              LDR      r0,[r4,#0x10]
000bde  b938              CBNZ     r0,|L1.3056|
;;;1823         {
;;;1824           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
000be0  6820              LDR      r0,[r4,#0]
000be2  6840              LDR      r0,[r0,#4]
000be4  b2c1              UXTB     r1,r0
000be6  6aa2              LDR      r2,[r4,#0x28]
000be8  1c50              ADDS     r0,r2,#1
000bea  62a0              STR      r0,[r4,#0x28]
000bec  7011              STRB     r1,[r2,#0]
000bee  e007              B        |L1.3072|
                  |L1.3056|
;;;1825         }
;;;1826         else
;;;1827         {
;;;1828           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
000bf0  6820              LDR      r0,[r4,#0]
000bf2  6840              LDR      r0,[r0,#4]
000bf4  f000017f          AND      r1,r0,#0x7f
000bf8  6aa2              LDR      r2,[r4,#0x28]
000bfa  1c50              ADDS     r0,r2,#1
000bfc  62a0              STR      r0,[r4,#0x28]
000bfe  7011              STRB     r1,[r2,#0]
                  |L1.3072|
;;;1829         }
;;;1830       }
;;;1831   
;;;1832       if(--huart->RxXferCount == 0)
000c00  8de0              LDRH     r0,[r4,#0x2e]
000c02  1e40              SUBS     r0,r0,#1
000c04  b280              UXTH     r0,r0
000c06  85e0              STRH     r0,[r4,#0x2e]
000c08  bb08              CBNZ     r0,|L1.3150|
;;;1833       {
;;;1834         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
000c0a  6820              LDR      r0,[r4,#0]
000c0c  68c0              LDR      r0,[r0,#0xc]
000c0e  f0200020          BIC      r0,r0,#0x20
000c12  6821              LDR      r1,[r4,#0]
000c14  60c8              STR      r0,[r1,#0xc]
;;;1835   
;;;1836         /* Check if a transmit process is ongoing or not */
;;;1837         if(huart->State == HAL_UART_STATE_BUSY_TX_RX) 
000c16  f8940039          LDRB     r0,[r4,#0x39]
000c1a  2832              CMP      r0,#0x32
000c1c  d103              BNE      |L1.3110|
;;;1838         {
;;;1839           huart->State = HAL_UART_STATE_BUSY_TX;
000c1e  2012              MOVS     r0,#0x12
000c20  f8840039          STRB     r0,[r4,#0x39]
000c24  e00e              B        |L1.3140|
                  |L1.3110|
;;;1840         }
;;;1841         else
;;;1842         {
;;;1843           /* Disable the UART Parity Error Interrupt */
;;;1844           __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
000c26  6820              LDR      r0,[r4,#0]
000c28  68c0              LDR      r0,[r0,#0xc]
000c2a  f4207080          BIC      r0,r0,#0x100
000c2e  6821              LDR      r1,[r4,#0]
000c30  60c8              STR      r0,[r1,#0xc]
;;;1845   
;;;1846           /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1847           __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
000c32  6820              LDR      r0,[r4,#0]
000c34  6940              LDR      r0,[r0,#0x14]
000c36  f0200001          BIC      r0,r0,#1
000c3a  6821              LDR      r1,[r4,#0]
000c3c  6148              STR      r0,[r1,#0x14]
;;;1848   
;;;1849           huart->State = HAL_UART_STATE_READY;
000c3e  2001              MOVS     r0,#1
000c40  f8840039          STRB     r0,[r4,#0x39]
                  |L1.3140|
;;;1850         }
;;;1851         HAL_UART_RxCpltCallback(huart);
000c44  4620              MOV      r0,r4
000c46  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;1852   
;;;1853         return HAL_OK;
000c4a  2000              MOVS     r0,#0
                  |L1.3148|
;;;1854       }
;;;1855       return HAL_OK;
;;;1856     }
;;;1857     else
;;;1858     {
;;;1859       return HAL_BUSY; 
;;;1860     }
;;;1861   }
000c4c  bd70              POP      {r4-r6,pc}
                  |L1.3150|
000c4e  2000              MOVS     r0,#0                 ;1855
000c50  e7fc              B        |L1.3148|
                  |L1.3154|
000c52  2002              MOVS     r0,#2                 ;1859
000c54  e7fa              B        |L1.3148|
;;;1862   
                          ENDP

                  HAL_UART_IRQHandler PROC
;;;1188     */
;;;1189   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000c56  b5f8              PUSH     {r3-r7,lr}
;;;1190   {
000c58  4604              MOV      r4,r0
;;;1191     uint32_t tmp_flag = 0, tmp_it_source = 0;
000c5a  2500              MOVS     r5,#0
000c5c  2600              MOVS     r6,#0
;;;1192   
;;;1193     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_PE);
000c5e  6820              LDR      r0,[r4,#0]
000c60  6800              LDR      r0,[r0,#0]
000c62  f0000501          AND      r5,r0,#1
;;;1194     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_PE);  
000c66  6820              LDR      r0,[r4,#0]
000c68  68c0              LDR      r0,[r0,#0xc]
000c6a  f4007680          AND      r6,r0,#0x100
;;;1195     /* UART parity error interrupt occurred ------------------------------------*/
;;;1196     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000c6e  b125              CBZ      r5,|L1.3194|
000c70  b11e              CBZ      r6,|L1.3194|
;;;1197     { 
;;;1198       huart->ErrorCode |= HAL_UART_ERROR_PE;
000c72  6be0              LDR      r0,[r4,#0x3c]
000c74  f0400001          ORR      r0,r0,#1
000c78  63e0              STR      r0,[r4,#0x3c]
                  |L1.3194|
;;;1199     }
;;;1200     
;;;1201     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_FE);
000c7a  6820              LDR      r0,[r4,#0]
000c7c  6800              LDR      r0,[r0,#0]
000c7e  f3c00540          UBFX     r5,r0,#1,#1
;;;1202     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_ERR);
000c82  6820              LDR      r0,[r4,#0]
000c84  6940              LDR      r0,[r0,#0x14]
000c86  f0000601          AND      r6,r0,#1
;;;1203     /* UART frame error interrupt occurred -------------------------------------*/
;;;1204     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000c8a  e009              B        |L1.3232|
                  |L1.3212|
                          DCD      UART_DMATransmitCplt
                  |L1.3216|
                          DCD      UART_DMATxHalfCplt
                  |L1.3220|
                          DCD      UART_DMAError
                  |L1.3224|
                          DCD      UART_DMAReceiveCplt
                  |L1.3228|
                          DCD      UART_DMARxHalfCplt
                  |L1.3232|
000ca0  b125              CBZ      r5,|L1.3244|
000ca2  b11e              CBZ      r6,|L1.3244|
;;;1205     { 
;;;1206       huart->ErrorCode |= HAL_UART_ERROR_FE;
000ca4  6be0              LDR      r0,[r4,#0x3c]
000ca6  f0400004          ORR      r0,r0,#4
000caa  63e0              STR      r0,[r4,#0x3c]
                  |L1.3244|
;;;1207     }
;;;1208     
;;;1209     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_NE);
000cac  6820              LDR      r0,[r4,#0]
000cae  6800              LDR      r0,[r0,#0]
000cb0  f3c00580          UBFX     r5,r0,#2,#1
;;;1210     /* UART noise error interrupt occurred -------------------------------------*/
;;;1211     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000cb4  b125              CBZ      r5,|L1.3264|
000cb6  b11e              CBZ      r6,|L1.3264|
;;;1212     { 
;;;1213       huart->ErrorCode |= HAL_UART_ERROR_NE;
000cb8  6be0              LDR      r0,[r4,#0x3c]
000cba  f0400002          ORR      r0,r0,#2
000cbe  63e0              STR      r0,[r4,#0x3c]
                  |L1.3264|
;;;1214     }
;;;1215     
;;;1216     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_ORE);
000cc0  6820              LDR      r0,[r4,#0]
000cc2  6800              LDR      r0,[r0,#0]
000cc4  f3c005c0          UBFX     r5,r0,#3,#1
;;;1217     /* UART Over-Run interrupt occurred ----------------------------------------*/
;;;1218     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000cc8  b125              CBZ      r5,|L1.3284|
000cca  b11e              CBZ      r6,|L1.3284|
;;;1219     { 
;;;1220       huart->ErrorCode |= HAL_UART_ERROR_ORE;
000ccc  6be0              LDR      r0,[r4,#0x3c]
000cce  f0400008          ORR      r0,r0,#8
000cd2  63e0              STR      r0,[r4,#0x3c]
                  |L1.3284|
;;;1221     }
;;;1222     
;;;1223     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
000cd4  6820              LDR      r0,[r4,#0]
000cd6  6800              LDR      r0,[r0,#0]
000cd8  f3c01540          UBFX     r5,r0,#5,#1
;;;1224     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
000cdc  6820              LDR      r0,[r4,#0]
000cde  68c0              LDR      r0,[r0,#0xc]
000ce0  f0000620          AND      r6,r0,#0x20
;;;1225     /* UART in mode Receiver ---------------------------------------------------*/
;;;1226     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000ce4  b11d              CBZ      r5,|L1.3310|
000ce6  b116              CBZ      r6,|L1.3310|
;;;1227     { 
;;;1228       UART_Receive_IT(huart);
000ce8  4620              MOV      r0,r4
000cea  f7fffffe          BL       UART_Receive_IT
                  |L1.3310|
;;;1229     }
;;;1230     
;;;1231     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TXE);
000cee  6820              LDR      r0,[r4,#0]
000cf0  6800              LDR      r0,[r0,#0]
000cf2  f3c015c0          UBFX     r5,r0,#7,#1
;;;1232     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TXE);
000cf6  6820              LDR      r0,[r4,#0]
000cf8  68c0              LDR      r0,[r0,#0xc]
000cfa  f0000680          AND      r6,r0,#0x80
;;;1233     /* UART in mode Transmitter ------------------------------------------------*/
;;;1234     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000cfe  b11d              CBZ      r5,|L1.3336|
000d00  b116              CBZ      r6,|L1.3336|
;;;1235     {
;;;1236       UART_Transmit_IT(huart);
000d02  4620              MOV      r0,r4
000d04  f7fffffe          BL       UART_Transmit_IT
                  |L1.3336|
;;;1237     }
;;;1238   
;;;1239     tmp_flag = __HAL_UART_GET_FLAG(huart, UART_FLAG_TC);
000d08  6820              LDR      r0,[r4,#0]
000d0a  6800              LDR      r0,[r0,#0]
000d0c  f3c01580          UBFX     r5,r0,#6,#1
;;;1240     tmp_it_source = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_TC);
000d10  6820              LDR      r0,[r4,#0]
000d12  68c0              LDR      r0,[r0,#0xc]
000d14  f0000640          AND      r6,r0,#0x40
;;;1241     /* UART in mode Transmitter end --------------------------------------------*/
;;;1242     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000d18  b11d              CBZ      r5,|L1.3362|
000d1a  b116              CBZ      r6,|L1.3362|
;;;1243     {
;;;1244       UART_EndTransmit_IT(huart);
000d1c  4620              MOV      r0,r4
000d1e  f7fffffe          BL       UART_EndTransmit_IT
                  |L1.3362|
;;;1245     }  
;;;1246   
;;;1247     if(huart->ErrorCode != HAL_UART_ERROR_NONE)
000d22  6be0              LDR      r0,[r4,#0x3c]
000d24  b170              CBZ      r0,|L1.3396|
;;;1248     {
;;;1249       /* Clear all the error flag at once */
;;;1250       __HAL_UART_CLEAR_PEFLAG(huart);
000d26  bf00              NOP      
000d28  6820              LDR      r0,[r4,#0]
000d2a  6800              LDR      r0,[r0,#0]
000d2c  9000              STR      r0,[sp,#0]
000d2e  6820              LDR      r0,[r4,#0]
000d30  6840              LDR      r0,[r0,#4]
000d32  9000              STR      r0,[sp,#0]
000d34  bf00              NOP      
000d36  bf00              NOP      
;;;1251       
;;;1252       /* Set the UART state ready to be able to start again the process */
;;;1253       huart->State = HAL_UART_STATE_READY;
000d38  2001              MOVS     r0,#1
000d3a  f8840039          STRB     r0,[r4,#0x39]
;;;1254       
;;;1255       HAL_UART_ErrorCallback(huart);
000d3e  4620              MOV      r0,r4
000d40  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L1.3396|
;;;1256     }  
;;;1257   }
000d44  bdf8              POP      {r3-r7,pc}
;;;1258   
                          ENDP

                  HAL_LIN_SendBreak PROC
;;;1362     */
;;;1363   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000d46  4601              MOV      r1,r0
;;;1364   {
;;;1365     /* Check the parameters */
;;;1366     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1367     
;;;1368     /* Process Locked */
;;;1369     __HAL_LOCK(huart);
000d48  bf00              NOP      
000d4a  f8910038          LDRB     r0,[r1,#0x38]
000d4e  2801              CMP      r0,#1
000d50  d101              BNE      |L1.3414|
000d52  2002              MOVS     r0,#2
                  |L1.3412|
;;;1370     
;;;1371     huart->State = HAL_UART_STATE_BUSY;
;;;1372     
;;;1373     /* Send break characters */
;;;1374     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
;;;1375    
;;;1376     huart->State = HAL_UART_STATE_READY;
;;;1377     
;;;1378     /* Process Unlocked */
;;;1379     __HAL_UNLOCK(huart);
;;;1380     
;;;1381     return HAL_OK; 
;;;1382   }
000d54  4770              BX       lr
                  |L1.3414|
000d56  2001              MOVS     r0,#1                 ;1369
000d58  f8810038          STRB     r0,[r1,#0x38]         ;1369
000d5c  bf00              NOP                            ;1369
000d5e  2002              MOVS     r0,#2                 ;1371
000d60  f8810039          STRB     r0,[r1,#0x39]         ;1371
000d64  6808              LDR      r0,[r1,#0]            ;1374
000d66  68c0              LDR      r0,[r0,#0xc]          ;1374
000d68  f0400001          ORR      r0,r0,#1              ;1374
000d6c  680a              LDR      r2,[r1,#0]            ;1374
000d6e  60d0              STR      r0,[r2,#0xc]          ;1374
000d70  2001              MOVS     r0,#1                 ;1376
000d72  f8810039          STRB     r0,[r1,#0x39]         ;1376
000d76  bf00              NOP                            ;1379
000d78  2000              MOVS     r0,#0                 ;1379
000d7a  f8810038          STRB     r0,[r1,#0x38]         ;1379
000d7e  bf00              NOP                            ;1379
000d80  bf00              NOP                            ;1381
000d82  e7e7              B        |L1.3412|
;;;1383   
                          ENDP

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;1389     */
;;;1390   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000d84  4601              MOV      r1,r0
;;;1391   {
;;;1392     /* Check the parameters */
;;;1393     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1394     
;;;1395     /* Process Locked */
;;;1396     __HAL_LOCK(huart);
000d86  bf00              NOP      
000d88  f8910038          LDRB     r0,[r1,#0x38]
000d8c  2801              CMP      r0,#1
000d8e  d101              BNE      |L1.3476|
000d90  2002              MOVS     r0,#2
                  |L1.3474|
;;;1397     
;;;1398     huart->State = HAL_UART_STATE_BUSY;
;;;1399     
;;;1400     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;1401     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1402     
;;;1403     huart->State = HAL_UART_STATE_READY;
;;;1404     
;;;1405     /* Process Unlocked */
;;;1406     __HAL_UNLOCK(huart);
;;;1407     
;;;1408     return HAL_OK; 
;;;1409   }
000d92  4770              BX       lr
                  |L1.3476|
000d94  2001              MOVS     r0,#1                 ;1396
000d96  f8810038          STRB     r0,[r1,#0x38]         ;1396
000d9a  bf00              NOP                            ;1396
000d9c  2002              MOVS     r0,#2                 ;1398
000d9e  f8810039          STRB     r0,[r1,#0x39]         ;1398
000da2  6808              LDR      r0,[r1,#0]            ;1401
000da4  68c0              LDR      r0,[r0,#0xc]          ;1401
000da6  f0400002          ORR      r0,r0,#2              ;1401
000daa  680a              LDR      r2,[r1,#0]            ;1401
000dac  60d0              STR      r0,[r2,#0xc]          ;1401
000dae  2001              MOVS     r0,#1                 ;1403
000db0  f8810039          STRB     r0,[r1,#0x39]         ;1403
000db4  bf00              NOP                            ;1406
000db6  2000              MOVS     r0,#0                 ;1406
000db8  f8810038          STRB     r0,[r1,#0x38]         ;1406
000dbc  bf00              NOP                            ;1406
000dbe  bf00              NOP                            ;1408
000dc0  e7e7              B        |L1.3474|
;;;1410   
                          ENDP

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;1416     */
;;;1417   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000dc2  4601              MOV      r1,r0
;;;1418   {
;;;1419     /* Check the parameters */
;;;1420     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;1421     
;;;1422     /* Process Locked */
;;;1423     __HAL_LOCK(huart);
000dc4  bf00              NOP      
000dc6  f8910038          LDRB     r0,[r1,#0x38]
000dca  2801              CMP      r0,#1
000dcc  d101              BNE      |L1.3538|
000dce  2002              MOVS     r0,#2
                  |L1.3536|
;;;1424     
;;;1425     huart->State = HAL_UART_STATE_BUSY;
;;;1426     
;;;1427     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;1428     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
;;;1429     
;;;1430     huart->State = HAL_UART_STATE_READY;
;;;1431     
;;;1432     /* Process Unlocked */
;;;1433     __HAL_UNLOCK(huart);
;;;1434     
;;;1435     return HAL_OK; 
;;;1436   }
000dd0  4770              BX       lr
                  |L1.3538|
000dd2  2001              MOVS     r0,#1                 ;1423
000dd4  f8810038          STRB     r0,[r1,#0x38]         ;1423
000dd8  bf00              NOP                            ;1423
000dda  2002              MOVS     r0,#2                 ;1425
000ddc  f8810039          STRB     r0,[r1,#0x39]         ;1425
000de0  6808              LDR      r0,[r1,#0]            ;1428
000de2  68c0              LDR      r0,[r0,#0xc]          ;1428
000de4  f0200002          BIC      r0,r0,#2              ;1428
000de8  680a              LDR      r2,[r1,#0]            ;1428
000dea  60d0              STR      r0,[r2,#0xc]          ;1428
000dec  2001              MOVS     r0,#1                 ;1430
000dee  f8810039          STRB     r0,[r1,#0x39]         ;1430
000df2  bf00              NOP                            ;1433
000df4  2000              MOVS     r0,#0                 ;1433
000df6  f8810038          STRB     r0,[r1,#0x38]         ;1433
000dfa  bf00              NOP                            ;1433
000dfc  bf00              NOP                            ;1435
000dfe  e7e7              B        |L1.3536|
;;;1437   
                          ENDP

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;1443     */
;;;1444   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000e00  4601              MOV      r1,r0
;;;1445   {
;;;1446     /* Process Locked */
;;;1447     __HAL_LOCK(huart);
000e02  bf00              NOP      
000e04  f8910038          LDRB     r0,[r1,#0x38]
000e08  2801              CMP      r0,#1
000e0a  d101              BNE      |L1.3600|
000e0c  2002              MOVS     r0,#2
                  |L1.3598|
;;;1448     
;;;1449     huart->State = HAL_UART_STATE_BUSY;
;;;1450   
;;;1451     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1452     /* Clear TE and RE bits */
;;;1453     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;1454     MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_TE);
;;;1455    
;;;1456     huart->State = HAL_UART_STATE_READY;
;;;1457     
;;;1458     /* Process Unlocked */
;;;1459     __HAL_UNLOCK(huart);
;;;1460     
;;;1461     return HAL_OK; 
;;;1462   }
000e0e  4770              BX       lr
                  |L1.3600|
000e10  2001              MOVS     r0,#1                 ;1447
000e12  f8810038          STRB     r0,[r1,#0x38]         ;1447
000e16  bf00              NOP                            ;1447
000e18  2002              MOVS     r0,#2                 ;1449
000e1a  f8810039          STRB     r0,[r1,#0x39]         ;1449
000e1e  6808              LDR      r0,[r1,#0]            ;1454
000e20  68c0              LDR      r0,[r0,#0xc]          ;1454
000e22  f020000c          BIC      r0,r0,#0xc            ;1454
000e26  f0400008          ORR      r0,r0,#8              ;1454
000e2a  680a              LDR      r2,[r1,#0]            ;1454
000e2c  60d0              STR      r0,[r2,#0xc]          ;1454
000e2e  2001              MOVS     r0,#1                 ;1456
000e30  f8810039          STRB     r0,[r1,#0x39]         ;1456
000e34  bf00              NOP                            ;1459
000e36  2000              MOVS     r0,#0                 ;1459
000e38  f8810038          STRB     r0,[r1,#0x38]         ;1459
000e3c  bf00              NOP                            ;1459
000e3e  bf00              NOP                            ;1461
000e40  e7e5              B        |L1.3598|
;;;1463   
                          ENDP

                  HAL_HalfDuplex_EnableReceiver PROC
;;;1469     */
;;;1470   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000e42  4601              MOV      r1,r0
;;;1471   {
;;;1472     /* Process Locked */
;;;1473     __HAL_LOCK(huart);
000e44  bf00              NOP      
000e46  f8910038          LDRB     r0,[r1,#0x38]
000e4a  2801              CMP      r0,#1
000e4c  d101              BNE      |L1.3666|
000e4e  2002              MOVS     r0,#2
                  |L1.3664|
;;;1474     
;;;1475     huart->State = HAL_UART_STATE_BUSY;
;;;1476   
;;;1477     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1478     /* Clear TE and RE bits */
;;;1479     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;1480     MODIFY_REG(huart->Instance->CR1, (uint32_t)(USART_CR1_TE | USART_CR1_RE), USART_CR1_RE);
;;;1481     
;;;1482     huart->State = HAL_UART_STATE_READY;
;;;1483     
;;;1484     /* Process Unlocked */
;;;1485     __HAL_UNLOCK(huart);
;;;1486     
;;;1487     return HAL_OK; 
;;;1488   }
000e50  4770              BX       lr
                  |L1.3666|
000e52  2001              MOVS     r0,#1                 ;1473
000e54  f8810038          STRB     r0,[r1,#0x38]         ;1473
000e58  bf00              NOP                            ;1473
000e5a  2002              MOVS     r0,#2                 ;1475
000e5c  f8810039          STRB     r0,[r1,#0x39]         ;1475
000e60  6808              LDR      r0,[r1,#0]            ;1480
000e62  68c0              LDR      r0,[r0,#0xc]          ;1480
000e64  f020000c          BIC      r0,r0,#0xc            ;1480
000e68  1d00              ADDS     r0,r0,#4              ;1480
000e6a  680a              LDR      r2,[r1,#0]            ;1480
000e6c  60d0              STR      r0,[r2,#0xc]          ;1480
000e6e  2001              MOVS     r0,#1                 ;1482
000e70  f8810039          STRB     r0,[r1,#0x39]         ;1482
000e74  bf00              NOP                            ;1485
000e76  2000              MOVS     r0,#0                 ;1485
000e78  f8810038          STRB     r0,[r1,#0x38]         ;1485
000e7c  bf00              NOP                            ;1485
000e7e  bf00              NOP                            ;1487
000e80  e7e6              B        |L1.3664|
;;;1489   
                          ENDP

                  HAL_UART_GetState PROC
;;;1517     */
;;;1518   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000e82  4601              MOV      r1,r0
;;;1519   {
;;;1520     return huart->State;
000e84  f8910039          LDRB     r0,[r1,#0x39]
;;;1521   }
000e88  4770              BX       lr
;;;1522   
                          ENDP

                  HAL_UART_GetError PROC
;;;1528   */
;;;1529   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000e8a  4601              MOV      r1,r0
;;;1530   {
;;;1531     return huart->ErrorCode;
000e8c  6bc8              LDR      r0,[r1,#0x3c]
;;;1532   }
000e8e  4770              BX       lr
;;;1533   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 402
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 587
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
