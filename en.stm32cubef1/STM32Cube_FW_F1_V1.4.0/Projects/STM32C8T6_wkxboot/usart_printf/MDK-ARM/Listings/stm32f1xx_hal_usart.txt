; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\stm32f1xx_hal_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Inc -I..\..\..\..\Drivers\CMSIS\Include -I..\..\..\..\Drivers\CMSIS\Device\ST\STM32F1xx\Include -I..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Inc -ID:\development\arm_ucos3\src_code\en.stm32cubef1\STM32Cube_FW_F1_V1.4.0\Projects\STM32C8T6_wkxboot\usart_printf\MDK-ARM\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM3\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -DARMCM3 -DUSE_STM32F103_WKXBOOT -DSTM32F101xB --omf_browse=.\objects\stm32f1xx_hal_usart.crf ..\..\..\..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  USART_SetConfig PROC
;;;1828     */
;;;1829   static void USART_SetConfig(USART_HandleTypeDef *husart)
000000  b570              PUSH     {r4-r6,lr}
;;;1830   {
000002  4604              MOV      r4,r0
;;;1831     /* Check the parameters */
;;;1832     assert_param(IS_USART_POLARITY(husart->Init.CLKPolarity));
;;;1833     assert_param(IS_USART_PHASE(husart->Init.CLKPhase));
;;;1834     assert_param(IS_USART_LASTBIT(husart->Init.CLKLastBit));
;;;1835     assert_param(IS_USART_BAUDRATE(husart->Init.BaudRate));  
;;;1836     assert_param(IS_USART_WORD_LENGTH(husart->Init.WordLength));
;;;1837     assert_param(IS_USART_STOPBITS(husart->Init.StopBits));
;;;1838     assert_param(IS_USART_PARITY(husart->Init.Parity));
;;;1839     assert_param(IS_USART_MODE(husart->Init.Mode));
;;;1840   
;;;1841     /* The LBCL, CPOL and CPHA bits have to be selected when both the transmitter and the
;;;1842        receiver are disabled (TE=RE=0) to ensure that the clock pulses function correctly. */
;;;1843     CLEAR_BIT(husart->Instance->CR1, ((uint32_t)(USART_CR1_TE | USART_CR1_RE)));
000004  6820              LDR      r0,[r4,#0]
000006  68c0              LDR      r0,[r0,#0xc]
000008  f020000c          BIC      r0,r0,#0xc
00000c  6821              LDR      r1,[r4,#0]
00000e  60c8              STR      r0,[r1,#0xc]
;;;1844   
;;;1845     /*---------------------------- USART CR2 Configuration ---------------------*/
;;;1846     /* Configure the USART Clock, CPOL, CPHA and LastBit -----------------------*/
;;;1847     /* Set CPOL bit according to husart->Init.CLKPolarity value */
;;;1848     /* Set CPHA bit according to husart->Init.CLKPhase value */
;;;1849     /* Set LBCL bit according to husart->Init.CLKLastBit value */
;;;1850     /* Set Stop Bits: Set STOP[13:12] bits according to husart->Init.StopBits value */
;;;1851     /* Write to USART CR2 */
;;;1852     MODIFY_REG(husart->Instance->CR2, 
000010  69a0              LDR      r0,[r4,#0x18]
000012  f4406000          ORR      r0,r0,#0x800
000016  69e1              LDR      r1,[r4,#0x1c]
000018  4308              ORRS     r0,r0,r1
00001a  6a21              LDR      r1,[r4,#0x20]
00001c  4308              ORRS     r0,r0,r1
00001e  68e1              LDR      r1,[r4,#0xc]
000020  4308              ORRS     r0,r0,r1
000022  6821              LDR      r1,[r4,#0]
000024  6909              LDR      r1,[r1,#0x10]
000026  f421517c          BIC      r1,r1,#0x3f00
00002a  4308              ORRS     r0,r0,r1
00002c  6821              LDR      r1,[r4,#0]
00002e  6108              STR      r0,[r1,#0x10]
;;;1853                (uint32_t)(USART_CR2_CPHA | USART_CR2_CPOL | USART_CR2_CLKEN | USART_CR2_LBCL | USART_CR2_STOP),
;;;1854                ((uint32_t)(USART_CLOCK_ENABLE| husart->Init.CLKPolarity | husart->Init.CLKPhase| husart->Init.CLKLastBit | husart->Init.StopBits)));
;;;1855   
;;;1856     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;1857     /* Configure the USART Word Length, Parity and mode: 
;;;1858        Set the M bits according to husart->Init.WordLength value 
;;;1859        Set PCE and PS bits according to husart->Init.Parity value
;;;1860        Set TE and RE bits according to husart->Init.Mode value */
;;;1861     MODIFY_REG(husart->Instance->CR1, 
000030  6921              LDR      r1,[r4,#0x10]
000032  68a0              LDR      r0,[r4,#8]
000034  4308              ORRS     r0,r0,r1
000036  6961              LDR      r1,[r4,#0x14]
000038  4308              ORRS     r0,r0,r1
00003a  6821              LDR      r1,[r4,#0]
00003c  68c9              LDR      r1,[r1,#0xc]
00003e  f241620c          MOV      r2,#0x160c
000042  4391              BICS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  6821              LDR      r1,[r4,#0]
000048  60c8              STR      r0,[r1,#0xc]
;;;1862                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
;;;1863                (uint32_t)husart->Init.WordLength | husart->Init.Parity | husart->Init.Mode);
;;;1864   
;;;1865     /*-------------------------- USART CR3 Configuration -----------------------*/  
;;;1866     /* Clear CTSE and RTSE bits */
;;;1867     CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
00004a  6820              LDR      r0,[r4,#0]
00004c  6940              LDR      r0,[r0,#0x14]
00004e  f4207040          BIC      r0,r0,#0x300
000052  6821              LDR      r1,[r4,#0]
000054  6148              STR      r0,[r1,#0x14]
;;;1868   
;;;1869     /*-------------------------- USART BRR Configuration -----------------------*/
;;;1870     if((husart->Instance == USART1))
000056  49f9              LDR      r1,|L1.1084|
000058  6820              LDR      r0,[r4,#0]
00005a  4288              CMP      r0,r1
00005c  d134              BNE      |L1.200|
;;;1871     {
;;;1872       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK2Freq(), husart->Init.BaudRate);
00005e  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000062  eb0001c0          ADD      r1,r0,r0,LSL #3
000066  eb011000          ADD      r0,r1,r0,LSL #4
00006a  6861              LDR      r1,[r4,#4]
00006c  0089              LSLS     r1,r1,#2
00006e  fbb0f0f1          UDIV     r0,r0,r1
000072  2164              MOVS     r1,#0x64
000074  fbb0f5f1          UDIV     r5,r0,r1
000078  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00007c  eb0001c0          ADD      r1,r0,r0,LSL #3
000080  eb011000          ADD      r0,r1,r0,LSL #4
000084  6861              LDR      r1,[r4,#4]
000086  0089              LSLS     r1,r1,#2
000088  fbb0f6f1          UDIV     r6,r0,r1
00008c  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000090  eb0001c0          ADD      r1,r0,r0,LSL #3
000094  eb011000          ADD      r0,r1,r0,LSL #4
000098  6861              LDR      r1,[r4,#4]
00009a  0089              LSLS     r1,r1,#2
00009c  fbb0f0f1          UDIV     r0,r0,r1
0000a0  2164              MOVS     r1,#0x64
0000a2  fbb0f0f1          UDIV     r0,r0,r1
0000a6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000aa  eb011000          ADD      r0,r1,r0,LSL #4
0000ae  eba60080          SUB      r0,r6,r0,LSL #2
0000b2  2132              MOVS     r1,#0x32
0000b4  eb011000          ADD      r0,r1,r0,LSL #4
0000b8  2164              MOVS     r1,#0x64
0000ba  fbb0f0f1          UDIV     r0,r0,r1
0000be  f365101f          BFI      r0,r5,#4,#28
0000c2  6821              LDR      r1,[r4,#0]
0000c4  6088              STR      r0,[r1,#8]
0000c6  e033              B        |L1.304|
                  |L1.200|
;;;1873     }
;;;1874     else
;;;1875     {
;;;1876       husart->Instance->BRR = USART_BRR(HAL_RCC_GetPCLK1Freq(), husart->Init.BaudRate);
0000c8  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000cc  eb0001c0          ADD      r1,r0,r0,LSL #3
0000d0  eb011000          ADD      r0,r1,r0,LSL #4
0000d4  6861              LDR      r1,[r4,#4]
0000d6  0089              LSLS     r1,r1,#2
0000d8  fbb0f0f1          UDIV     r0,r0,r1
0000dc  2164              MOVS     r1,#0x64
0000de  fbb0f5f1          UDIV     r5,r0,r1
0000e2  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000e6  eb0001c0          ADD      r1,r0,r0,LSL #3
0000ea  eb011000          ADD      r0,r1,r0,LSL #4
0000ee  6861              LDR      r1,[r4,#4]
0000f0  0089              LSLS     r1,r1,#2
0000f2  fbb0f6f1          UDIV     r6,r0,r1
0000f6  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000fa  eb0001c0          ADD      r1,r0,r0,LSL #3
0000fe  eb011000          ADD      r0,r1,r0,LSL #4
000102  6861              LDR      r1,[r4,#4]
000104  0089              LSLS     r1,r1,#2
000106  fbb0f0f1          UDIV     r0,r0,r1
00010a  2164              MOVS     r1,#0x64
00010c  fbb0f0f1          UDIV     r0,r0,r1
000110  eb0001c0          ADD      r1,r0,r0,LSL #3
000114  eb011000          ADD      r0,r1,r0,LSL #4
000118  eba60080          SUB      r0,r6,r0,LSL #2
00011c  2132              MOVS     r1,#0x32
00011e  eb011000          ADD      r0,r1,r0,LSL #4
000122  2164              MOVS     r1,#0x64
000124  fbb0f0f1          UDIV     r0,r0,r1
000128  f365101f          BFI      r0,r5,#4,#28
00012c  6821              LDR      r1,[r4,#0]
00012e  6088              STR      r0,[r1,#8]
                  |L1.304|
;;;1877     }
;;;1878   }
000130  bd70              POP      {r4-r6,pc}
;;;1879   
                          ENDP

                  HAL_USART_MspInit PROC
;;;323      */
;;;324     __weak void HAL_USART_MspInit(USART_HandleTypeDef *husart)
000132  4770              BX       lr
;;;325    {
;;;326      /* Prevent unused argument(s) compilation warning */
;;;327      UNUSED(husart);
;;;328      /* NOTE: This function should not be modified, when the callback is needed,
;;;329               the HAL_USART_MspInit can be implemented in the user file
;;;330       */ 
;;;331    }
;;;332    
                          ENDP

                  HAL_USART_Init PROC
;;;242      */
;;;243    HAL_StatusTypeDef HAL_USART_Init(USART_HandleTypeDef *husart)
000134  b510              PUSH     {r4,lr}
;;;244    {
000136  4604              MOV      r4,r0
;;;245      /* Check the USART handle allocation */
;;;246      if(husart == NULL)
000138  b90c              CBNZ     r4,|L1.318|
;;;247      {
;;;248        return HAL_ERROR;
00013a  2001              MOVS     r0,#1
                  |L1.316|
;;;249      }
;;;250    
;;;251      /* Check the parameters */
;;;252      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;253    
;;;254      if(husart->State == HAL_USART_STATE_RESET)
;;;255      {
;;;256        /* Allocate lock resource and initialize it */
;;;257        husart->Lock = HAL_UNLOCKED;
;;;258        
;;;259        /* Init the low level hardware */
;;;260        HAL_USART_MspInit(husart);
;;;261      }
;;;262      
;;;263      husart->State = HAL_USART_STATE_BUSY;
;;;264    
;;;265      /* Set the USART Communication parameters */
;;;266      USART_SetConfig(husart);
;;;267    
;;;268      /* In USART mode, the following bits must be kept cleared: 
;;;269         - LINEN bit in the USART_CR2 register
;;;270         - HDSEL, SCEN and IREN bits in the USART_CR3 register */
;;;271      CLEAR_BIT(husart->Instance->CR2, USART_CR2_LINEN);
;;;272      CLEAR_BIT(husart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN | USART_CR3_HDSEL));
;;;273    
;;;274      /* Enable the Peripheral */
;;;275      __HAL_USART_ENABLE(husart);
;;;276    
;;;277      /* Initialize the USART state */
;;;278      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;279      husart->State= HAL_USART_STATE_READY;
;;;280    
;;;281      return HAL_OK;
;;;282    }
00013c  bd10              POP      {r4,pc}
                  |L1.318|
00013e  f894003d          LDRB     r0,[r4,#0x3d]         ;254
000142  b928              CBNZ     r0,|L1.336|
000144  2000              MOVS     r0,#0                 ;257
000146  f884003c          STRB     r0,[r4,#0x3c]         ;257
00014a  4620              MOV      r0,r4                 ;260
00014c  f7fffffe          BL       HAL_USART_MspInit
                  |L1.336|
000150  2002              MOVS     r0,#2                 ;263
000152  f884003d          STRB     r0,[r4,#0x3d]         ;263
000156  4620              MOV      r0,r4                 ;266
000158  f7fffffe          BL       USART_SetConfig
00015c  6820              LDR      r0,[r4,#0]            ;271
00015e  6900              LDR      r0,[r0,#0x10]         ;271
000160  f4204080          BIC      r0,r0,#0x4000         ;271
000164  6821              LDR      r1,[r4,#0]            ;271
000166  6108              STR      r0,[r1,#0x10]         ;271
000168  6820              LDR      r0,[r4,#0]            ;272
00016a  6940              LDR      r0,[r0,#0x14]         ;272
00016c  f020002a          BIC      r0,r0,#0x2a           ;272
000170  6821              LDR      r1,[r4,#0]            ;272
000172  6148              STR      r0,[r1,#0x14]         ;272
000174  6820              LDR      r0,[r4,#0]            ;275
000176  68c0              LDR      r0,[r0,#0xc]          ;275
000178  f4405000          ORR      r0,r0,#0x2000         ;275
00017c  6821              LDR      r1,[r4,#0]            ;275
00017e  60c8              STR      r0,[r1,#0xc]          ;275
000180  2000              MOVS     r0,#0                 ;278
000182  6420              STR      r0,[r4,#0x40]         ;278
000184  2001              MOVS     r0,#1                 ;279
000186  f884003d          STRB     r0,[r4,#0x3d]         ;279
00018a  2000              MOVS     r0,#0                 ;281
00018c  e7d6              B        |L1.316|
;;;283    
                          ENDP

                  HAL_USART_MspDeInit PROC
;;;338      */
;;;339     __weak void HAL_USART_MspDeInit(USART_HandleTypeDef *husart)
00018e  4770              BX       lr
;;;340    {
;;;341      /* Prevent unused argument(s) compilation warning */
;;;342      UNUSED(husart);
;;;343      /* NOTE: This function should not be modified, when the callback is needed,
;;;344               the HAL_USART_MspDeInit can be implemented in the user file
;;;345       */ 
;;;346    }
;;;347    
                          ENDP

                  HAL_USART_DeInit PROC
;;;289      */
;;;290    HAL_StatusTypeDef HAL_USART_DeInit(USART_HandleTypeDef *husart)
000190  b510              PUSH     {r4,lr}
;;;291    {
000192  4604              MOV      r4,r0
;;;292       /* Check the USART handle allocation */
;;;293      if(husart == NULL)
000194  b90c              CBNZ     r4,|L1.410|
;;;294      {
;;;295        return HAL_ERROR;
000196  2001              MOVS     r0,#1
                  |L1.408|
;;;296      }
;;;297    
;;;298      /* Check the parameters */
;;;299      assert_param(IS_USART_INSTANCE(husart->Instance));
;;;300    
;;;301      husart->State = HAL_USART_STATE_BUSY;
;;;302    
;;;303      /* Disable the Peripheral */
;;;304      __HAL_USART_DISABLE(husart);
;;;305    
;;;306      /* DeInit the low level hardware */
;;;307      HAL_USART_MspDeInit(husart);
;;;308    
;;;309      husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;310      husart->State = HAL_USART_STATE_RESET;
;;;311    
;;;312      /* Release Lock */
;;;313      __HAL_UNLOCK(husart);
;;;314    
;;;315      return HAL_OK;
;;;316    }
000198  bd10              POP      {r4,pc}
                  |L1.410|
00019a  2002              MOVS     r0,#2                 ;301
00019c  f884003d          STRB     r0,[r4,#0x3d]         ;301
0001a0  6820              LDR      r0,[r4,#0]            ;304
0001a2  68c0              LDR      r0,[r0,#0xc]          ;304
0001a4  f4205000          BIC      r0,r0,#0x2000         ;304
0001a8  6821              LDR      r1,[r4,#0]            ;304
0001aa  60c8              STR      r0,[r1,#0xc]          ;304
0001ac  4620              MOV      r0,r4                 ;307
0001ae  f7fffffe          BL       HAL_USART_MspDeInit
0001b2  2000              MOVS     r0,#0                 ;309
0001b4  6420              STR      r0,[r4,#0x40]         ;309
0001b6  f884003d          STRB     r0,[r4,#0x3d]         ;310
0001ba  bf00              NOP                            ;313
0001bc  f884003c          STRB     r0,[r4,#0x3c]         ;313
0001c0  bf00              NOP                            ;313
0001c2  bf00              NOP                            ;315
0001c4  e7e8              B        |L1.408|
;;;317    
                          ENDP

                  USART_WaitOnFlagUntilTimeout PROC
;;;1517     */
;;;1518   static HAL_StatusTypeDef USART_WaitOnFlagUntilTimeout(USART_HandleTypeDef *husart, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
0001c6  e92d41f0          PUSH     {r4-r8,lr}
;;;1519   {
0001ca  4604              MOV      r4,r0
0001cc  460e              MOV      r6,r1
0001ce  4617              MOV      r7,r2
0001d0  461d              MOV      r5,r3
;;;1520     uint32_t tickstart = 0;
0001d2  f04f0800          MOV      r8,#0
;;;1521   
;;;1522     /* Get tick */ 
;;;1523     tickstart = HAL_GetTick();
0001d6  f7fffffe          BL       HAL_GetTick
0001da  4680              MOV      r8,r0
;;;1524   
;;;1525     /* Wait until flag is set */
;;;1526     if(Status == RESET)
0001dc  bb9f              CBNZ     r7,|L1.582|
;;;1527     {
;;;1528       while(__HAL_USART_GET_FLAG(husart, Flag) == RESET)
0001de  e02b              B        |L1.568|
                  |L1.480|
;;;1529       {
;;;1530         /* Check for the Timeout */
;;;1531         if(Timeout != HAL_MAX_DELAY)
0001e0  1c68              ADDS     r0,r5,#1
0001e2  b348              CBZ      r0,|L1.568|
;;;1532         {
;;;1533           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
0001e4  b12d              CBZ      r5,|L1.498|
0001e6  f7fffffe          BL       HAL_GetTick
0001ea  eba00008          SUB      r0,r0,r8
0001ee  42a8              CMP      r0,r5
0001f0  d922              BLS      |L1.568|
                  |L1.498|
;;;1534           {
;;;1535             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1536             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
0001f2  6820              LDR      r0,[r4,#0]
0001f4  68c0              LDR      r0,[r0,#0xc]
0001f6  f0200080          BIC      r0,r0,#0x80
0001fa  6821              LDR      r1,[r4,#0]
0001fc  60c8              STR      r0,[r1,#0xc]
;;;1537             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
0001fe  6820              LDR      r0,[r4,#0]
000200  68c0              LDR      r0,[r0,#0xc]
000202  f0200020          BIC      r0,r0,#0x20
000206  6821              LDR      r1,[r4,#0]
000208  60c8              STR      r0,[r1,#0xc]
;;;1538             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
00020a  6820              LDR      r0,[r4,#0]
00020c  68c0              LDR      r0,[r0,#0xc]
00020e  f4207080          BIC      r0,r0,#0x100
000212  6821              LDR      r1,[r4,#0]
000214  60c8              STR      r0,[r1,#0xc]
;;;1539             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000216  6820              LDR      r0,[r4,#0]
000218  6940              LDR      r0,[r0,#0x14]
00021a  f0200001          BIC      r0,r0,#1
00021e  6821              LDR      r1,[r4,#0]
000220  6148              STR      r0,[r1,#0x14]
;;;1540   
;;;1541             husart->State= HAL_USART_STATE_READY;
000222  2001              MOVS     r0,#1
000224  f884003d          STRB     r0,[r4,#0x3d]
;;;1542   
;;;1543             /* Process Unlocked */
;;;1544             __HAL_UNLOCK(husart);
000228  bf00              NOP      
00022a  2000              MOVS     r0,#0
00022c  f884003c          STRB     r0,[r4,#0x3c]
000230  bf00              NOP      
;;;1545   
;;;1546             return HAL_TIMEOUT;
000232  2003              MOVS     r0,#3
                  |L1.564|
;;;1547           }
;;;1548         }
;;;1549       }
;;;1550     }
;;;1551     else
;;;1552     {
;;;1553       while(__HAL_USART_GET_FLAG(husart, Flag) != RESET)
;;;1554       {
;;;1555         /* Check for the Timeout */
;;;1556         if(Timeout != HAL_MAX_DELAY)
;;;1557         {
;;;1558           if((Timeout == 0)||((HAL_GetTick() - tickstart ) > Timeout))
;;;1559           {
;;;1560             /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;1561             __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
;;;1562             __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
;;;1563             __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
;;;1564             __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
;;;1565   
;;;1566             husart->State= HAL_USART_STATE_READY;
;;;1567   
;;;1568             /* Process Unlocked */
;;;1569             __HAL_UNLOCK(husart);
;;;1570   
;;;1571             return HAL_TIMEOUT;
;;;1572           }
;;;1573         }
;;;1574       }
;;;1575     }
;;;1576     return HAL_OK;
;;;1577   }
000234  e8bd81f0          POP      {r4-r8,pc}
                  |L1.568|
000238  6820              LDR      r0,[r4,#0]            ;1528
00023a  6800              LDR      r0,[r0,#0]            ;1528
00023c  4030              ANDS     r0,r0,r6              ;1528
00023e  42b0              CMP      r0,r6                 ;1528
000240  d102              BNE      |L1.584|
000242  2001              MOVS     r0,#1                 ;1528
000244  e001              B        |L1.586|
                  |L1.582|
000246  e003              B        |L1.592|
                  |L1.584|
000248  2000              MOVS     r0,#0                 ;1528
                  |L1.586|
00024a  2800              CMP      r0,#0                 ;1528
00024c  d0c8              BEQ      |L1.480|
00024e  e035              B        |L1.700|
                  |L1.592|
000250  e02a              B        |L1.680|
                  |L1.594|
000252  1c68              ADDS     r0,r5,#1              ;1556
000254  b340              CBZ      r0,|L1.680|
000256  b12d              CBZ      r5,|L1.612|
000258  f7fffffe          BL       HAL_GetTick
00025c  eba00008          SUB      r0,r0,r8              ;1558
000260  42a8              CMP      r0,r5                 ;1558
000262  d921              BLS      |L1.680|
                  |L1.612|
000264  6820              LDR      r0,[r4,#0]            ;1561
000266  68c0              LDR      r0,[r0,#0xc]          ;1561
000268  f0200080          BIC      r0,r0,#0x80           ;1561
00026c  6821              LDR      r1,[r4,#0]            ;1561
00026e  60c8              STR      r0,[r1,#0xc]          ;1561
000270  6820              LDR      r0,[r4,#0]            ;1562
000272  68c0              LDR      r0,[r0,#0xc]          ;1562
000274  f0200020          BIC      r0,r0,#0x20           ;1562
000278  6821              LDR      r1,[r4,#0]            ;1562
00027a  60c8              STR      r0,[r1,#0xc]          ;1562
00027c  6820              LDR      r0,[r4,#0]            ;1563
00027e  68c0              LDR      r0,[r0,#0xc]          ;1563
000280  f4207080          BIC      r0,r0,#0x100          ;1563
000284  6821              LDR      r1,[r4,#0]            ;1563
000286  60c8              STR      r0,[r1,#0xc]          ;1563
000288  6820              LDR      r0,[r4,#0]            ;1564
00028a  6940              LDR      r0,[r0,#0x14]         ;1564
00028c  f0200001          BIC      r0,r0,#1              ;1564
000290  6821              LDR      r1,[r4,#0]            ;1564
000292  6148              STR      r0,[r1,#0x14]         ;1564
000294  2001              MOVS     r0,#1                 ;1566
000296  f884003d          STRB     r0,[r4,#0x3d]         ;1566
00029a  bf00              NOP                            ;1569
00029c  2000              MOVS     r0,#0                 ;1569
00029e  f884003c          STRB     r0,[r4,#0x3c]         ;1569
0002a2  bf00              NOP                            ;1569
0002a4  2003              MOVS     r0,#3                 ;1571
0002a6  e7c5              B        |L1.564|
                  |L1.680|
0002a8  6820              LDR      r0,[r4,#0]            ;1553
0002aa  6800              LDR      r0,[r0,#0]            ;1553
0002ac  4030              ANDS     r0,r0,r6              ;1553
0002ae  42b0              CMP      r0,r6                 ;1553
0002b0  d101              BNE      |L1.694|
0002b2  2001              MOVS     r0,#1                 ;1553
0002b4  e000              B        |L1.696|
                  |L1.694|
0002b6  2000              MOVS     r0,#0                 ;1553
                  |L1.696|
0002b8  2800              CMP      r0,#0                 ;1553
0002ba  d1ca              BNE      |L1.594|
                  |L1.700|
0002bc  2000              MOVS     r0,#0                 ;1576
0002be  e7b9              B        |L1.564|
;;;1578   
                          ENDP

                  HAL_USART_Transmit PROC
;;;421      */
;;;422    HAL_StatusTypeDef HAL_USART_Transmit(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size, uint32_t Timeout)
0002c0  e92d41f0          PUSH     {r4-r8,lr}
;;;423    {
0002c4  4604              MOV      r4,r0
0002c6  460d              MOV      r5,r1
0002c8  4616              MOV      r6,r2
0002ca  461f              MOV      r7,r3
;;;424      uint16_t* tmp=0;
0002cc  f04f0800          MOV      r8,#0
;;;425    
;;;426      if(husart->State == HAL_USART_STATE_READY)
0002d0  f894003d          LDRB     r0,[r4,#0x3d]
0002d4  2801              CMP      r0,#1
0002d6  d156              BNE      |L1.902|
;;;427      {
;;;428        if((pTxData == NULL) || (Size == 0)) 
0002d8  b105              CBZ      r5,|L1.732|
0002da  b916              CBNZ     r6,|L1.738|
                  |L1.732|
;;;429        {
;;;430          return  HAL_ERROR;
0002dc  2001              MOVS     r0,#1
                  |L1.734|
;;;431        }
;;;432    
;;;433        /* Process Locked */
;;;434        __HAL_LOCK(husart);
;;;435    
;;;436        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;437        husart->State = HAL_USART_STATE_BUSY_TX;
;;;438    
;;;439        husart->TxXferSize = Size;
;;;440        husart->TxXferCount = Size;
;;;441        while(husart->TxXferCount > 0)
;;;442        {
;;;443          husart->TxXferCount--;
;;;444          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;445          {
;;;446            /* Wait for TC flag in order to write data in DR */
;;;447            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;448            {
;;;449              return HAL_TIMEOUT;
;;;450            }
;;;451            tmp = (uint16_t*) pTxData;
;;;452            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;453            if(husart->Init.Parity == USART_PARITY_NONE)
;;;454            {
;;;455              pTxData += 2;
;;;456            }
;;;457            else
;;;458            {
;;;459              pTxData += 1;
;;;460            }
;;;461          }
;;;462          else
;;;463          {
;;;464            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;465            {
;;;466              return HAL_TIMEOUT;
;;;467            }
;;;468            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0xFF));
;;;469          }
;;;470        }
;;;471    
;;;472        if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TC, RESET, Timeout) != HAL_OK)
;;;473        { 
;;;474          return HAL_TIMEOUT;
;;;475        }
;;;476    
;;;477        husart->State = HAL_USART_STATE_READY;
;;;478    
;;;479        /* Process Unlocked */
;;;480        __HAL_UNLOCK(husart);
;;;481    
;;;482        return HAL_OK;
;;;483      }
;;;484      else
;;;485      {
;;;486        return HAL_BUSY;
;;;487      }
;;;488    }
0002de  e8bd81f0          POP      {r4-r8,pc}
                  |L1.738|
0002e2  bf00              NOP                            ;434
0002e4  f894003c          LDRB     r0,[r4,#0x3c]         ;434
0002e8  2801              CMP      r0,#1                 ;434
0002ea  d101              BNE      |L1.752|
0002ec  2002              MOVS     r0,#2                 ;434
0002ee  e7f6              B        |L1.734|
                  |L1.752|
0002f0  2001              MOVS     r0,#1                 ;434
0002f2  f884003c          STRB     r0,[r4,#0x3c]         ;434
0002f6  bf00              NOP                            ;434
0002f8  2000              MOVS     r0,#0                 ;436
0002fa  6420              STR      r0,[r4,#0x40]         ;436
0002fc  2012              MOVS     r0,#0x12              ;437
0002fe  f884003d          STRB     r0,[r4,#0x3d]         ;437
000302  8526              STRH     r6,[r4,#0x28]         ;439
000304  8566              STRH     r6,[r4,#0x2a]         ;440
000306  e029              B        |L1.860|
                  |L1.776|
000308  8d60              LDRH     r0,[r4,#0x2a]         ;443
00030a  1e40              SUBS     r0,r0,#1              ;443
00030c  8560              STRH     r0,[r4,#0x2a]         ;443
00030e  68a0              LDR      r0,[r4,#8]            ;444
000310  f5b05f80          CMP      r0,#0x1000            ;444
000314  d115              BNE      |L1.834|
000316  463b              MOV      r3,r7                 ;447
000318  2200              MOVS     r2,#0                 ;447
00031a  2180              MOVS     r1,#0x80              ;447
00031c  4620              MOV      r0,r4                 ;447
00031e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000322  b108              CBZ      r0,|L1.808|
000324  2003              MOVS     r0,#3                 ;449
000326  e7da              B        |L1.734|
                  |L1.808|
000328  46a8              MOV      r8,r5                 ;451
00032a  f8b80000          LDRH     r0,[r8,#0]            ;452
00032e  f3c00008          UBFX     r0,r0,#0,#9           ;452
000332  6821              LDR      r1,[r4,#0]            ;452
000334  6048              STR      r0,[r1,#4]            ;452
000336  6920              LDR      r0,[r4,#0x10]         ;453
000338  b908              CBNZ     r0,|L1.830|
00033a  1cad              ADDS     r5,r5,#2              ;455
00033c  e00e              B        |L1.860|
                  |L1.830|
00033e  1c6d              ADDS     r5,r5,#1              ;459
000340  e00c              B        |L1.860|
                  |L1.834|
000342  463b              MOV      r3,r7                 ;464
000344  2200              MOVS     r2,#0                 ;464
000346  2180              MOVS     r1,#0x80              ;464
000348  4620              MOV      r0,r4                 ;464
00034a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00034e  b108              CBZ      r0,|L1.852|
000350  2003              MOVS     r0,#3                 ;466
000352  e7c4              B        |L1.734|
                  |L1.852|
000354  f8150b01          LDRB     r0,[r5],#1            ;468
000358  6821              LDR      r1,[r4,#0]            ;468
00035a  6048              STR      r0,[r1,#4]            ;468
                  |L1.860|
00035c  8d60              LDRH     r0,[r4,#0x2a]         ;441
00035e  2800              CMP      r0,#0                 ;441
000360  dcd2              BGT      |L1.776|
000362  463b              MOV      r3,r7                 ;472
000364  2200              MOVS     r2,#0                 ;472
000366  2140              MOVS     r1,#0x40              ;472
000368  4620              MOV      r0,r4                 ;472
00036a  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00036e  b108              CBZ      r0,|L1.884|
000370  2003              MOVS     r0,#3                 ;474
000372  e7b4              B        |L1.734|
                  |L1.884|
000374  2001              MOVS     r0,#1                 ;477
000376  f884003d          STRB     r0,[r4,#0x3d]         ;477
00037a  bf00              NOP                            ;480
00037c  2000              MOVS     r0,#0                 ;480
00037e  f884003c          STRB     r0,[r4,#0x3c]         ;480
000382  bf00              NOP                            ;480
000384  e7ab              B        |L1.734|
                  |L1.902|
000386  2002              MOVS     r0,#2                 ;486
000388  e7a9              B        |L1.734|
;;;489    
                          ENDP

                  HAL_USART_Receive PROC
;;;498      */
;;;499    HAL_StatusTypeDef HAL_USART_Receive(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
00038a  e92d41f0          PUSH     {r4-r8,lr}
;;;500    {
00038e  4604              MOV      r4,r0
000390  460d              MOV      r5,r1
000392  4616              MOV      r6,r2
000394  4698              MOV      r8,r3
;;;501      uint16_t* tmp=0;
000396  2700              MOVS     r7,#0
;;;502    
;;;503      if(husart->State == HAL_USART_STATE_READY)
000398  f894003d          LDRB     r0,[r4,#0x3d]
00039c  2801              CMP      r0,#1
00039e  d175              BNE      |L1.1164|
;;;504      {
;;;505        if((pRxData == NULL) || (Size == 0)) 
0003a0  b105              CBZ      r5,|L1.932|
0003a2  b916              CBNZ     r6,|L1.938|
                  |L1.932|
;;;506        {
;;;507          return  HAL_ERROR;
0003a4  2001              MOVS     r0,#1
                  |L1.934|
;;;508        }
;;;509        
;;;510        /* Process Locked */
;;;511        __HAL_LOCK(husart);
;;;512    
;;;513        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;514        husart->State = HAL_USART_STATE_BUSY_RX;
;;;515    
;;;516        husart->RxXferSize = Size;
;;;517        husart->RxXferCount = Size;
;;;518        /* Check the remain data to be received */
;;;519        while(husart->RxXferCount > 0)
;;;520        {
;;;521          husart->RxXferCount--;
;;;522          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;523          {
;;;524            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;525            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;526            { 
;;;527              return HAL_TIMEOUT;
;;;528            }
;;;529            /* Send dummy byte in order to generate clock */
;;;530            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));
;;;531            
;;;532            /* Wait for RXNE Flag */
;;;533            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;534            { 
;;;535              return HAL_TIMEOUT;
;;;536            }
;;;537            tmp = (uint16_t*) pRxData ;
;;;538            if(husart->Init.Parity == USART_PARITY_NONE)
;;;539            {
;;;540              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;541              pRxData +=2;
;;;542            }
;;;543            else
;;;544            {
;;;545              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;546              pRxData +=1;
;;;547            }
;;;548          }
;;;549          else
;;;550          {
;;;551            /* Wait until TXE flag is set to send dummy byte in order to generate the clock for the slave to send data */
;;;552            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;553            { 
;;;554              return HAL_TIMEOUT;
;;;555            }
;;;556    
;;;557            /* Send Dummy Byte in order to generate clock */
;;;558            WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));
;;;559    
;;;560            /* Wait until RXNE flag is set to receive the byte */
;;;561            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;562            {
;;;563              return HAL_TIMEOUT;
;;;564            }
;;;565            if(husart->Init.Parity == USART_PARITY_NONE)
;;;566            {
;;;567              /* Receive data */
;;;568              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;569            }
;;;570            else
;;;571            {
;;;572              /* Receive data */
;;;573              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;574            }
;;;575            
;;;576          }
;;;577        }
;;;578    
;;;579        husart->State = HAL_USART_STATE_READY;
;;;580    
;;;581        /* Process Unlocked */
;;;582        __HAL_UNLOCK(husart);
;;;583    
;;;584        return HAL_OK;
;;;585      }
;;;586      else
;;;587      {
;;;588        return HAL_BUSY;
;;;589      }
;;;590    }
0003a6  e8bd81f0          POP      {r4-r8,pc}
                  |L1.938|
0003aa  bf00              NOP                            ;511
0003ac  f894003c          LDRB     r0,[r4,#0x3c]         ;511
0003b0  2801              CMP      r0,#1                 ;511
0003b2  d101              BNE      |L1.952|
0003b4  2002              MOVS     r0,#2                 ;511
0003b6  e7f6              B        |L1.934|
                  |L1.952|
0003b8  2001              MOVS     r0,#1                 ;511
0003ba  f884003c          STRB     r0,[r4,#0x3c]         ;511
0003be  bf00              NOP                            ;511
0003c0  2000              MOVS     r0,#0                 ;513
0003c2  6420              STR      r0,[r4,#0x40]         ;513
0003c4  2022              MOVS     r0,#0x22              ;514
0003c6  f884003d          STRB     r0,[r4,#0x3d]         ;514
0003ca  8626              STRH     r6,[r4,#0x30]         ;516
0003cc  8666              STRH     r6,[r4,#0x32]         ;517
0003ce  e050              B        |L1.1138|
                  |L1.976|
0003d0  8e60              LDRH     r0,[r4,#0x32]         ;521
0003d2  1e40              SUBS     r0,r0,#1              ;521
0003d4  8660              STRH     r0,[r4,#0x32]         ;521
0003d6  68a0              LDR      r0,[r4,#8]            ;522
0003d8  f5b05f80          CMP      r0,#0x1000            ;522
0003dc  d125              BNE      |L1.1066|
0003de  4643              MOV      r3,r8                 ;525
0003e0  2200              MOVS     r2,#0                 ;525
0003e2  2180              MOVS     r1,#0x80              ;525
0003e4  4620              MOV      r0,r4                 ;525
0003e6  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
0003ea  b108              CBZ      r0,|L1.1008|
0003ec  2003              MOVS     r0,#3                 ;527
0003ee  e7da              B        |L1.934|
                  |L1.1008|
0003f0  f24010ff          MOV      r0,#0x1ff             ;530
0003f4  6821              LDR      r1,[r4,#0]            ;530
0003f6  6048              STR      r0,[r1,#4]            ;530
0003f8  4643              MOV      r3,r8                 ;533
0003fa  2200              MOVS     r2,#0                 ;533
0003fc  2120              MOVS     r1,#0x20              ;533
0003fe  4620              MOV      r0,r4                 ;533
000400  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000404  b108              CBZ      r0,|L1.1034|
000406  2003              MOVS     r0,#3                 ;535
000408  e7cd              B        |L1.934|
                  |L1.1034|
00040a  462f              MOV      r7,r5                 ;537
00040c  6920              LDR      r0,[r4,#0x10]         ;538
00040e  b930              CBNZ     r0,|L1.1054|
000410  6820              LDR      r0,[r4,#0]            ;540
000412  6840              LDR      r0,[r0,#4]            ;540
000414  f3c00008          UBFX     r0,r0,#0,#9           ;540
000418  8038              STRH     r0,[r7,#0]            ;540
00041a  1cad              ADDS     r5,r5,#2              ;541
00041c  e029              B        |L1.1138|
                  |L1.1054|
00041e  6820              LDR      r0,[r4,#0]            ;545
000420  6840              LDR      r0,[r0,#4]            ;545
000422  b2c0              UXTB     r0,r0                 ;545
000424  8038              STRH     r0,[r7,#0]            ;545
000426  1c6d              ADDS     r5,r5,#1              ;546
000428  e023              B        |L1.1138|
                  |L1.1066|
00042a  4643              MOV      r3,r8                 ;552
00042c  2200              MOVS     r2,#0                 ;552
00042e  2180              MOVS     r1,#0x80              ;552
000430  4620              MOV      r0,r4                 ;552
000432  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000436  b118              CBZ      r0,|L1.1088|
000438  2003              MOVS     r0,#3                 ;554
00043a  e7b4              B        |L1.934|
                  |L1.1084|
                          DCD      0x40013800
                  |L1.1088|
000440  20ff              MOVS     r0,#0xff              ;558
000442  6821              LDR      r1,[r4,#0]            ;558
000444  6048              STR      r0,[r1,#4]            ;558
000446  4643              MOV      r3,r8                 ;561
000448  2200              MOVS     r2,#0                 ;561
00044a  2120              MOVS     r1,#0x20              ;561
00044c  4620              MOV      r0,r4                 ;561
00044e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000452  b108              CBZ      r0,|L1.1112|
000454  2003              MOVS     r0,#3                 ;563
000456  e7a6              B        |L1.934|
                  |L1.1112|
000458  6920              LDR      r0,[r4,#0x10]         ;565
00045a  b920              CBNZ     r0,|L1.1126|
00045c  6820              LDR      r0,[r4,#0]            ;568
00045e  6840              LDR      r0,[r0,#4]            ;568
000460  f8050b01          STRB     r0,[r5],#1            ;568
000464  e005              B        |L1.1138|
                  |L1.1126|
000466  6820              LDR      r0,[r4,#0]            ;573
000468  6840              LDR      r0,[r0,#4]            ;573
00046a  f000007f          AND      r0,r0,#0x7f           ;573
00046e  f8050b01          STRB     r0,[r5],#1            ;573
                  |L1.1138|
000472  8e60              LDRH     r0,[r4,#0x32]         ;519
000474  2800              CMP      r0,#0                 ;519
000476  dcab              BGT      |L1.976|
000478  2001              MOVS     r0,#1                 ;579
00047a  f884003d          STRB     r0,[r4,#0x3d]         ;579
00047e  bf00              NOP                            ;582
000480  2000              MOVS     r0,#0                 ;582
000482  f884003c          STRB     r0,[r4,#0x3c]         ;582
000486  bf00              NOP                            ;582
000488  e78d              B        |L1.934|
00048a  e7ff              B        |L1.1164|
                  |L1.1164|
00048c  2002              MOVS     r0,#2                 ;588
00048e  e78a              B        |L1.934|
;;;591    
                          ENDP

                  HAL_USART_TransmitReceive PROC
;;;601      */
;;;602    HAL_StatusTypeDef HAL_USART_TransmitReceive(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size, uint32_t Timeout)
000490  e92d47f0          PUSH     {r4-r10,lr}
;;;603    {
000494  4604              MOV      r4,r0
000496  460e              MOV      r6,r1
000498  4615              MOV      r5,r2
00049a  461f              MOV      r7,r3
00049c  f8dd9020          LDR      r9,[sp,#0x20]
;;;604      uint16_t* tmp=0;
0004a0  f04f0800          MOV      r8,#0
;;;605    
;;;606      if(husart->State == HAL_USART_STATE_READY)
0004a4  f894003d          LDRB     r0,[r4,#0x3d]
0004a8  2801              CMP      r0,#1
0004aa  d171              BNE      |L1.1424|
;;;607      {
;;;608        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
0004ac  b10e              CBZ      r6,|L1.1202|
0004ae  b105              CBZ      r5,|L1.1202|
0004b0  b917              CBNZ     r7,|L1.1208|
                  |L1.1202|
;;;609        {
;;;610          return  HAL_ERROR;
0004b2  2001              MOVS     r0,#1
                  |L1.1204|
;;;611        }
;;;612        /* Process Locked */
;;;613        __HAL_LOCK(husart);
;;;614    
;;;615        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;616        husart->State = HAL_USART_STATE_BUSY_RX;
;;;617    
;;;618        husart->RxXferSize = Size;
;;;619        husart->TxXferSize = Size;
;;;620        husart->TxXferCount = Size;
;;;621        husart->RxXferCount = Size;
;;;622    
;;;623        /* Check the remain data to be received */
;;;624        while(husart->TxXferCount > 0)
;;;625        {
;;;626          husart->TxXferCount--;
;;;627          husart->RxXferCount--;
;;;628          if(husart->Init.WordLength == USART_WORDLENGTH_9B)
;;;629          {
;;;630            /* Wait for TC flag in order to write data in DR */
;;;631            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;632            {
;;;633              return HAL_TIMEOUT;
;;;634            }
;;;635            tmp = (uint16_t*) pTxData;
;;;636            WRITE_REG(husart->Instance->DR, (*tmp & (uint16_t)0x01FF));
;;;637            if(husart->Init.Parity == USART_PARITY_NONE)
;;;638            {
;;;639              pTxData += 2;
;;;640            }
;;;641            else
;;;642            {
;;;643              pTxData += 1;
;;;644            }
;;;645            
;;;646            /* Wait for RXNE Flag */
;;;647            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;648            {
;;;649              return HAL_TIMEOUT;
;;;650            }
;;;651            tmp = (uint16_t*) pRxData ;
;;;652            if(husart->Init.Parity == USART_PARITY_NONE)
;;;653            {
;;;654              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
;;;655              pRxData += 2;
;;;656            }
;;;657            else
;;;658            {
;;;659              *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
;;;660              pRxData += 1;
;;;661            }
;;;662          } 
;;;663          else
;;;664          {
;;;665            /* Wait for TC flag in order to write data in DR */
;;;666            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_TXE, RESET, Timeout) != HAL_OK)
;;;667            {
;;;668              return HAL_TIMEOUT;
;;;669            }
;;;670            WRITE_REG(husart->Instance->DR, (*pTxData++ & (uint8_t)0x00FF));
;;;671    
;;;672            /* Wait for RXNE Flag */
;;;673            if(USART_WaitOnFlagUntilTimeout(husart, USART_FLAG_RXNE, RESET, Timeout) != HAL_OK)
;;;674            {
;;;675              return HAL_TIMEOUT;
;;;676            }
;;;677            if(husart->Init.Parity == USART_PARITY_NONE)
;;;678            {
;;;679              /* Receive data */
;;;680              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
;;;681            }
;;;682            else
;;;683            {
;;;684              /* Receive data */
;;;685              *pRxData++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
;;;686            }
;;;687          }
;;;688        }
;;;689    
;;;690        husart->State = HAL_USART_STATE_READY;
;;;691    
;;;692        /* Process Unlocked */
;;;693        __HAL_UNLOCK(husart);
;;;694    
;;;695        return HAL_OK;
;;;696      }
;;;697      else
;;;698      {
;;;699        return HAL_BUSY;
;;;700      }
;;;701    }
0004b4  e8bd87f0          POP      {r4-r10,pc}
                  |L1.1208|
0004b8  bf00              NOP                            ;613
0004ba  f894003c          LDRB     r0,[r4,#0x3c]         ;613
0004be  2801              CMP      r0,#1                 ;613
0004c0  d101              BNE      |L1.1222|
0004c2  2002              MOVS     r0,#2                 ;613
0004c4  e7f6              B        |L1.1204|
                  |L1.1222|
0004c6  2001              MOVS     r0,#1                 ;613
0004c8  f884003c          STRB     r0,[r4,#0x3c]         ;613
0004cc  bf00              NOP                            ;613
0004ce  2000              MOVS     r0,#0                 ;615
0004d0  6420              STR      r0,[r4,#0x40]         ;615
0004d2  2022              MOVS     r0,#0x22              ;616
0004d4  f884003d          STRB     r0,[r4,#0x3d]         ;616
0004d8  8627              STRH     r7,[r4,#0x30]         ;618
0004da  8527              STRH     r7,[r4,#0x28]         ;619
0004dc  8567              STRH     r7,[r4,#0x2a]         ;620
0004de  8667              STRH     r7,[r4,#0x32]         ;621
0004e0  e05d              B        |L1.1438|
                  |L1.1250|
0004e2  8d60              LDRH     r0,[r4,#0x2a]         ;626
0004e4  1e40              SUBS     r0,r0,#1              ;626
0004e6  8560              STRH     r0,[r4,#0x2a]         ;626
0004e8  8e60              LDRH     r0,[r4,#0x32]         ;627
0004ea  1e40              SUBS     r0,r0,#1              ;627
0004ec  8660              STRH     r0,[r4,#0x32]         ;627
0004ee  68a0              LDR      r0,[r4,#8]            ;628
0004f0  f5b05f80          CMP      r0,#0x1000            ;628
0004f4  d12f              BNE      |L1.1366|
0004f6  464b              MOV      r3,r9                 ;631
0004f8  2200              MOVS     r2,#0                 ;631
0004fa  2180              MOVS     r1,#0x80              ;631
0004fc  4620              MOV      r0,r4                 ;631
0004fe  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000502  b108              CBZ      r0,|L1.1288|
000504  2003              MOVS     r0,#3                 ;633
000506  e7d5              B        |L1.1204|
                  |L1.1288|
000508  46b0              MOV      r8,r6                 ;635
00050a  f8b80000          LDRH     r0,[r8,#0]            ;636
00050e  f3c00008          UBFX     r0,r0,#0,#9           ;636
000512  6821              LDR      r1,[r4,#0]            ;636
000514  6048              STR      r0,[r1,#4]            ;636
000516  6920              LDR      r0,[r4,#0x10]         ;637
000518  b908              CBNZ     r0,|L1.1310|
00051a  1cb6              ADDS     r6,r6,#2              ;639
00051c  e000              B        |L1.1312|
                  |L1.1310|
00051e  1c76              ADDS     r6,r6,#1              ;643
                  |L1.1312|
000520  464b              MOV      r3,r9                 ;647
000522  2200              MOVS     r2,#0                 ;647
000524  2120              MOVS     r1,#0x20              ;647
000526  4620              MOV      r0,r4                 ;647
000528  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00052c  b108              CBZ      r0,|L1.1330|
00052e  2003              MOVS     r0,#3                 ;649
000530  e7c0              B        |L1.1204|
                  |L1.1330|
000532  46a8              MOV      r8,r5                 ;651
000534  6920              LDR      r0,[r4,#0x10]         ;652
000536  b938              CBNZ     r0,|L1.1352|
000538  6820              LDR      r0,[r4,#0]            ;654
00053a  6840              LDR      r0,[r0,#4]            ;654
00053c  f3c00008          UBFX     r0,r0,#0,#9           ;654
000540  f8a80000          STRH     r0,[r8,#0]            ;654
000544  1cad              ADDS     r5,r5,#2              ;655
000546  e02a              B        |L1.1438|
                  |L1.1352|
000548  6820              LDR      r0,[r4,#0]            ;659
00054a  6840              LDR      r0,[r0,#4]            ;659
00054c  b2c0              UXTB     r0,r0                 ;659
00054e  f8a80000          STRH     r0,[r8,#0]            ;659
000552  1c6d              ADDS     r5,r5,#1              ;660
000554  e023              B        |L1.1438|
                  |L1.1366|
000556  464b              MOV      r3,r9                 ;666
000558  2200              MOVS     r2,#0                 ;666
00055a  2180              MOVS     r1,#0x80              ;666
00055c  4620              MOV      r0,r4                 ;666
00055e  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
000562  b108              CBZ      r0,|L1.1384|
000564  2003              MOVS     r0,#3                 ;668
000566  e7a5              B        |L1.1204|
                  |L1.1384|
000568  f8160b01          LDRB     r0,[r6],#1            ;670
00056c  6821              LDR      r1,[r4,#0]            ;670
00056e  6048              STR      r0,[r1,#4]            ;670
000570  464b              MOV      r3,r9                 ;673
000572  2200              MOVS     r2,#0                 ;673
000574  2120              MOVS     r1,#0x20              ;673
000576  4620              MOV      r0,r4                 ;673
000578  f7fffffe          BL       USART_WaitOnFlagUntilTimeout
00057c  b108              CBZ      r0,|L1.1410|
00057e  2003              MOVS     r0,#3                 ;675
000580  e798              B        |L1.1204|
                  |L1.1410|
000582  6920              LDR      r0,[r4,#0x10]         ;677
000584  b928              CBNZ     r0,|L1.1426|
000586  6820              LDR      r0,[r4,#0]            ;680
000588  6840              LDR      r0,[r0,#4]            ;680
00058a  f8050b01          STRB     r0,[r5],#1            ;680
00058e  e006              B        |L1.1438|
                  |L1.1424|
000590  e011              B        |L1.1462|
                  |L1.1426|
000592  6820              LDR      r0,[r4,#0]            ;685
000594  6840              LDR      r0,[r0,#4]            ;685
000596  f000007f          AND      r0,r0,#0x7f           ;685
00059a  f8050b01          STRB     r0,[r5],#1            ;685
                  |L1.1438|
00059e  8d60              LDRH     r0,[r4,#0x2a]         ;624
0005a0  2800              CMP      r0,#0                 ;624
0005a2  dc9e              BGT      |L1.1250|
0005a4  2001              MOVS     r0,#1                 ;690
0005a6  f884003d          STRB     r0,[r4,#0x3d]         ;690
0005aa  bf00              NOP                            ;693
0005ac  2000              MOVS     r0,#0                 ;693
0005ae  f884003c          STRB     r0,[r4,#0x3c]         ;693
0005b2  bf00              NOP                            ;693
0005b4  e77e              B        |L1.1204|
                  |L1.1462|
0005b6  2002              MOVS     r0,#2                 ;699
0005b8  e77c              B        |L1.1204|
;;;702    
                          ENDP

                  HAL_USART_Transmit_IT PROC
;;;711      */
;;;712    HAL_StatusTypeDef HAL_USART_Transmit_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
0005ba  b510              PUSH     {r4,lr}
;;;713    {
0005bc  4603              MOV      r3,r0
;;;714      if(husart->State == HAL_USART_STATE_READY)
0005be  f893003d          LDRB     r0,[r3,#0x3d]
0005c2  2801              CMP      r0,#1
0005c4  d123              BNE      |L1.1550|
;;;715      {
;;;716        if((pTxData == NULL) || (Size == 0)) 
0005c6  b101              CBZ      r1,|L1.1482|
0005c8  b90a              CBNZ     r2,|L1.1486|
                  |L1.1482|
;;;717        {
;;;718          return HAL_ERROR;
0005ca  2001              MOVS     r0,#1
                  |L1.1484|
;;;719        }
;;;720    
;;;721        /* Process Locked */
;;;722        __HAL_LOCK(husart);
;;;723    
;;;724        husart->pTxBuffPtr = pTxData;
;;;725        husart->TxXferSize = Size;
;;;726        husart->TxXferCount = Size;
;;;727    
;;;728        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;729        husart->State = HAL_USART_STATE_BUSY_TX;
;;;730    
;;;731        /* The USART Error Interrupts: (Frame error, Noise error, Overrun error) 
;;;732           are not managed by the USART transmit process to avoid the overrun interrupt
;;;733           when the USART mode is configured for transmit and receive "USART_MODE_TX_RX"
;;;734           to benefit for the frame error and noise interrupts the USART mode should be
;;;735           configured only for transmit "USART_MODE_TX"
;;;736           The __HAL_USART_ENABLE_IT(husart, USART_IT_ERR) can be used to enable the Frame error,
;;;737           Noise error interrupt */
;;;738    
;;;739        /* Process Unlocked */
;;;740        __HAL_UNLOCK(husart);
;;;741    
;;;742        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;743        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;744    
;;;745        return HAL_OK;
;;;746      }
;;;747      else
;;;748      {
;;;749        return HAL_BUSY;
;;;750      }
;;;751    }
0005cc  bd10              POP      {r4,pc}
                  |L1.1486|
0005ce  bf00              NOP                            ;722
0005d0  f893003c          LDRB     r0,[r3,#0x3c]         ;722
0005d4  2801              CMP      r0,#1                 ;722
0005d6  d101              BNE      |L1.1500|
0005d8  2002              MOVS     r0,#2                 ;722
0005da  e7f7              B        |L1.1484|
                  |L1.1500|
0005dc  2001              MOVS     r0,#1                 ;722
0005de  f883003c          STRB     r0,[r3,#0x3c]         ;722
0005e2  bf00              NOP                            ;722
0005e4  6259              STR      r1,[r3,#0x24]         ;724
0005e6  851a              STRH     r2,[r3,#0x28]         ;725
0005e8  855a              STRH     r2,[r3,#0x2a]         ;726
0005ea  2000              MOVS     r0,#0                 ;728
0005ec  6418              STR      r0,[r3,#0x40]         ;728
0005ee  2012              MOVS     r0,#0x12              ;729
0005f0  f883003d          STRB     r0,[r3,#0x3d]         ;729
0005f4  bf00              NOP                            ;740
0005f6  2000              MOVS     r0,#0                 ;740
0005f8  f883003c          STRB     r0,[r3,#0x3c]         ;740
0005fc  bf00              NOP                            ;740
0005fe  6818              LDR      r0,[r3,#0]            ;743
000600  68c0              LDR      r0,[r0,#0xc]          ;743
000602  f0400080          ORR      r0,r0,#0x80           ;743
000606  681c              LDR      r4,[r3,#0]            ;743
000608  60e0              STR      r0,[r4,#0xc]          ;743
00060a  2000              MOVS     r0,#0                 ;745
00060c  e7de              B        |L1.1484|
                  |L1.1550|
00060e  2002              MOVS     r0,#2                 ;749
000610  e7dc              B        |L1.1484|
;;;752    
                          ENDP

                  HAL_USART_Receive_IT PROC
;;;760      */
;;;761    HAL_StatusTypeDef HAL_USART_Receive_IT(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
000612  b510              PUSH     {r4,lr}
;;;762    {
000614  4603              MOV      r3,r0
;;;763      if(husart->State == HAL_USART_STATE_READY)
000616  f893003d          LDRB     r0,[r3,#0x3d]
00061a  2801              CMP      r0,#1
00061c  d133              BNE      |L1.1670|
;;;764      {
;;;765        if((pRxData == NULL) || (Size == 0)) 
00061e  b101              CBZ      r1,|L1.1570|
000620  b90a              CBNZ     r2,|L1.1574|
                  |L1.1570|
;;;766        {
;;;767          return HAL_ERROR;
000622  2001              MOVS     r0,#1
                  |L1.1572|
;;;768        }
;;;769        /* Process Locked */
;;;770        __HAL_LOCK(husart);
;;;771    
;;;772        husart->pRxBuffPtr = pRxData;
;;;773        husart->RxXferSize = Size;
;;;774        husart->RxXferCount = Size;
;;;775    
;;;776        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;777        husart->State = HAL_USART_STATE_BUSY_RX;
;;;778    
;;;779        /* Process Unlocked */
;;;780        __HAL_UNLOCK(husart);
;;;781    
;;;782        /* Enable the USART Data Register not empty Interrupt */
;;;783        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;784    
;;;785        /* Enable the USART Parity Error Interrupt */
;;;786        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;787    
;;;788        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;789        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;790    
;;;791        /* Send dummy byte in order to generate the clock for the slave to send data */
;;;792        WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF));    
;;;793    
;;;794        return HAL_OK;
;;;795      }
;;;796      else
;;;797      {
;;;798        return HAL_BUSY;
;;;799      }
;;;800    }
000624  bd10              POP      {r4,pc}
                  |L1.1574|
000626  bf00              NOP                            ;770
000628  f893003c          LDRB     r0,[r3,#0x3c]         ;770
00062c  2801              CMP      r0,#1                 ;770
00062e  d101              BNE      |L1.1588|
000630  2002              MOVS     r0,#2                 ;770
000632  e7f7              B        |L1.1572|
                  |L1.1588|
000634  2001              MOVS     r0,#1                 ;770
000636  f883003c          STRB     r0,[r3,#0x3c]         ;770
00063a  bf00              NOP                            ;770
00063c  62d9              STR      r1,[r3,#0x2c]         ;772
00063e  861a              STRH     r2,[r3,#0x30]         ;773
000640  865a              STRH     r2,[r3,#0x32]         ;774
000642  2000              MOVS     r0,#0                 ;776
000644  6418              STR      r0,[r3,#0x40]         ;776
000646  2022              MOVS     r0,#0x22              ;777
000648  f883003d          STRB     r0,[r3,#0x3d]         ;777
00064c  bf00              NOP                            ;780
00064e  2000              MOVS     r0,#0                 ;780
000650  f883003c          STRB     r0,[r3,#0x3c]         ;780
000654  bf00              NOP                            ;780
000656  6818              LDR      r0,[r3,#0]            ;783
000658  68c0              LDR      r0,[r0,#0xc]          ;783
00065a  f0400020          ORR      r0,r0,#0x20           ;783
00065e  681c              LDR      r4,[r3,#0]            ;783
000660  60e0              STR      r0,[r4,#0xc]          ;783
000662  6818              LDR      r0,[r3,#0]            ;786
000664  68c0              LDR      r0,[r0,#0xc]          ;786
000666  f4407080          ORR      r0,r0,#0x100          ;786
00066a  681c              LDR      r4,[r3,#0]            ;786
00066c  60e0              STR      r0,[r4,#0xc]          ;786
00066e  6818              LDR      r0,[r3,#0]            ;789
000670  6940              LDR      r0,[r0,#0x14]         ;789
000672  f0400001          ORR      r0,r0,#1              ;789
000676  681c              LDR      r4,[r3,#0]            ;789
000678  6160              STR      r0,[r4,#0x14]         ;789
00067a  f24010ff          MOV      r0,#0x1ff             ;792
00067e  681c              LDR      r4,[r3,#0]            ;792
000680  6060              STR      r0,[r4,#4]            ;792
000682  2000              MOVS     r0,#0                 ;794
000684  e7ce              B        |L1.1572|
                  |L1.1670|
000686  2002              MOVS     r0,#2                 ;798
000688  e7cc              B        |L1.1572|
;;;801    
                          ENDP

                  HAL_USART_TransmitReceive_IT PROC
;;;810      */
;;;811    HAL_StatusTypeDef HAL_USART_TransmitReceive_IT(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData,  uint16_t Size)
00068a  b530              PUSH     {r4,r5,lr}
;;;812    {
00068c  4604              MOV      r4,r0
;;;813      if(husart->State == HAL_USART_STATE_READY)
00068e  f894003d          LDRB     r0,[r4,#0x3d]
000692  2801              CMP      r0,#1
000694  d139              BNE      |L1.1802|
;;;814      {
;;;815        if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000696  b109              CBZ      r1,|L1.1692|
000698  b102              CBZ      r2,|L1.1692|
00069a  b90b              CBNZ     r3,|L1.1696|
                  |L1.1692|
;;;816        {
;;;817          return HAL_ERROR;
00069c  2001              MOVS     r0,#1
                  |L1.1694|
;;;818        }
;;;819        /* Process Locked */
;;;820        __HAL_LOCK(husart);
;;;821    
;;;822        husart->pRxBuffPtr = pRxData;
;;;823        husart->RxXferSize = Size;
;;;824        husart->RxXferCount = Size;
;;;825        husart->pTxBuffPtr = pTxData;
;;;826        husart->TxXferSize = Size;
;;;827        husart->TxXferCount = Size;
;;;828    
;;;829        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;830        husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;831    
;;;832        /* Process Unlocked */
;;;833        __HAL_UNLOCK(husart);
;;;834    
;;;835        /* Enable the USART Data Register not empty Interrupt */
;;;836        __HAL_USART_ENABLE_IT(husart, USART_IT_RXNE); 
;;;837    
;;;838        /* Enable the USART Parity Error Interrupt */
;;;839        __HAL_USART_ENABLE_IT(husart, USART_IT_PE);
;;;840    
;;;841        /* Enable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;842        __HAL_USART_ENABLE_IT(husart, USART_IT_ERR);
;;;843    
;;;844        /* Enable the USART Transmit Data Register Empty Interrupt */
;;;845        __HAL_USART_ENABLE_IT(husart, USART_IT_TXE);
;;;846    
;;;847        return HAL_OK;
;;;848      }
;;;849      else
;;;850      {
;;;851        return HAL_BUSY; 
;;;852      }
;;;853    }
00069e  bd30              POP      {r4,r5,pc}
                  |L1.1696|
0006a0  bf00              NOP                            ;820
0006a2  f894003c          LDRB     r0,[r4,#0x3c]         ;820
0006a6  2801              CMP      r0,#1                 ;820
0006a8  d101              BNE      |L1.1710|
0006aa  2002              MOVS     r0,#2                 ;820
0006ac  e7f7              B        |L1.1694|
                  |L1.1710|
0006ae  2001              MOVS     r0,#1                 ;820
0006b0  f884003c          STRB     r0,[r4,#0x3c]         ;820
0006b4  bf00              NOP                            ;820
0006b6  62e2              STR      r2,[r4,#0x2c]         ;822
0006b8  8623              STRH     r3,[r4,#0x30]         ;823
0006ba  8663              STRH     r3,[r4,#0x32]         ;824
0006bc  6261              STR      r1,[r4,#0x24]         ;825
0006be  8523              STRH     r3,[r4,#0x28]         ;826
0006c0  8563              STRH     r3,[r4,#0x2a]         ;827
0006c2  2000              MOVS     r0,#0                 ;829
0006c4  6420              STR      r0,[r4,#0x40]         ;829
0006c6  2032              MOVS     r0,#0x32              ;830
0006c8  f884003d          STRB     r0,[r4,#0x3d]         ;830
0006cc  bf00              NOP                            ;833
0006ce  2000              MOVS     r0,#0                 ;833
0006d0  f884003c          STRB     r0,[r4,#0x3c]         ;833
0006d4  bf00              NOP                            ;833
0006d6  6820              LDR      r0,[r4,#0]            ;836
0006d8  68c0              LDR      r0,[r0,#0xc]          ;836
0006da  f0400020          ORR      r0,r0,#0x20           ;836
0006de  6825              LDR      r5,[r4,#0]            ;836
0006e0  60e8              STR      r0,[r5,#0xc]          ;836
0006e2  6820              LDR      r0,[r4,#0]            ;839
0006e4  68c0              LDR      r0,[r0,#0xc]          ;839
0006e6  f4407080          ORR      r0,r0,#0x100          ;839
0006ea  6825              LDR      r5,[r4,#0]            ;839
0006ec  60e8              STR      r0,[r5,#0xc]          ;839
0006ee  6820              LDR      r0,[r4,#0]            ;842
0006f0  6940              LDR      r0,[r0,#0x14]         ;842
0006f2  f0400001          ORR      r0,r0,#1              ;842
0006f6  6825              LDR      r5,[r4,#0]            ;842
0006f8  6168              STR      r0,[r5,#0x14]         ;842
0006fa  6820              LDR      r0,[r4,#0]            ;845
0006fc  68c0              LDR      r0,[r0,#0xc]          ;845
0006fe  f0400080          ORR      r0,r0,#0x80           ;845
000702  6825              LDR      r5,[r4,#0]            ;845
000704  60e8              STR      r0,[r5,#0xc]          ;845
000706  2000              MOVS     r0,#0                 ;847
000708  e7c9              B        |L1.1694|
                  |L1.1802|
00070a  2002              MOVS     r0,#2                 ;851
00070c  e7c7              B        |L1.1694|
;;;854    
                          ENDP

                  HAL_USART_ErrorCallback PROC
;;;1314     */
;;;1315    __weak void HAL_USART_ErrorCallback(USART_HandleTypeDef *husart)
00070e  4770              BX       lr
;;;1316   {
;;;1317     /* Prevent unused argument(s) compilation warning */
;;;1318     UNUSED(husart);
;;;1319     /* NOTE: This function should not be modified, when the callback is needed,
;;;1320              the HAL_USART_ErrorCallback can be implemented in the user file
;;;1321      */ 
;;;1322   }
;;;1323   
                          ENDP

                  USART_DMAError PROC
;;;1496     */
;;;1497   static void USART_DMAError(DMA_HandleTypeDef *hdma)   
000710  b570              PUSH     {r4-r6,lr}
;;;1498   {
000712  4605              MOV      r5,r0
;;;1499     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000714  6a6c              LDR      r4,[r5,#0x24]
;;;1500   
;;;1501     husart->RxXferCount = 0;
000716  2000              MOVS     r0,#0
000718  8660              STRH     r0,[r4,#0x32]
;;;1502     husart->TxXferCount = 0;
00071a  8560              STRH     r0,[r4,#0x2a]
;;;1503     husart->ErrorCode |= HAL_USART_ERROR_DMA;
00071c  6c20              LDR      r0,[r4,#0x40]
00071e  f0400010          ORR      r0,r0,#0x10
000722  6420              STR      r0,[r4,#0x40]
;;;1504     husart->State= HAL_USART_STATE_READY;
000724  2001              MOVS     r0,#1
000726  f884003d          STRB     r0,[r4,#0x3d]
;;;1505     
;;;1506     HAL_USART_ErrorCallback(husart);
00072a  4620              MOV      r0,r4
00072c  f7fffffe          BL       HAL_USART_ErrorCallback
;;;1507   }
000730  bd70              POP      {r4-r6,pc}
;;;1508   
                          ENDP

                  HAL_USART_TxHalfCpltCallback PROC
;;;1254     */
;;;1255    __weak void HAL_USART_TxHalfCpltCallback(USART_HandleTypeDef *husart)
000732  4770              BX       lr
;;;1256   {
;;;1257     /* Prevent unused argument(s) compilation warning */
;;;1258     UNUSED(husart);
;;;1259     /* NOTE: This function should not be modified, when the callback is needed,
;;;1260              the HAL_USART_TxHalfCpltCallback can be implemented in the user file
;;;1261      */
;;;1262   }
;;;1263   
                          ENDP

                  USART_DMATxHalfCplt PROC
;;;1421     */
;;;1422   static void USART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000734  b570              PUSH     {r4-r6,lr}
;;;1423   {
000736  4604              MOV      r4,r0
;;;1424     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000738  6a65              LDR      r5,[r4,#0x24]
;;;1425   
;;;1426     HAL_USART_TxHalfCpltCallback(husart);
00073a  4628              MOV      r0,r5
00073c  f7fffffe          BL       HAL_USART_TxHalfCpltCallback
;;;1427   }
000740  bd70              POP      {r4-r6,pc}
;;;1428   
                          ENDP

                  HAL_USART_TxCpltCallback PROC
;;;1239     */
;;;1240    __weak void HAL_USART_TxCpltCallback(USART_HandleTypeDef *husart)
000742  4770              BX       lr
;;;1241   {
;;;1242     /* Prevent unused argument(s) compilation warning */
;;;1243     UNUSED(husart);
;;;1244     /* NOTE: This function should not be modified, when the callback is needed,
;;;1245              the HAL_USART_TxCpltCallback can be implemented in the user file
;;;1246      */
;;;1247   }
;;;1248   
                          ENDP

                  USART_DMATransmitCplt PROC
;;;1386     */
;;;1387   static void USART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000744  b570              PUSH     {r4-r6,lr}
;;;1388   {
000746  4605              MOV      r5,r0
;;;1389     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
000748  6a6c              LDR      r4,[r5,#0x24]
;;;1390   
;;;1391     /* DMA Normal mode */
;;;1392     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
00074a  6828              LDR      r0,[r5,#0]
00074c  6800              LDR      r0,[r0,#0]
00074e  f0000020          AND      r0,r0,#0x20
000752  b990              CBNZ     r0,|L1.1914|
;;;1393     {
;;;1394       husart->TxXferCount = 0;
000754  2000              MOVS     r0,#0
000756  8560              STRH     r0,[r4,#0x2a]
;;;1395   
;;;1396       if(husart->State == HAL_USART_STATE_BUSY_TX)
000758  f894003d          LDRB     r0,[r4,#0x3d]
00075c  2812              CMP      r0,#0x12
00075e  d113              BNE      |L1.1928|
;;;1397       {
;;;1398         /* Disable the DMA transfer for transmit request by resetting the DMAT bit
;;;1399            in the USART CR3 register */
;;;1400         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAT);
000760  6820              LDR      r0,[r4,#0]
000762  6940              LDR      r0,[r0,#0x14]
000764  f0200080          BIC      r0,r0,#0x80
000768  6821              LDR      r1,[r4,#0]
00076a  6148              STR      r0,[r1,#0x14]
;;;1401         
;;;1402         /* Enable the USART Transmit Complete Interrupt */    
;;;1403         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
00076c  6820              LDR      r0,[r4,#0]
00076e  68c0              LDR      r0,[r0,#0xc]
000770  f0400040          ORR      r0,r0,#0x40
000774  6821              LDR      r1,[r4,#0]
000776  60c8              STR      r0,[r1,#0xc]
000778  e006              B        |L1.1928|
                  |L1.1914|
;;;1404       }
;;;1405     }
;;;1406     /* DMA Circular mode */
;;;1407     else
;;;1408     {
;;;1409       if(husart->State == HAL_USART_STATE_BUSY_TX)
00077a  f894003d          LDRB     r0,[r4,#0x3d]
00077e  2812              CMP      r0,#0x12
000780  d102              BNE      |L1.1928|
;;;1410       {
;;;1411         HAL_USART_TxCpltCallback(husart);
000782  4620              MOV      r0,r4
000784  f7fffffe          BL       HAL_USART_TxCpltCallback
                  |L1.1928|
;;;1412       }
;;;1413     }
;;;1414   }
000788  bd70              POP      {r4-r6,pc}
;;;1415   
                          ENDP

                  HAL_USART_Transmit_DMA PROC
;;;862      */
;;;863    HAL_StatusTypeDef HAL_USART_Transmit_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint16_t Size)
00078a  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;864    {
00078c  4604              MOV      r4,r0
00078e  4615              MOV      r5,r2
;;;865      uint32_t *tmp=0;
000790  2600              MOVS     r6,#0
;;;866      
;;;867      if(husart->State == HAL_USART_STATE_READY)
000792  f894003d          LDRB     r0,[r4,#0x3d]
000796  2801              CMP      r0,#1
000798  d139              BNE      |L1.2062|
;;;868      {
;;;869        if((pTxData == NULL) || (Size == 0)) 
00079a  9801              LDR      r0,[sp,#4]
00079c  b100              CBZ      r0,|L1.1952|
00079e  b90d              CBNZ     r5,|L1.1956|
                  |L1.1952|
;;;870        {
;;;871          return HAL_ERROR;
0007a0  2001              MOVS     r0,#1
                  |L1.1954|
;;;872        }
;;;873        /* Process Locked */
;;;874        __HAL_LOCK(husart);  
;;;875    
;;;876        husart->pTxBuffPtr = pTxData;
;;;877        husart->TxXferSize = Size;
;;;878        husart->TxXferCount = Size;
;;;879    
;;;880        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;881        husart->State = HAL_USART_STATE_BUSY_TX;
;;;882    
;;;883        /* Set the USART DMA transfer complete callback */
;;;884        husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;885    
;;;886        /* Set the USART DMA Half transfer complete callback */
;;;887        husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;888    
;;;889        /* Set the DMA error callback */
;;;890        husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;891    
;;;892        /* Enable the USART transmit DMA channel */
;;;893        tmp = (uint32_t*)&pTxData;
;;;894        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;895    
;;;896        /* Clear the TC flag in the SR register by writing 0 to it */
;;;897        __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;898    
;;;899        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;900           in the USART CR3 register */
;;;901        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;902    
;;;903        /* Process Unlocked */
;;;904        __HAL_UNLOCK(husart);
;;;905    
;;;906        return HAL_OK;
;;;907      }
;;;908      else
;;;909      {
;;;910        return HAL_BUSY;
;;;911      }
;;;912    }
0007a2  bdfe              POP      {r1-r7,pc}
                  |L1.1956|
0007a4  bf00              NOP                            ;874
0007a6  f894003c          LDRB     r0,[r4,#0x3c]         ;874
0007aa  2801              CMP      r0,#1                 ;874
0007ac  d101              BNE      |L1.1970|
0007ae  2002              MOVS     r0,#2                 ;874
0007b0  e7f7              B        |L1.1954|
                  |L1.1970|
0007b2  2001              MOVS     r0,#1                 ;874
0007b4  f884003c          STRB     r0,[r4,#0x3c]         ;874
0007b8  bf00              NOP                            ;874
0007ba  9801              LDR      r0,[sp,#4]            ;876
0007bc  6260              STR      r0,[r4,#0x24]         ;876
0007be  8525              STRH     r5,[r4,#0x28]         ;877
0007c0  8565              STRH     r5,[r4,#0x2a]         ;878
0007c2  2000              MOVS     r0,#0                 ;880
0007c4  6420              STR      r0,[r4,#0x40]         ;880
0007c6  2012              MOVS     r0,#0x12              ;881
0007c8  f884003d          STRB     r0,[r4,#0x3d]         ;881
0007cc  48fe              LDR      r0,|L1.3016|
0007ce  6b61              LDR      r1,[r4,#0x34]         ;884
0007d0  6288              STR      r0,[r1,#0x28]         ;884
0007d2  48fe              LDR      r0,|L1.3020|
0007d4  6b61              LDR      r1,[r4,#0x34]         ;887
0007d6  62c8              STR      r0,[r1,#0x2c]         ;887
0007d8  48fd              LDR      r0,|L1.3024|
0007da  6b61              LDR      r1,[r4,#0x34]         ;890
0007dc  6308              STR      r0,[r1,#0x30]         ;890
0007de  ae01              ADD      r6,sp,#4              ;893
0007e0  6823              LDR      r3,[r4,#0]            ;894
0007e2  1d1a              ADDS     r2,r3,#4              ;894
0007e4  6831              LDR      r1,[r6,#0]            ;894
0007e6  462b              MOV      r3,r5                 ;894
0007e8  6b60              LDR      r0,[r4,#0x34]         ;894
0007ea  f7fffffe          BL       HAL_DMA_Start_IT
0007ee  f06f0040          MVN      r0,#0x40              ;897
0007f2  6821              LDR      r1,[r4,#0]            ;897
0007f4  6008              STR      r0,[r1,#0]            ;897
0007f6  6820              LDR      r0,[r4,#0]            ;901
0007f8  6940              LDR      r0,[r0,#0x14]         ;901
0007fa  f0400080          ORR      r0,r0,#0x80           ;901
0007fe  6821              LDR      r1,[r4,#0]            ;901
000800  6148              STR      r0,[r1,#0x14]         ;901
000802  bf00              NOP                            ;904
000804  2000              MOVS     r0,#0                 ;904
000806  f884003c          STRB     r0,[r4,#0x3c]         ;904
00080a  bf00              NOP                            ;904
00080c  e7c9              B        |L1.1954|
                  |L1.2062|
00080e  2002              MOVS     r0,#2                 ;910
000810  e7c7              B        |L1.1954|
;;;913    
                          ENDP

                  HAL_USART_RxHalfCpltCallback PROC
;;;1284     */
;;;1285   __weak void HAL_USART_RxHalfCpltCallback(USART_HandleTypeDef *husart)
000812  4770              BX       lr
;;;1286   {
;;;1287     /* Prevent unused argument(s) compilation warning */
;;;1288     UNUSED(husart);
;;;1289     /* NOTE: This function should not be modified, when the callback is needed,
;;;1290              the HAL_USART_RxHalfCpltCallback can be implemented in the user file
;;;1291      */
;;;1292   }
;;;1293   
                          ENDP

                  USART_DMARxHalfCplt PROC
;;;1483     */
;;;1484   static void USART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000814  b570              PUSH     {r4-r6,lr}
;;;1485   {
000816  4604              MOV      r4,r0
;;;1486     USART_HandleTypeDef* husart = (USART_HandleTypeDef*)((DMA_HandleTypeDef*)hdma)->Parent;
000818  6a65              LDR      r5,[r4,#0x24]
;;;1487   
;;;1488     HAL_USART_RxHalfCpltCallback(husart); 
00081a  4628              MOV      r0,r5
00081c  f7fffffe          BL       HAL_USART_RxHalfCpltCallback
;;;1489   }
000820  bd70              POP      {r4-r6,pc}
;;;1490   
                          ENDP

                  HAL_USART_TxRxCpltCallback PROC
;;;1299     */
;;;1300   __weak void HAL_USART_TxRxCpltCallback(USART_HandleTypeDef *husart)
000822  4770              BX       lr
;;;1301   {
;;;1302     /* Prevent unused argument(s) compilation warning */
;;;1303     UNUSED(husart);
;;;1304     /* NOTE: This function should not be modified, when the callback is needed,
;;;1305              the HAL_USART_TxRxCpltCallback can be implemented in the user file
;;;1306      */
;;;1307   }
;;;1308   
                          ENDP

                  HAL_USART_RxCpltCallback PROC
;;;1269     */
;;;1270   __weak void HAL_USART_RxCpltCallback(USART_HandleTypeDef *husart)
000824  4770              BX       lr
;;;1271   {
;;;1272     /* Prevent unused argument(s) compilation warning */
;;;1273     UNUSED(husart);
;;;1274     /* NOTE: This function should not be modified, when the callback is needed,
;;;1275              the HAL_USART_RxCpltCallback can be implemented in the user file
;;;1276      */
;;;1277   }
;;;1278   
                          ENDP

                  USART_DMAReceiveCplt PROC
;;;1434     */
;;;1435   static void USART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000826  b570              PUSH     {r4-r6,lr}
;;;1436   {
000828  4605              MOV      r5,r0
;;;1437     USART_HandleTypeDef* husart = ( USART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
00082a  6a6c              LDR      r4,[r5,#0x24]
;;;1438   
;;;1439     /* DMA Normal mode */
;;;1440     if ( HAL_IS_BIT_CLR(hdma->Instance->CCR, DMA_CCR_CIRC) )
00082c  6828              LDR      r0,[r5,#0]
00082e  6800              LDR      r0,[r0,#0]
000830  f0000020          AND      r0,r0,#0x20
000834  b9f8              CBNZ     r0,|L1.2166|
;;;1441     {
;;;1442       husart->RxXferCount = 0;
000836  2000              MOVS     r0,#0
000838  8660              STRH     r0,[r4,#0x32]
;;;1443       if(husart->State == HAL_USART_STATE_BUSY_RX)
00083a  f894003d          LDRB     r0,[r4,#0x3d]
00083e  2822              CMP      r0,#0x22
000840  d10c              BNE      |L1.2140|
;;;1444       {
;;;1445         /* Disable the DMA transfer for the receiver requests by setting the DMAR bit 
;;;1446            in the USART CR3 register */
;;;1447         CLEAR_BIT(husart->Instance->CR3, USART_CR3_DMAR);
000842  6820              LDR      r0,[r4,#0]
000844  6940              LDR      r0,[r0,#0x14]
000846  f0200040          BIC      r0,r0,#0x40
00084a  6821              LDR      r1,[r4,#0]
00084c  6148              STR      r0,[r1,#0x14]
;;;1448   
;;;1449         husart->State= HAL_USART_STATE_READY;
00084e  2001              MOVS     r0,#1
000850  f884003d          STRB     r0,[r4,#0x3d]
;;;1450         HAL_USART_RxCpltCallback(husart);
000854  4620              MOV      r0,r4
000856  f7fffffe          BL       HAL_USART_RxCpltCallback
00085a  e017              B        |L1.2188|
                  |L1.2140|
;;;1451       }
;;;1452       /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
;;;1453       else
;;;1454       {
;;;1455         /* Disable the DMA transfer for the Transmit/receiver requests by setting the DMAT/DMAR bit 
;;;1456            in the USART CR3 register */
;;;1457         CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
00085c  6820              LDR      r0,[r4,#0]
00085e  6940              LDR      r0,[r0,#0x14]
000860  f02000c0          BIC      r0,r0,#0xc0
000864  6821              LDR      r1,[r4,#0]
000866  6148              STR      r0,[r1,#0x14]
;;;1458   
;;;1459         husart->State= HAL_USART_STATE_READY;
000868  2001              MOVS     r0,#1
00086a  f884003d          STRB     r0,[r4,#0x3d]
;;;1460         HAL_USART_TxRxCpltCallback(husart);
00086e  4620              MOV      r0,r4
000870  f7fffffe          BL       HAL_USART_TxRxCpltCallback
000874  e00a              B        |L1.2188|
                  |L1.2166|
;;;1461       }
;;;1462     }
;;;1463     /* DMA circular mode */
;;;1464     else
;;;1465     {
;;;1466       if(husart->State == HAL_USART_STATE_BUSY_RX)
000876  f894003d          LDRB     r0,[r4,#0x3d]
00087a  2822              CMP      r0,#0x22
00087c  d103              BNE      |L1.2182|
;;;1467       {
;;;1468         HAL_USART_RxCpltCallback(husart);
00087e  4620              MOV      r0,r4
000880  f7fffffe          BL       HAL_USART_RxCpltCallback
000884  e002              B        |L1.2188|
                  |L1.2182|
;;;1469       }
;;;1470       /* the usart state is HAL_USART_STATE_BUSY_TX_RX*/
;;;1471       else
;;;1472       {
;;;1473         HAL_USART_TxRxCpltCallback(husart);
000886  4620              MOV      r0,r4
000888  f7fffffe          BL       HAL_USART_TxRxCpltCallback
                  |L1.2188|
;;;1474       }
;;;1475     }
;;;1476   }
00088c  bd70              POP      {r4-r6,pc}
;;;1477   
                          ENDP

                  HAL_USART_Receive_DMA PROC
;;;923      */
;;;924    HAL_StatusTypeDef HAL_USART_Receive_DMA(USART_HandleTypeDef *husart, uint8_t *pRxData, uint16_t Size)
00088e  b577              PUSH     {r0-r2,r4-r6,lr}
;;;925    {
000890  b081              SUB      sp,sp,#4
000892  4604              MOV      r4,r0
000894  4615              MOV      r5,r2
;;;926      uint32_t *tmp=0;
000896  2600              MOVS     r6,#0
;;;927      
;;;928      if(husart->State == HAL_USART_STATE_READY)
000898  f894003d          LDRB     r0,[r4,#0x3d]
00089c  2801              CMP      r0,#1
00089e  d14e              BNE      |L1.2366|
;;;929      {
;;;930        if((pRxData == NULL) || (Size == 0)) 
0008a0  9802              LDR      r0,[sp,#8]
0008a2  b100              CBZ      r0,|L1.2214|
0008a4  b915              CBNZ     r5,|L1.2220|
                  |L1.2214|
;;;931        {
;;;932          return HAL_ERROR;
0008a6  2001              MOVS     r0,#1
                  |L1.2216|
;;;933        }
;;;934    
;;;935        /* Process Locked */
;;;936        __HAL_LOCK(husart);
;;;937    
;;;938        husart->pRxBuffPtr = pRxData;
;;;939        husart->RxXferSize = Size;
;;;940        husart->pTxBuffPtr = pRxData;
;;;941        husart->TxXferSize = Size;
;;;942    
;;;943        husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;944        husart->State = HAL_USART_STATE_BUSY_RX;
;;;945    
;;;946        /* Set the USART DMA Rx transfer complete callback */
;;;947        husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;948    
;;;949        /* Set the USART DMA Half transfer complete callback */
;;;950        husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;951    
;;;952        /* Set the USART DMA Rx transfer error callback */
;;;953        husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;954    
;;;955        /* Enable the USART receive DMA channel */
;;;956        tmp = (uint32_t*)&pRxData;
;;;957        HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;958    
;;;959        /* Enable the USART transmit DMA channel: the transmit channel is used in order
;;;960           to generate in the non-blocking mode the clock to the slave device, 
;;;961           this mode isn't a simplex receive mode but a full-duplex receive one */
;;;962        HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;963    
;;;964        /* Clear the Overrun flag just before enabling the DMA Rx request: mandatory for the second transfer
;;;965           when using the USART in circular mode */
;;;966        __HAL_USART_CLEAR_OREFLAG(husart);
;;;967        
;;;968        /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;969           in the USART CR3 register */
;;;970        SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;971    
;;;972        /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;973           in the USART CR3 register */
;;;974        SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;975    
;;;976        /* Process Unlocked */
;;;977        __HAL_UNLOCK(husart);
;;;978    
;;;979        return HAL_OK;
;;;980      }
;;;981      else
;;;982      {
;;;983        return HAL_BUSY;
;;;984      }
;;;985    }
0008a8  b004              ADD      sp,sp,#0x10
0008aa  bd70              POP      {r4-r6,pc}
                  |L1.2220|
0008ac  bf00              NOP                            ;936
0008ae  f894003c          LDRB     r0,[r4,#0x3c]         ;936
0008b2  2801              CMP      r0,#1                 ;936
0008b4  d101              BNE      |L1.2234|
0008b6  2002              MOVS     r0,#2                 ;936
0008b8  e7f6              B        |L1.2216|
                  |L1.2234|
0008ba  2001              MOVS     r0,#1                 ;936
0008bc  f884003c          STRB     r0,[r4,#0x3c]         ;936
0008c0  bf00              NOP                            ;936
0008c2  9802              LDR      r0,[sp,#8]            ;938
0008c4  62e0              STR      r0,[r4,#0x2c]         ;938
0008c6  8625              STRH     r5,[r4,#0x30]         ;939
0008c8  9802              LDR      r0,[sp,#8]            ;940
0008ca  6260              STR      r0,[r4,#0x24]         ;940
0008cc  8525              STRH     r5,[r4,#0x28]         ;941
0008ce  2000              MOVS     r0,#0                 ;943
0008d0  6420              STR      r0,[r4,#0x40]         ;943
0008d2  2022              MOVS     r0,#0x22              ;944
0008d4  f884003d          STRB     r0,[r4,#0x3d]         ;944
0008d8  48be              LDR      r0,|L1.3028|
0008da  6ba1              LDR      r1,[r4,#0x38]         ;947
0008dc  6288              STR      r0,[r1,#0x28]         ;947
0008de  48be              LDR      r0,|L1.3032|
0008e0  6ba1              LDR      r1,[r4,#0x38]         ;950
0008e2  62c8              STR      r0,[r1,#0x2c]         ;950
0008e4  48ba              LDR      r0,|L1.3024|
0008e6  6ba1              LDR      r1,[r4,#0x38]         ;953
0008e8  6308              STR      r0,[r1,#0x30]         ;953
0008ea  ae02              ADD      r6,sp,#8              ;956
0008ec  6832              LDR      r2,[r6,#0]            ;957
0008ee  6823              LDR      r3,[r4,#0]            ;957
0008f0  1d19              ADDS     r1,r3,#4              ;957
0008f2  462b              MOV      r3,r5                 ;957
0008f4  6ba0              LDR      r0,[r4,#0x38]         ;957
0008f6  f7fffffe          BL       HAL_DMA_Start_IT
0008fa  6823              LDR      r3,[r4,#0]            ;962
0008fc  1d1a              ADDS     r2,r3,#4              ;962
0008fe  6831              LDR      r1,[r6,#0]            ;962
000900  462b              MOV      r3,r5                 ;962
000902  6b60              LDR      r0,[r4,#0x34]         ;962
000904  f7fffffe          BL       HAL_DMA_Start_IT
000908  bf00              NOP                            ;966
00090a  6820              LDR      r0,[r4,#0]            ;966
00090c  6800              LDR      r0,[r0,#0]            ;966
00090e  9000              STR      r0,[sp,#0]            ;966
000910  6820              LDR      r0,[r4,#0]            ;966
000912  6840              LDR      r0,[r0,#4]            ;966
000914  9000              STR      r0,[sp,#0]            ;966
000916  bf00              NOP                            ;966
000918  bf00              NOP                            ;966
00091a  6820              LDR      r0,[r4,#0]            ;970
00091c  6940              LDR      r0,[r0,#0x14]         ;970
00091e  f0400040          ORR      r0,r0,#0x40           ;970
000922  6821              LDR      r1,[r4,#0]            ;970
000924  6148              STR      r0,[r1,#0x14]         ;970
000926  6820              LDR      r0,[r4,#0]            ;974
000928  6940              LDR      r0,[r0,#0x14]         ;974
00092a  f0400080          ORR      r0,r0,#0x80           ;974
00092e  6821              LDR      r1,[r4,#0]            ;974
000930  6148              STR      r0,[r1,#0x14]         ;974
000932  bf00              NOP                            ;977
000934  2000              MOVS     r0,#0                 ;977
000936  f884003c          STRB     r0,[r4,#0x3c]         ;977
00093a  bf00              NOP                            ;977
00093c  e7b4              B        |L1.2216|
                  |L1.2366|
00093e  2002              MOVS     r0,#2                 ;983
000940  e7b2              B        |L1.2216|
;;;986    
                          ENDP

                  HAL_USART_TransmitReceive_DMA PROC
;;;996      */
;;;997    HAL_StatusTypeDef HAL_USART_TransmitReceive_DMA(USART_HandleTypeDef *husart, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size)
000942  b57f              PUSH     {r0-r6,lr}
;;;998    {
000944  b082              SUB      sp,sp,#8
000946  4604              MOV      r4,r0
000948  461d              MOV      r5,r3
;;;999      uint32_t *tmp=0;
00094a  2600              MOVS     r6,#0
;;;1000     
;;;1001     if(husart->State == HAL_USART_STATE_READY)
00094c  f894003d          LDRB     r0,[r4,#0x3d]
000950  2801              CMP      r0,#1
000952  d15d              BNE      |L1.2576|
;;;1002     {
;;;1003       if((pTxData == NULL) || (pRxData == NULL) || (Size == 0)) 
000954  9803              LDR      r0,[sp,#0xc]
000956  b110              CBZ      r0,|L1.2398|
000958  9804              LDR      r0,[sp,#0x10]
00095a  b100              CBZ      r0,|L1.2398|
00095c  b915              CBNZ     r5,|L1.2404|
                  |L1.2398|
;;;1004       {
;;;1005         return HAL_ERROR;
00095e  2001              MOVS     r0,#1
                  |L1.2400|
;;;1006       }
;;;1007       /* Process Locked */
;;;1008       __HAL_LOCK(husart);
;;;1009   
;;;1010       husart->pRxBuffPtr = pRxData;
;;;1011       husart->RxXferSize = Size;
;;;1012       husart->pTxBuffPtr = pTxData;
;;;1013       husart->TxXferSize = Size;
;;;1014   
;;;1015       husart->ErrorCode = HAL_USART_ERROR_NONE;
;;;1016       husart->State = HAL_USART_STATE_BUSY_TX_RX;
;;;1017   
;;;1018       /* Set the USART DMA Rx transfer complete callback */
;;;1019       husart->hdmarx->XferCpltCallback = USART_DMAReceiveCplt;
;;;1020   
;;;1021       /* Set the USART DMA Half transfer complete callback */
;;;1022       husart->hdmarx->XferHalfCpltCallback = USART_DMARxHalfCplt;
;;;1023   
;;;1024       /* Set the USART DMA Tx transfer complete callback */
;;;1025       husart->hdmatx->XferCpltCallback = USART_DMATransmitCplt;
;;;1026   
;;;1027       /* Set the USART DMA Half transfer complete callback */
;;;1028       husart->hdmatx->XferHalfCpltCallback = USART_DMATxHalfCplt;
;;;1029   
;;;1030       /* Set the USART DMA Tx transfer error callback */
;;;1031       husart->hdmatx->XferErrorCallback = USART_DMAError;
;;;1032   
;;;1033       /* Set the USART DMA Rx transfer error callback */
;;;1034       husart->hdmarx->XferErrorCallback = USART_DMAError;
;;;1035   
;;;1036       /* Enable the USART receive DMA channel */
;;;1037       tmp = (uint32_t*)&pRxData;
;;;1038       HAL_DMA_Start_IT(husart->hdmarx, (uint32_t)&husart->Instance->DR, *(uint32_t*)tmp, Size);
;;;1039   
;;;1040       /* Enable the USART transmit DMA channel */
;;;1041       tmp = (uint32_t*)&pTxData;
;;;1042       HAL_DMA_Start_IT(husart->hdmatx, *(uint32_t*)tmp, (uint32_t)&husart->Instance->DR, Size);
;;;1043       
;;;1044       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1045       __HAL_USART_CLEAR_FLAG(husart, USART_FLAG_TC);
;;;1046   
;;;1047       /* Clear the Overrun flag: mandatory for the second transfer in circular mode */
;;;1048       __HAL_USART_CLEAR_OREFLAG(husart);
;;;1049       
;;;1050       /* Enable the DMA transfer for the receiver request by setting the DMAR bit 
;;;1051          in the USART CR3 register */
;;;1052       SET_BIT(husart->Instance->CR3, USART_CR3_DMAR);
;;;1053   
;;;1054       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1055          in the USART CR3 register */
;;;1056       SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1057   
;;;1058       /* Process Unlocked */
;;;1059       __HAL_UNLOCK(husart);
;;;1060   
;;;1061       return HAL_OK;
;;;1062     }
;;;1063     else
;;;1064     {
;;;1065       return HAL_BUSY;
;;;1066     }
;;;1067   }
000960  b006              ADD      sp,sp,#0x18
000962  bd70              POP      {r4-r6,pc}
                  |L1.2404|
000964  bf00              NOP                            ;1008
000966  f894003c          LDRB     r0,[r4,#0x3c]         ;1008
00096a  2801              CMP      r0,#1                 ;1008
00096c  d101              BNE      |L1.2418|
00096e  2002              MOVS     r0,#2                 ;1008
000970  e7f6              B        |L1.2400|
                  |L1.2418|
000972  2001              MOVS     r0,#1                 ;1008
000974  f884003c          STRB     r0,[r4,#0x3c]         ;1008
000978  bf00              NOP                            ;1008
00097a  9804              LDR      r0,[sp,#0x10]         ;1010
00097c  62e0              STR      r0,[r4,#0x2c]         ;1010
00097e  8625              STRH     r5,[r4,#0x30]         ;1011
000980  9803              LDR      r0,[sp,#0xc]          ;1012
000982  6260              STR      r0,[r4,#0x24]         ;1012
000984  8525              STRH     r5,[r4,#0x28]         ;1013
000986  2000              MOVS     r0,#0                 ;1015
000988  6420              STR      r0,[r4,#0x40]         ;1015
00098a  2032              MOVS     r0,#0x32              ;1016
00098c  f884003d          STRB     r0,[r4,#0x3d]         ;1016
000990  4890              LDR      r0,|L1.3028|
000992  6ba1              LDR      r1,[r4,#0x38]         ;1019
000994  6288              STR      r0,[r1,#0x28]         ;1019
000996  4890              LDR      r0,|L1.3032|
000998  6ba1              LDR      r1,[r4,#0x38]         ;1022
00099a  62c8              STR      r0,[r1,#0x2c]         ;1022
00099c  488a              LDR      r0,|L1.3016|
00099e  6b61              LDR      r1,[r4,#0x34]         ;1025
0009a0  6288              STR      r0,[r1,#0x28]         ;1025
0009a2  488a              LDR      r0,|L1.3020|
0009a4  6b61              LDR      r1,[r4,#0x34]         ;1028
0009a6  62c8              STR      r0,[r1,#0x2c]         ;1028
0009a8  4889              LDR      r0,|L1.3024|
0009aa  6b61              LDR      r1,[r4,#0x34]         ;1031
0009ac  6308              STR      r0,[r1,#0x30]         ;1031
0009ae  6ba1              LDR      r1,[r4,#0x38]         ;1034
0009b0  6308              STR      r0,[r1,#0x30]         ;1034
0009b2  ae04              ADD      r6,sp,#0x10           ;1037
0009b4  6832              LDR      r2,[r6,#0]            ;1038
0009b6  6823              LDR      r3,[r4,#0]            ;1038
0009b8  1d19              ADDS     r1,r3,#4              ;1038
0009ba  462b              MOV      r3,r5                 ;1038
0009bc  6ba0              LDR      r0,[r4,#0x38]         ;1038
0009be  f7fffffe          BL       HAL_DMA_Start_IT
0009c2  ae03              ADD      r6,sp,#0xc            ;1041
0009c4  6823              LDR      r3,[r4,#0]            ;1042
0009c6  1d1a              ADDS     r2,r3,#4              ;1042
0009c8  6831              LDR      r1,[r6,#0]            ;1042
0009ca  462b              MOV      r3,r5                 ;1042
0009cc  6b60              LDR      r0,[r4,#0x34]         ;1042
0009ce  f7fffffe          BL       HAL_DMA_Start_IT
0009d2  f06f0040          MVN      r0,#0x40              ;1045
0009d6  6821              LDR      r1,[r4,#0]            ;1045
0009d8  6008              STR      r0,[r1,#0]            ;1045
0009da  bf00              NOP                            ;1048
0009dc  6820              LDR      r0,[r4,#0]            ;1048
0009de  6800              LDR      r0,[r0,#0]            ;1048
0009e0  9001              STR      r0,[sp,#4]            ;1048
0009e2  6820              LDR      r0,[r4,#0]            ;1048
0009e4  6840              LDR      r0,[r0,#4]            ;1048
0009e6  9001              STR      r0,[sp,#4]            ;1048
0009e8  bf00              NOP                            ;1048
0009ea  bf00              NOP                            ;1048
0009ec  6820              LDR      r0,[r4,#0]            ;1052
0009ee  6940              LDR      r0,[r0,#0x14]         ;1052
0009f0  f0400040          ORR      r0,r0,#0x40           ;1052
0009f4  6821              LDR      r1,[r4,#0]            ;1052
0009f6  6148              STR      r0,[r1,#0x14]         ;1052
0009f8  6820              LDR      r0,[r4,#0]            ;1056
0009fa  6940              LDR      r0,[r0,#0x14]         ;1056
0009fc  f0400080          ORR      r0,r0,#0x80           ;1056
000a00  6821              LDR      r1,[r4,#0]            ;1056
000a02  6148              STR      r0,[r1,#0x14]         ;1056
000a04  bf00              NOP                            ;1059
000a06  2000              MOVS     r0,#0                 ;1059
000a08  f884003c          STRB     r0,[r4,#0x3c]         ;1059
000a0c  bf00              NOP                            ;1059
000a0e  e7a7              B        |L1.2400|
                  |L1.2576|
000a10  2002              MOVS     r0,#2                 ;1065
000a12  e7a5              B        |L1.2400|
;;;1068   
                          ENDP

                  HAL_USART_DMAPause PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_USART_DMAPause(USART_HandleTypeDef *husart)
000a14  4601              MOV      r1,r0
;;;1076   {
;;;1077     /* Process Locked */
;;;1078     __HAL_LOCK(husart);
000a16  bf00              NOP      
000a18  f891003c          LDRB     r0,[r1,#0x3c]
000a1c  2801              CMP      r0,#1
000a1e  d101              BNE      |L1.2596|
000a20  2002              MOVS     r0,#2
                  |L1.2594|
;;;1079     
;;;1080     /* Disable the USART DMA Tx request */
;;;1081     CLEAR_BIT(husart->Instance->CR3, (uint32_t)(USART_CR3_DMAT));
;;;1082     
;;;1083     /* Process Unlocked */
;;;1084     __HAL_UNLOCK(husart);
;;;1085   
;;;1086     return HAL_OK; 
;;;1087   }
000a22  4770              BX       lr
                  |L1.2596|
000a24  2001              MOVS     r0,#1                 ;1078
000a26  f881003c          STRB     r0,[r1,#0x3c]         ;1078
000a2a  bf00              NOP                            ;1078
000a2c  6808              LDR      r0,[r1,#0]            ;1081
000a2e  6940              LDR      r0,[r0,#0x14]         ;1081
000a30  f0200080          BIC      r0,r0,#0x80           ;1081
000a34  680a              LDR      r2,[r1,#0]            ;1081
000a36  6150              STR      r0,[r2,#0x14]         ;1081
000a38  bf00              NOP                            ;1084
000a3a  2000              MOVS     r0,#0                 ;1084
000a3c  f881003c          STRB     r0,[r1,#0x3c]         ;1084
000a40  bf00              NOP                            ;1084
000a42  bf00              NOP                            ;1086
000a44  e7ed              B        |L1.2594|
;;;1088   
                          ENDP

                  HAL_USART_DMAResume PROC
;;;1094     */
;;;1095   HAL_StatusTypeDef HAL_USART_DMAResume(USART_HandleTypeDef *husart)
000a46  4601              MOV      r1,r0
;;;1096   {
;;;1097     /* Process Locked */
;;;1098     __HAL_LOCK(husart);
000a48  bf00              NOP      
000a4a  f891003c          LDRB     r0,[r1,#0x3c]
000a4e  2801              CMP      r0,#1
000a50  d101              BNE      |L1.2646|
000a52  2002              MOVS     r0,#2
                  |L1.2644|
;;;1099     
;;;1100     /* Enable the USART DMA Tx request */
;;;1101     SET_BIT(husart->Instance->CR3, USART_CR3_DMAT);
;;;1102     
;;;1103     /* Process Unlocked */
;;;1104     __HAL_UNLOCK(husart);
;;;1105   
;;;1106     return HAL_OK;
;;;1107   }
000a54  4770              BX       lr
                  |L1.2646|
000a56  2001              MOVS     r0,#1                 ;1098
000a58  f881003c          STRB     r0,[r1,#0x3c]         ;1098
000a5c  bf00              NOP                            ;1098
000a5e  6808              LDR      r0,[r1,#0]            ;1101
000a60  6940              LDR      r0,[r0,#0x14]         ;1101
000a62  f0400080          ORR      r0,r0,#0x80           ;1101
000a66  680a              LDR      r2,[r1,#0]            ;1101
000a68  6150              STR      r0,[r2,#0x14]         ;1101
000a6a  bf00              NOP                            ;1104
000a6c  2000              MOVS     r0,#0                 ;1104
000a6e  f881003c          STRB     r0,[r1,#0x3c]         ;1104
000a72  bf00              NOP                            ;1104
000a74  bf00              NOP                            ;1106
000a76  e7ed              B        |L1.2644|
;;;1108   
                          ENDP

                  HAL_USART_DMAStop PROC
;;;1114     */
;;;1115   HAL_StatusTypeDef HAL_USART_DMAStop(USART_HandleTypeDef *husart)
000a78  b510              PUSH     {r4,lr}
;;;1116   {
000a7a  4604              MOV      r4,r0
;;;1117     /* The Lock is not implemented on this API to allow the user application
;;;1118        to call the HAL USART API under callbacks HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback():
;;;1119        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1120        and the correspond call back is executed HAL_USART_TxCpltCallback() / HAL_USART_RxCpltCallback()
;;;1121        */
;;;1122   
;;;1123     /* Abort the USART DMA Tx channel */
;;;1124     if(husart->hdmatx != NULL)
000a7c  6b60              LDR      r0,[r4,#0x34]
000a7e  b110              CBZ      r0,|L1.2694|
;;;1125     {
;;;1126       HAL_DMA_Abort(husart->hdmatx);
000a80  6b60              LDR      r0,[r4,#0x34]
000a82  f7fffffe          BL       HAL_DMA_Abort
                  |L1.2694|
;;;1127     }
;;;1128     /* Abort the USART DMA Rx channel */
;;;1129     if(husart->hdmarx != NULL)
000a86  6ba0              LDR      r0,[r4,#0x38]
000a88  b110              CBZ      r0,|L1.2704|
;;;1130     {  
;;;1131       HAL_DMA_Abort(husart->hdmarx);
000a8a  6ba0              LDR      r0,[r4,#0x38]
000a8c  f7fffffe          BL       HAL_DMA_Abort
                  |L1.2704|
;;;1132     }
;;;1133     
;;;1134     /* Disable the USART Tx/Rx DMA requests */
;;;1135     CLEAR_BIT(husart->Instance->CR3, (USART_CR3_DMAT | USART_CR3_DMAR));
000a90  6820              LDR      r0,[r4,#0]
000a92  6940              LDR      r0,[r0,#0x14]
000a94  f02000c0          BIC      r0,r0,#0xc0
000a98  6821              LDR      r1,[r4,#0]
000a9a  6148              STR      r0,[r1,#0x14]
;;;1136   
;;;1137     husart->State = HAL_USART_STATE_READY;
000a9c  2001              MOVS     r0,#1
000a9e  f884003d          STRB     r0,[r4,#0x3d]
;;;1138   
;;;1139     return HAL_OK;
000aa2  2000              MOVS     r0,#0
;;;1140   }
000aa4  bd10              POP      {r4,pc}
;;;1141   
                          ENDP

                  USART_EndTransmit_IT PROC
;;;1632     */
;;;1633   static HAL_StatusTypeDef USART_EndTransmit_IT(USART_HandleTypeDef *husart)
000aa6  b510              PUSH     {r4,lr}
;;;1634   {
000aa8  4604              MOV      r4,r0
;;;1635     /* Disable the USART Transmit Complete Interrupt */    
;;;1636     __HAL_USART_DISABLE_IT(husart, USART_IT_TC);
000aaa  6820              LDR      r0,[r4,#0]
000aac  68c0              LDR      r0,[r0,#0xc]
000aae  f0200040          BIC      r0,r0,#0x40
000ab2  6821              LDR      r1,[r4,#0]
000ab4  60c8              STR      r0,[r1,#0xc]
;;;1637     
;;;1638     /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1639     __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000ab6  6820              LDR      r0,[r4,#0]
000ab8  6940              LDR      r0,[r0,#0x14]
000aba  f0200001          BIC      r0,r0,#1
000abe  6821              LDR      r1,[r4,#0]
000ac0  6148              STR      r0,[r1,#0x14]
;;;1640       
;;;1641     husart->State = HAL_USART_STATE_READY;
000ac2  2001              MOVS     r0,#1
000ac4  f884003d          STRB     r0,[r4,#0x3d]
;;;1642      
;;;1643     HAL_USART_TxCpltCallback(husart);
000ac8  4620              MOV      r0,r4
000aca  f7fffffe          BL       HAL_USART_TxCpltCallback
;;;1644     
;;;1645     return HAL_OK;
000ace  2000              MOVS     r0,#0
;;;1646   }
000ad0  bd10              POP      {r4,pc}
;;;1647   
                          ENDP

                  USART_TransmitReceive_IT PROC
;;;1726     */
;;;1727   static HAL_StatusTypeDef USART_TransmitReceive_IT(USART_HandleTypeDef *husart)
000ad2  b570              PUSH     {r4-r6,lr}
;;;1728   {
000ad4  4604              MOV      r4,r0
;;;1729     uint16_t* tmp=0;
000ad6  2500              MOVS     r5,#0
;;;1730   
;;;1731     if(husart->State == HAL_USART_STATE_BUSY_TX_RX)
000ad8  f894003d          LDRB     r0,[r4,#0x3d]
000adc  2832              CMP      r0,#0x32
000ade  d17d              BNE      |L1.3036|
;;;1732     {
;;;1733       if(husart->TxXferCount != 0x00)
000ae0  8d60              LDRH     r0,[r4,#0x2a]
000ae2  b348              CBZ      r0,|L1.2872|
;;;1734       {
;;;1735         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_TXE) != RESET)
000ae4  6820              LDR      r0,[r4,#0]
000ae6  6800              LDR      r0,[r0,#0]
000ae8  f3c010c0          UBFX     r0,r0,#7,#1
000aec  b320              CBZ      r0,|L1.2872|
;;;1736         {
;;;1737           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
000aee  68a0              LDR      r0,[r4,#8]
000af0  f5b05f80          CMP      r0,#0x1000
000af4  d10f              BNE      |L1.2838|
;;;1738           {
;;;1739             tmp = (uint16_t*) husart->pTxBuffPtr;
000af6  6a65              LDR      r5,[r4,#0x24]
;;;1740             WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
000af8  8828              LDRH     r0,[r5,#0]
000afa  f3c00008          UBFX     r0,r0,#0,#9
000afe  6821              LDR      r1,[r4,#0]
000b00  6048              STR      r0,[r1,#4]
;;;1741             if(husart->Init.Parity == USART_PARITY_NONE)
000b02  6920              LDR      r0,[r4,#0x10]
000b04  b918              CBNZ     r0,|L1.2830|
;;;1742             {
;;;1743               husart->pTxBuffPtr += 2;
000b06  6a60              LDR      r0,[r4,#0x24]
000b08  1c80              ADDS     r0,r0,#2
000b0a  6260              STR      r0,[r4,#0x24]
000b0c  e009              B        |L1.2850|
                  |L1.2830|
;;;1744             }
;;;1745             else
;;;1746             {
;;;1747               husart->pTxBuffPtr += 1;
000b0e  6a60              LDR      r0,[r4,#0x24]
000b10  1c40              ADDS     r0,r0,#1
000b12  6260              STR      r0,[r4,#0x24]
000b14  e005              B        |L1.2850|
                  |L1.2838|
;;;1748             }
;;;1749           } 
;;;1750           else
;;;1751           {
;;;1752             WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
000b16  6a61              LDR      r1,[r4,#0x24]
000b18  1c48              ADDS     r0,r1,#1
000b1a  6260              STR      r0,[r4,#0x24]
000b1c  7808              LDRB     r0,[r1,#0]
000b1e  6821              LDR      r1,[r4,#0]
000b20  6048              STR      r0,[r1,#4]
                  |L1.2850|
;;;1753           }
;;;1754           husart->TxXferCount--;
000b22  8d60              LDRH     r0,[r4,#0x2a]
000b24  1e40              SUBS     r0,r0,#1
000b26  8560              STRH     r0,[r4,#0x2a]
;;;1755   
;;;1756           /* Check the latest data transmitted */
;;;1757           if(husart->TxXferCount == 0)
000b28  8d60              LDRH     r0,[r4,#0x2a]
000b2a  b928              CBNZ     r0,|L1.2872|
;;;1758           {
;;;1759              __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000b2c  6820              LDR      r0,[r4,#0]
000b2e  68c0              LDR      r0,[r0,#0xc]
000b30  f0200080          BIC      r0,r0,#0x80
000b34  6821              LDR      r1,[r4,#0]
000b36  60c8              STR      r0,[r1,#0xc]
                  |L1.2872|
;;;1760           }
;;;1761         }
;;;1762       }
;;;1763   
;;;1764       if(husart->RxXferCount != 0x00)
000b38  8e60              LDRH     r0,[r4,#0x32]
000b3a  b388              CBZ      r0,|L1.2976|
;;;1765       {
;;;1766         if(__HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE) != RESET)
000b3c  6820              LDR      r0,[r4,#0]
000b3e  6800              LDR      r0,[r0,#0]
000b40  f3c01040          UBFX     r0,r0,#5,#1
000b44  b360              CBZ      r0,|L1.2976|
;;;1767         {
;;;1768           if(husart->Init.WordLength == USART_WORDLENGTH_9B)
000b46  68a0              LDR      r0,[r4,#8]
000b48  f5b05f80          CMP      r0,#0x1000
000b4c  d113              BNE      |L1.2934|
;;;1769           {
;;;1770             tmp = (uint16_t*) husart->pRxBuffPtr;
000b4e  6ae5              LDR      r5,[r4,#0x2c]
;;;1771             if(husart->Init.Parity == USART_PARITY_NONE)
000b50  6920              LDR      r0,[r4,#0x10]
000b52  b940              CBNZ     r0,|L1.2918|
;;;1772             {
;;;1773               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
000b54  6820              LDR      r0,[r4,#0]
000b56  6840              LDR      r0,[r0,#4]
000b58  f3c00008          UBFX     r0,r0,#0,#9
000b5c  8028              STRH     r0,[r5,#0]
;;;1774               husart->pRxBuffPtr += 2;
000b5e  6ae0              LDR      r0,[r4,#0x2c]
000b60  1c80              ADDS     r0,r0,#2
000b62  62e0              STR      r0,[r4,#0x2c]
000b64  e019              B        |L1.2970|
                  |L1.2918|
;;;1775             }
;;;1776             else
;;;1777             {
;;;1778               *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
000b66  6820              LDR      r0,[r4,#0]
000b68  6840              LDR      r0,[r0,#4]
000b6a  b2c0              UXTB     r0,r0
000b6c  8028              STRH     r0,[r5,#0]
;;;1779               husart->pRxBuffPtr += 1;
000b6e  6ae0              LDR      r0,[r4,#0x2c]
000b70  1c40              ADDS     r0,r0,#1
000b72  62e0              STR      r0,[r4,#0x2c]
000b74  e011              B        |L1.2970|
                  |L1.2934|
;;;1780             }
;;;1781           } 
;;;1782           else
;;;1783           {
;;;1784             if(husart->Init.Parity == USART_PARITY_NONE)
000b76  6920              LDR      r0,[r4,#0x10]
000b78  b938              CBNZ     r0,|L1.2954|
;;;1785             {
;;;1786               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
000b7a  6820              LDR      r0,[r4,#0]
000b7c  6840              LDR      r0,[r0,#4]
000b7e  b2c1              UXTB     r1,r0
000b80  6ae2              LDR      r2,[r4,#0x2c]
000b82  1c50              ADDS     r0,r2,#1
000b84  62e0              STR      r0,[r4,#0x2c]
000b86  7011              STRB     r1,[r2,#0]
000b88  e007              B        |L1.2970|
                  |L1.2954|
;;;1787             }
;;;1788             else
;;;1789             {
;;;1790               *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
000b8a  6820              LDR      r0,[r4,#0]
000b8c  6840              LDR      r0,[r0,#4]
000b8e  f000017f          AND      r1,r0,#0x7f
000b92  6ae2              LDR      r2,[r4,#0x2c]
000b94  1c50              ADDS     r0,r2,#1
000b96  62e0              STR      r0,[r4,#0x2c]
000b98  7011              STRB     r1,[r2,#0]
                  |L1.2970|
;;;1791             }
;;;1792           }
;;;1793           husart->RxXferCount--;
000b9a  8e60              LDRH     r0,[r4,#0x32]
000b9c  1e40              SUBS     r0,r0,#1
000b9e  8660              STRH     r0,[r4,#0x32]
                  |L1.2976|
;;;1794         }
;;;1795       }
;;;1796   
;;;1797       /* Check the latest data received */
;;;1798       if(husart->RxXferCount == 0)
000ba0  8e60              LDRH     r0,[r4,#0x32]
000ba2  bb28              CBNZ     r0,|L1.3056|
;;;1799       {
;;;1800         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000ba4  6820              LDR      r0,[r4,#0]
000ba6  68c0              LDR      r0,[r0,#0xc]
000ba8  f0200020          BIC      r0,r0,#0x20
000bac  6821              LDR      r1,[r4,#0]
000bae  60c8              STR      r0,[r1,#0xc]
;;;1801   
;;;1802         /* Disable the USART Parity Error Interrupt */
;;;1803         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
000bb0  6820              LDR      r0,[r4,#0]
000bb2  68c0              LDR      r0,[r0,#0xc]
000bb4  f4207080          BIC      r0,r0,#0x100
000bb8  6821              LDR      r1,[r4,#0]
000bba  60c8              STR      r0,[r1,#0xc]
;;;1804   
;;;1805         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1806         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000bbc  6820              LDR      r0,[r4,#0]
000bbe  6940              LDR      r0,[r0,#0x14]
000bc0  f0200001          BIC      r0,r0,#1
000bc4  6821              LDR      r1,[r4,#0]
000bc6  e00a              B        |L1.3038|
                  |L1.3016|
                          DCD      USART_DMATransmitCplt
                  |L1.3020|
                          DCD      USART_DMATxHalfCplt
                  |L1.3024|
                          DCD      USART_DMAError
                  |L1.3028|
                          DCD      USART_DMAReceiveCplt
                  |L1.3032|
                          DCD      USART_DMARxHalfCplt
                  |L1.3036|
000bdc  e00a              B        |L1.3060|
                  |L1.3038|
000bde  6148              STR      r0,[r1,#0x14]
;;;1807   
;;;1808         husart->State = HAL_USART_STATE_READY;
000be0  2001              MOVS     r0,#1
000be2  f884003d          STRB     r0,[r4,#0x3d]
;;;1809   
;;;1810         HAL_USART_TxRxCpltCallback(husart);
000be6  4620              MOV      r0,r4
000be8  f7fffffe          BL       HAL_USART_TxRxCpltCallback
;;;1811   
;;;1812         return HAL_OK;
000bec  2000              MOVS     r0,#0
                  |L1.3054|
;;;1813       }
;;;1814   
;;;1815       return HAL_OK;
;;;1816     }
;;;1817     else
;;;1818     {
;;;1819       return HAL_BUSY; 
;;;1820     }
;;;1821   }
000bee  bd70              POP      {r4-r6,pc}
                  |L1.3056|
000bf0  2000              MOVS     r0,#0                 ;1815
000bf2  e7fc              B        |L1.3054|
                  |L1.3060|
000bf4  2002              MOVS     r0,#2                 ;1819
000bf6  e7fa              B        |L1.3054|
;;;1822   
                          ENDP

                  USART_Transmit_IT PROC
;;;1585     */
;;;1586   static HAL_StatusTypeDef USART_Transmit_IT(USART_HandleTypeDef *husart)
000bf8  4601              MOV      r1,r0
;;;1587   {
;;;1588     uint16_t* tmp=0;
000bfa  2200              MOVS     r2,#0
;;;1589    
;;;1590     if(husart->State == HAL_USART_STATE_BUSY_TX)
000bfc  f891003d          LDRB     r0,[r1,#0x3d]
000c00  2812              CMP      r0,#0x12
000c02  d12c              BNE      |L1.3166|
;;;1591     {
;;;1592       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
000c04  6888              LDR      r0,[r1,#8]
000c06  f5b05f80          CMP      r0,#0x1000
000c0a  d10f              BNE      |L1.3116|
;;;1593       {
;;;1594         tmp = (uint16_t*) husart->pTxBuffPtr;
000c0c  6a4a              LDR      r2,[r1,#0x24]
;;;1595         WRITE_REG(husart->Instance->DR, (uint16_t)(*tmp & (uint16_t)0x01FF));
000c0e  8810              LDRH     r0,[r2,#0]
000c10  f3c00008          UBFX     r0,r0,#0,#9
000c14  680b              LDR      r3,[r1,#0]
000c16  6058              STR      r0,[r3,#4]
;;;1596         if(husart->Init.Parity == USART_PARITY_NONE)
000c18  6908              LDR      r0,[r1,#0x10]
000c1a  b918              CBNZ     r0,|L1.3108|
;;;1597         {
;;;1598           husart->pTxBuffPtr += 2;
000c1c  6a48              LDR      r0,[r1,#0x24]
000c1e  1c80              ADDS     r0,r0,#2
000c20  6248              STR      r0,[r1,#0x24]
000c22  e009              B        |L1.3128|
                  |L1.3108|
;;;1599         }
;;;1600         else
;;;1601         {
;;;1602           husart->pTxBuffPtr += 1;
000c24  6a48              LDR      r0,[r1,#0x24]
000c26  1c40              ADDS     r0,r0,#1
000c28  6248              STR      r0,[r1,#0x24]
000c2a  e005              B        |L1.3128|
                  |L1.3116|
;;;1603         }
;;;1604       } 
;;;1605       else
;;;1606       { 
;;;1607         WRITE_REG(husart->Instance->DR, (uint8_t)(*husart->pTxBuffPtr++ & (uint8_t)0x00FF));
000c2c  6a4b              LDR      r3,[r1,#0x24]
000c2e  1c58              ADDS     r0,r3,#1
000c30  6248              STR      r0,[r1,#0x24]
000c32  7818              LDRB     r0,[r3,#0]
000c34  680b              LDR      r3,[r1,#0]
000c36  6058              STR      r0,[r3,#4]
                  |L1.3128|
;;;1608       }
;;;1609       
;;;1610       if(--husart->TxXferCount == 0)
000c38  8d48              LDRH     r0,[r1,#0x2a]
000c3a  1e40              SUBS     r0,r0,#1
000c3c  b280              UXTH     r0,r0
000c3e  8548              STRH     r0,[r1,#0x2a]
000c40  b958              CBNZ     r0,|L1.3162|
;;;1611       {
;;;1612         /* Disable the USART Transmit data register empty Interrupt */
;;;1613         __HAL_USART_DISABLE_IT(husart, USART_IT_TXE);
000c42  6808              LDR      r0,[r1,#0]
000c44  68c0              LDR      r0,[r0,#0xc]
000c46  f0200080          BIC      r0,r0,#0x80
000c4a  680b              LDR      r3,[r1,#0]
000c4c  60d8              STR      r0,[r3,#0xc]
;;;1614   
;;;1615         /* Enable the USART Transmit Complete Interrupt */    
;;;1616         __HAL_USART_ENABLE_IT(husart, USART_IT_TC);
000c4e  6808              LDR      r0,[r1,#0]
000c50  68c0              LDR      r0,[r0,#0xc]
000c52  f0400040          ORR      r0,r0,#0x40
000c56  680b              LDR      r3,[r1,#0]
000c58  60d8              STR      r0,[r3,#0xc]
                  |L1.3162|
;;;1617       }
;;;1618       return HAL_OK;
000c5a  2000              MOVS     r0,#0
                  |L1.3164|
;;;1619     }
;;;1620     else
;;;1621     {
;;;1622       return HAL_BUSY;
;;;1623     }
;;;1624   }
000c5c  4770              BX       lr
                  |L1.3166|
000c5e  2002              MOVS     r0,#2                 ;1622
000c60  e7fc              B        |L1.3164|
;;;1625   
                          ENDP

                  USART_Receive_IT PROC
;;;1654     */
;;;1655   static HAL_StatusTypeDef USART_Receive_IT(USART_HandleTypeDef *husart)
000c62  b570              PUSH     {r4-r6,lr}
;;;1656   {
000c64  4604              MOV      r4,r0
;;;1657     uint16_t* tmp=0;
000c66  2500              MOVS     r5,#0
;;;1658     if(husart->State == HAL_USART_STATE_BUSY_RX)
000c68  f894003d          LDRB     r0,[r4,#0x3d]
000c6c  2822              CMP      r0,#0x22
000c6e  d158              BNE      |L1.3362|
;;;1659     {
;;;1660       if(husart->Init.WordLength == USART_WORDLENGTH_9B)
000c70  68a0              LDR      r0,[r4,#8]
000c72  f5b05f80          CMP      r0,#0x1000
000c76  d11c              BNE      |L1.3250|
;;;1661       {
;;;1662         tmp = (uint16_t*) husart->pRxBuffPtr;
000c78  6ae5              LDR      r5,[r4,#0x2c]
;;;1663         if(husart->Init.Parity == USART_PARITY_NONE)
000c7a  6920              LDR      r0,[r4,#0x10]
000c7c  b940              CBNZ     r0,|L1.3216|
;;;1664         {
;;;1665           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x01FF);
000c7e  6820              LDR      r0,[r4,#0]
000c80  6840              LDR      r0,[r0,#4]
000c82  f3c00008          UBFX     r0,r0,#0,#9
000c86  8028              STRH     r0,[r5,#0]
;;;1666           husart->pRxBuffPtr += 2;
000c88  6ae0              LDR      r0,[r4,#0x2c]
000c8a  1c80              ADDS     r0,r0,#2
000c8c  62e0              STR      r0,[r4,#0x2c]
000c8e  e006              B        |L1.3230|
                  |L1.3216|
;;;1667         }
;;;1668         else
;;;1669         {
;;;1670           *tmp = (uint16_t)(husart->Instance->DR & (uint16_t)0x00FF);
000c90  6820              LDR      r0,[r4,#0]
000c92  6840              LDR      r0,[r0,#4]
000c94  b2c0              UXTB     r0,r0
000c96  8028              STRH     r0,[r5,#0]
;;;1671           husart->pRxBuffPtr += 1;
000c98  6ae0              LDR      r0,[r4,#0x2c]
000c9a  1c40              ADDS     r0,r0,#1
000c9c  62e0              STR      r0,[r4,#0x2c]
                  |L1.3230|
;;;1672         }
;;;1673         if(--husart->RxXferCount != 0x00) 
000c9e  8e60              LDRH     r0,[r4,#0x32]
000ca0  1e40              SUBS     r0,r0,#1
000ca2  b280              UXTH     r0,r0
000ca4  8660              STRH     r0,[r4,#0x32]
000ca6  b1f0              CBZ      r0,|L1.3302|
;;;1674         {
;;;1675           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1676           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x01FF)); 
000ca8  f24010ff          MOV      r0,#0x1ff
000cac  6821              LDR      r1,[r4,#0]
000cae  6048              STR      r0,[r1,#4]
000cb0  e019              B        |L1.3302|
                  |L1.3250|
;;;1677         }
;;;1678       } 
;;;1679       else
;;;1680       {
;;;1681         if(husart->Init.Parity == USART_PARITY_NONE)
000cb2  6920              LDR      r0,[r4,#0x10]
000cb4  b938              CBNZ     r0,|L1.3270|
;;;1682         {
;;;1683           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x00FF);
000cb6  6820              LDR      r0,[r4,#0]
000cb8  6840              LDR      r0,[r0,#4]
000cba  b2c1              UXTB     r1,r0
000cbc  6ae2              LDR      r2,[r4,#0x2c]
000cbe  1c50              ADDS     r0,r2,#1
000cc0  62e0              STR      r0,[r4,#0x2c]
000cc2  7011              STRB     r1,[r2,#0]
000cc4  e007              B        |L1.3286|
                  |L1.3270|
;;;1684         }
;;;1685         else
;;;1686         {
;;;1687           *husart->pRxBuffPtr++ = (uint8_t)(husart->Instance->DR & (uint8_t)0x007F);
000cc6  6820              LDR      r0,[r4,#0]
000cc8  6840              LDR      r0,[r0,#4]
000cca  f000017f          AND      r1,r0,#0x7f
000cce  6ae2              LDR      r2,[r4,#0x2c]
000cd0  1c50              ADDS     r0,r2,#1
000cd2  62e0              STR      r0,[r4,#0x2c]
000cd4  7011              STRB     r1,[r2,#0]
                  |L1.3286|
;;;1688         }
;;;1689   
;;;1690         if(--husart->RxXferCount != 0x00) 
000cd6  8e60              LDRH     r0,[r4,#0x32]
000cd8  1e40              SUBS     r0,r0,#1
000cda  b280              UXTH     r0,r0
000cdc  8660              STRH     r0,[r4,#0x32]
000cde  b110              CBZ      r0,|L1.3302|
;;;1691         {
;;;1692           /* Send dummy byte in order to generate the clock for the slave to send the next data */
;;;1693           WRITE_REG(husart->Instance->DR, (DUMMY_DATA & (uint16_t)0x00FF));  
000ce0  20ff              MOVS     r0,#0xff
000ce2  6821              LDR      r1,[r4,#0]
000ce4  6048              STR      r0,[r1,#4]
                  |L1.3302|
;;;1694         }
;;;1695       }
;;;1696   
;;;1697       if(husart->RxXferCount == 0)
000ce6  8e60              LDRH     r0,[r4,#0x32]
000ce8  b9c8              CBNZ     r0,|L1.3358|
;;;1698       {
;;;1699         /* Disable the USART RXNE Interrupt */
;;;1700         __HAL_USART_DISABLE_IT(husart, USART_IT_RXNE);
000cea  6820              LDR      r0,[r4,#0]
000cec  68c0              LDR      r0,[r0,#0xc]
000cee  f0200020          BIC      r0,r0,#0x20
000cf2  6821              LDR      r1,[r4,#0]
000cf4  60c8              STR      r0,[r1,#0xc]
;;;1701   
;;;1702         /* Disable the USART Parity Error Interrupt */
;;;1703         __HAL_USART_DISABLE_IT(husart, USART_IT_PE);
000cf6  6820              LDR      r0,[r4,#0]
000cf8  68c0              LDR      r0,[r0,#0xc]
000cfa  f4207080          BIC      r0,r0,#0x100
000cfe  6821              LDR      r1,[r4,#0]
000d00  60c8              STR      r0,[r1,#0xc]
;;;1704   
;;;1705         /* Disable the USART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1706         __HAL_USART_DISABLE_IT(husart, USART_IT_ERR);
000d02  6820              LDR      r0,[r4,#0]
000d04  6940              LDR      r0,[r0,#0x14]
000d06  f0200001          BIC      r0,r0,#1
000d0a  6821              LDR      r1,[r4,#0]
000d0c  6148              STR      r0,[r1,#0x14]
;;;1707   
;;;1708         husart->State = HAL_USART_STATE_READY;
000d0e  2001              MOVS     r0,#1
000d10  f884003d          STRB     r0,[r4,#0x3d]
;;;1709         HAL_USART_RxCpltCallback(husart);
000d14  4620              MOV      r0,r4
000d16  f7fffffe          BL       HAL_USART_RxCpltCallback
;;;1710         
;;;1711         return HAL_OK;
000d1a  2000              MOVS     r0,#0
                  |L1.3356|
;;;1712       }
;;;1713       return HAL_OK;
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       return HAL_BUSY; 
;;;1718     }
;;;1719   }
000d1c  bd70              POP      {r4-r6,pc}
                  |L1.3358|
000d1e  2000              MOVS     r0,#0                 ;1713
000d20  e7fc              B        |L1.3356|
                  |L1.3362|
000d22  2002              MOVS     r0,#2                 ;1717
000d24  e7fa              B        |L1.3356|
;;;1720   
                          ENDP

                  HAL_USART_IRQHandler PROC
;;;1147     */
;;;1148   void HAL_USART_IRQHandler(USART_HandleTypeDef *husart)
000d26  b5f8              PUSH     {r3-r7,lr}
;;;1149   {
000d28  4604              MOV      r4,r0
;;;1150     uint32_t tmp_flag = 0, tmp_it_source = 0;
000d2a  2500              MOVS     r5,#0
000d2c  2600              MOVS     r6,#0
;;;1151     
;;;1152     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_PE);
000d2e  6820              LDR      r0,[r4,#0]
000d30  6800              LDR      r0,[r0,#0]
000d32  f0000501          AND      r5,r0,#1
;;;1153     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_PE);
000d36  6820              LDR      r0,[r4,#0]
000d38  68c0              LDR      r0,[r0,#0xc]
000d3a  f4007680          AND      r6,r0,#0x100
;;;1154     /* USART parity error interrupt occurred -----------------------------------*/
;;;1155     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000d3e  b125              CBZ      r5,|L1.3402|
000d40  b11e              CBZ      r6,|L1.3402|
;;;1156     {
;;;1157       husart->ErrorCode |= HAL_USART_ERROR_PE;
000d42  6c20              LDR      r0,[r4,#0x40]
000d44  f0400001          ORR      r0,r0,#1
000d48  6420              STR      r0,[r4,#0x40]
                  |L1.3402|
;;;1158     }
;;;1159   
;;;1160     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_FE);
000d4a  6820              LDR      r0,[r4,#0]
000d4c  6800              LDR      r0,[r0,#0]
000d4e  f3c00540          UBFX     r5,r0,#1,#1
;;;1161     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_ERR);
000d52  6820              LDR      r0,[r4,#0]
000d54  6940              LDR      r0,[r0,#0x14]
000d56  f0000601          AND      r6,r0,#1
;;;1162     /* USART frame error interrupt occurred ------------------------------------*/
;;;1163     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000d5a  b125              CBZ      r5,|L1.3430|
000d5c  b11e              CBZ      r6,|L1.3430|
;;;1164     {
;;;1165       husart->ErrorCode |= HAL_USART_ERROR_FE;
000d5e  6c20              LDR      r0,[r4,#0x40]
000d60  f0400004          ORR      r0,r0,#4
000d64  6420              STR      r0,[r4,#0x40]
                  |L1.3430|
;;;1166     }
;;;1167   
;;;1168     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_NE);
000d66  6820              LDR      r0,[r4,#0]
000d68  6800              LDR      r0,[r0,#0]
000d6a  f3c00580          UBFX     r5,r0,#2,#1
;;;1169     /* USART noise error interrupt occurred ------------------------------------*/
;;;1170     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000d6e  b125              CBZ      r5,|L1.3450|
000d70  b11e              CBZ      r6,|L1.3450|
;;;1171     {
;;;1172       husart->ErrorCode |= HAL_USART_ERROR_NE;
000d72  6c20              LDR      r0,[r4,#0x40]
000d74  f0400002          ORR      r0,r0,#2
000d78  6420              STR      r0,[r4,#0x40]
                  |L1.3450|
;;;1173     }
;;;1174   
;;;1175     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_ORE);
000d7a  6820              LDR      r0,[r4,#0]
000d7c  6800              LDR      r0,[r0,#0]
000d7e  f3c005c0          UBFX     r5,r0,#3,#1
;;;1176     /* USART Over-Run interrupt occurred ---------------------------------------*/
;;;1177     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000d82  b125              CBZ      r5,|L1.3470|
000d84  b11e              CBZ      r6,|L1.3470|
;;;1178     {
;;;1179       husart->ErrorCode |= HAL_USART_ERROR_ORE;
000d86  6c20              LDR      r0,[r4,#0x40]
000d88  f0400008          ORR      r0,r0,#8
000d8c  6420              STR      r0,[r4,#0x40]
                  |L1.3470|
;;;1180     }
;;;1181   
;;;1182     if(husart->ErrorCode != HAL_USART_ERROR_NONE)
000d8e  6c20              LDR      r0,[r4,#0x40]
000d90  b170              CBZ      r0,|L1.3504|
;;;1183     {
;;;1184       /* Clear all the error flag at once */
;;;1185       __HAL_USART_CLEAR_PEFLAG(husart);
000d92  bf00              NOP      
000d94  6820              LDR      r0,[r4,#0]
000d96  6800              LDR      r0,[r0,#0]
000d98  9000              STR      r0,[sp,#0]
000d9a  6820              LDR      r0,[r4,#0]
000d9c  6840              LDR      r0,[r0,#4]
000d9e  9000              STR      r0,[sp,#0]
000da0  bf00              NOP      
000da2  bf00              NOP      
;;;1186   
;;;1187       /* Set the USART state ready to be able to start again the process */
;;;1188       husart->State = HAL_USART_STATE_READY;
000da4  2001              MOVS     r0,#1
000da6  f884003d          STRB     r0,[r4,#0x3d]
;;;1189       
;;;1190       HAL_USART_ErrorCallback(husart);
000daa  4620              MOV      r0,r4
000dac  f7fffffe          BL       HAL_USART_ErrorCallback
                  |L1.3504|
;;;1191     }
;;;1192   
;;;1193     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_RXNE);
000db0  6820              LDR      r0,[r4,#0]
000db2  6800              LDR      r0,[r0,#0]
000db4  f3c01540          UBFX     r5,r0,#5,#1
;;;1194     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_RXNE);
000db8  6820              LDR      r0,[r4,#0]
000dba  68c0              LDR      r0,[r0,#0xc]
000dbc  f0000620          AND      r6,r0,#0x20
;;;1195     /* USART in mode Receiver --------------------------------------------------*/
;;;1196     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000dc0  b15d              CBZ      r5,|L1.3546|
000dc2  b156              CBZ      r6,|L1.3546|
;;;1197     {
;;;1198       if(husart->State == HAL_USART_STATE_BUSY_RX)
000dc4  f894003d          LDRB     r0,[r4,#0x3d]
000dc8  2822              CMP      r0,#0x22
000dca  d103              BNE      |L1.3540|
;;;1199       {
;;;1200         USART_Receive_IT(husart);
000dcc  4620              MOV      r0,r4
000dce  f7fffffe          BL       USART_Receive_IT
000dd2  e002              B        |L1.3546|
                  |L1.3540|
;;;1201       }
;;;1202       else
;;;1203       {
;;;1204         USART_TransmitReceive_IT(husart);
000dd4  4620              MOV      r0,r4
000dd6  f7fffffe          BL       USART_TransmitReceive_IT
                  |L1.3546|
;;;1205       }
;;;1206     }
;;;1207   
;;;1208     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TXE);
000dda  6820              LDR      r0,[r4,#0]
000ddc  6800              LDR      r0,[r0,#0]
000dde  f3c015c0          UBFX     r5,r0,#7,#1
;;;1209     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TXE);
000de2  6820              LDR      r0,[r4,#0]
000de4  68c0              LDR      r0,[r0,#0xc]
000de6  f0000680          AND      r6,r0,#0x80
;;;1210     /* USART in mode Transmitter -----------------------------------------------*/
;;;1211     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000dea  b15d              CBZ      r5,|L1.3588|
000dec  b156              CBZ      r6,|L1.3588|
;;;1212     {
;;;1213       if(husart->State == HAL_USART_STATE_BUSY_TX)
000dee  f894003d          LDRB     r0,[r4,#0x3d]
000df2  2812              CMP      r0,#0x12
000df4  d103              BNE      |L1.3582|
;;;1214       {
;;;1215         USART_Transmit_IT(husart);
000df6  4620              MOV      r0,r4
000df8  f7fffffe          BL       USART_Transmit_IT
000dfc  e002              B        |L1.3588|
                  |L1.3582|
;;;1216       }
;;;1217       else
;;;1218       {
;;;1219         USART_TransmitReceive_IT(husart);
000dfe  4620              MOV      r0,r4
000e00  f7fffffe          BL       USART_TransmitReceive_IT
                  |L1.3588|
;;;1220       }
;;;1221     }
;;;1222     
;;;1223     tmp_flag = __HAL_USART_GET_FLAG(husart, USART_FLAG_TC);
000e04  6820              LDR      r0,[r4,#0]
000e06  6800              LDR      r0,[r0,#0]
000e08  f3c01580          UBFX     r5,r0,#6,#1
;;;1224     tmp_it_source = __HAL_USART_GET_IT_SOURCE(husart, USART_IT_TC);
000e0c  6820              LDR      r0,[r4,#0]
000e0e  68c0              LDR      r0,[r0,#0xc]
000e10  f0000640          AND      r6,r0,#0x40
;;;1225     /* USART in mode Transmitter (transmission end) -----------------------------*/
;;;1226     if((tmp_flag != RESET) && (tmp_it_source != RESET))
000e14  b11d              CBZ      r5,|L1.3614|
000e16  b116              CBZ      r6,|L1.3614|
;;;1227     {
;;;1228       USART_EndTransmit_IT(husart);
000e18  4620              MOV      r0,r4
000e1a  f7fffffe          BL       USART_EndTransmit_IT
                  |L1.3614|
;;;1229     } 
;;;1230   
;;;1231   }
000e1e  bdf8              POP      {r3-r7,pc}
;;;1232   
                          ENDP

                  HAL_USART_GetState PROC
;;;1352     */
;;;1353   HAL_USART_StateTypeDef HAL_USART_GetState(USART_HandleTypeDef *husart)
000e20  4601              MOV      r1,r0
;;;1354   {
;;;1355     return husart->State;
000e22  f891003d          LDRB     r0,[r1,#0x3d]
;;;1356   }
000e26  4770              BX       lr
;;;1357   
                          ENDP

                  HAL_USART_GetError PROC
;;;1363     */
;;;1364   uint32_t HAL_USART_GetError(USART_HandleTypeDef *husart)
000e28  4601              MOV      r1,r0
;;;1365   {
;;;1366     return husart->ErrorCode;
000e2a  6c08              LDR      r0,[r1,#0x40]
;;;1367   }
000e2c  4770              BX       lr
;;;1368   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16|
#line 388 "..\\..\\..\\..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH|
#line 402
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX|
#line 587
|__asm___21_stm32f1xx_hal_usart_c_32ae8742____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
